<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Redis | 异梦的博客</title><meta name="keywords" content="Java"><meta name="author" content="异梦"><meta name="copyright" content="异梦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redies">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://yimeng436.github.io/2022/08/22/Redis/Redis/index.html">
<meta property="og:site_name" content="异梦的博客">
<meta property="og:description" content="Redies">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yimeng436.github.io/img/top.png">
<meta property="article:published_time" content="2022-08-21T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-10T17:56:08.190Z">
<meta property="article:author" content="异梦">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yimeng436.github.io/img/top.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yimeng436.github.io/2022/08/22/Redis/Redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-11 01:56:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">异梦的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-21T16:00:00.000Z" title="发表于 2022-08-22 00:00:00">2022-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-10T17:56:08.190Z" title="更新于 2024-01-11 01:56:08">2024-01-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong><center><font size=7>Redis</font></center></strong></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Remote DIctionary Server(Redis)：远程字典服务 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。</p>
<p>早期我们的数据库都是单机数据库，总共没多少人反问，那时候服务器承受的压力非常的小，慢慢的数据量和访问量都上来了之后，我们为了避免查询时间过程，或者访问同一个数据来回访问mysql服务器，所以添加上一层缓存，来存放之前访问过的内容，较好的解决了当时慢慢增长的用户和数据。</p>
<p>后来再达到一定的程度之时，就出现了mysql集群，分库分表等一些操作，一个集群分成多个部分每个部分存放一部分数据，将原本为一张表记录的所有内容进行拆分，分成多个表来存储。</p>
<p>近几年，数据量和用户量爆炸式增长，mysql等关系型数据库就不够用了，数据多，数据类型多访问量大等一些问题。</p>
<p>再加上现在很多数据，如社交网络、地理位置等，这些信息并不存在一个固定的格式，甚至是动态变化的，如果还使用mysql这样的关系型数据库来存储，一是存储格式不好确定、二是根本没办法实现动态的拓展。</p>
<p>因此Nosql就诞生了，Nosql全称  Not Only Sql，他是并不是一种以表的形式去存储数据的，它存储数据的方式有很多：K-V键值对、文档存储、图形数据库等，Nosql有以下特点：</p>
<ul>
<li>方便拓展（数据之间没有关系，很好拓展）</li>
<li>大数据量高性能</li>
<li>不要求严格一致性，只要求最终一致</li>
<li>满足CAP原则和 BASE理论</li>
<li>高性能、高可用、高可扩</li>
</ul>
<p>存储方式：</p>
<ul>
<li>K-V：<ul>
<li>Redis</li>
</ul>
</li>
<li>文档数据库（bson）：<ul>
<li>MongoDb：最像关系型数据库的非关系型数据库</li>
</ul>
</li>
<li>列存储<ul>
<li>HBase</li>
</ul>
</li>
<li>图像关系数据库<ul>
<li>首先他不是存储图像的，而是存关系的，如朋友圈社交网络，淘宝物品推荐</li>
<li>Neo4J</li>
</ul>
</li>
</ul>
<p>Redis 能干嘛：</p>
<ul>
<li><p>内存存储、持久化</p>
</li>
<li><p>效率高，可用于高速缓存</p>
</li>
<li><p>发布订阅系统</p>
</li>
<li><p>地图信息分析</p>
</li>
<li><p>计时器、计数器（浏览量）</p>
</li>
<li><p>缓存、消息队列MQ</p>
</li>
<li><p>….</p>
</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases/tag/v5.0.14.1">windows只能安装这个版本的)</a></p>
<p>安装完后测试：<br><img src="/../../images/image-20221207172148914.png" alt="image-20221207172148914"></p>
<p>服务未开启：</p>
<p>win+r：services.msc   找到redis ，右键启动</p>
<p><img src="/../../images/image-20221207172243313.png" alt="image-20221207172243313"></p>
<p>重新测试：</p>
<p><img src="/../../images/image-20221207172316078.png" alt="image-20221207172316078"></p>
<p>退出命令：shutdown</p>
<p>开启服务端：redis-server</p>
<p><img src="/../../images/image-20221207172412789.png" alt="image-20221207172412789"></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Redis 默认有16个数据库</p>
<p><img src="/../../images/image-20221207172613327.png" alt="image-20221207172613327"></p>
<p>默认使用 第0个，可以用select + 数字进行切换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 3		<span class="comment">#切换数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE		<span class="comment">#查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name zyh		<span class="comment">#新增数据</span></span><br><span class="line">OK	</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; get name		<span class="comment">#获取值</span></span><br><span class="line"><span class="string">&quot;zyh&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; keys *		<span class="comment">#查看所有的key</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; flushdb		<span class="comment">#清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[3]&gt;flushall  	<span class="comment">#清空所有数据库的内容</span></span><br></pre></td></tr></table></figure>







<ul>
<li>Redis 是单线程的（后面支持多线程了）</li>
</ul>
<p>因为官方表示，CPU不是Redis 的性能瓶颈，内存和网络带宽才是，所以就采用了单线程来实现。</p>
<ul>
<li>为什么单线程还那么快</li>
</ul>
<p>​		首先多线程不一定就比单线程快，在单核cpu下，多线程肯定存在调度问题，调度策略选择的不好肯定会导致上下文切换频繁，导致系统开销更大，速度更慢。</p>
<p>​		Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，未进行持久化前数据实在内存中的，内存读写速度比磁盘读写快。</p>
<p>​		Redis 底层的I&#x2F;O多路复用优化的很好。</p>
<h2 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><ul>
<li>首先我们知道Linux中划分了内核空间和用户空间，用户空间实际上执行的都是我们自己安装的应用程序，而内核空间就是执行的是那些能让整个操作系统正常运行的必要程序，划分的好处是用户空间不会占用到内核空间，而导致内核空间的程序出现错误，导致系统奔溃。</li>
</ul>
<p>​		用户空间只能执行一些简单的计算，内核空间可以执行任何指令，用户空间当要使用系统资源（写数据：要使用磁盘；发送socket网络套接字：使用网卡资源等）需要使用系统调用，像系统发送指令，从用户空间切换到内核空间。</p>
<ul>
<li><p>内存和磁盘之间的I&#x2F;O：</p>
<ul>
<li>PIO（已经淘汰）：很早以前，内存和磁盘之间的传输是需要CPU控制的，CPU要完成数据的存储和转发，I&#x2F;O会占用CPU大量的资源，CPU对其他事情的处理被阻塞。</li>
<li>DMA：上面那种方式显然是不合理，于是出现了DMA的方式，DMA会有一个DMA控制器，DMA控制器相当于是一个小型的CPU，开始传输时，CPU只需要对DMA控制器发送一个指令，CPU就可以转去完成其他任务，后续DMA会通过总线来完成数据的传输，完成之后会通知CPU，这样就极大的降低了CPU的占用率。</li>
</ul>
</li>
<li><p>缓存I&#x2F;O 和 直接I&#x2F;O：</p>
<ul>
<li>缓存I&#x2F;O： 当用户发起一个读请求的时候，用户空间会通过系统调用请求切换到内核空间去读磁盘，从磁盘中读取数据到内核空间的缓冲区中，在将内核空间的缓冲区传给用户空间的缓冲区，供用户应用使用。</li>
<li>直接I&#x2F;O：当用户发起一个读请求的时候，用户空间直接去访问磁盘将数据读到用户空间的缓冲区中。</li>
</ul>
</li>
<li><p>网络I&#x2F;O：</p>
<p>和自盘I&#x2F;O类似，只不过，方式变成了从一个应用通过网卡传递到另一个应用上，</p>
<p><img src="/../../images/image-20221207183334580.png" alt="image-20221207183334580"></p>
</li>
<li><p>同步I&#x2F;O和异步I&#x2F;O：</p>
<ul>
<li>同步I&#x2F;O：用户空间向内核空间请求数据，如果内核空间一直不返回给用户空间，用户空间的线程就一直等待。比如说用户程序申请I&#x2F;O时候，用户进程就会一直轮询访问去看I&#x2F;O操作是否准备就绪。</li>
<li>异步I&#x2F;O：与上面相反，如果内核一定时间内没有返回数据，就先去执行其他任务，等到内核空间返回数据时，会发送一个通知。</li>
</ul>
</li>
</ul>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name haha		</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; exists name		<span class="comment">#判断  name 这个ket存不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1		</span><br><span class="line">127.0.0.1:6379&gt; exists nam1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; move name 1			<span class="comment">#移除 键</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zyh</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire name 10		<span class="comment">#给key设置过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name		<span class="comment">#当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，									返回 key 的剩余生存时间。</span></span><br><span class="line">(<span class="built_in">integer</span>) 3						</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2					<span class="comment">#当 key 不存在时，返回 -2 </span></span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)							<span class="comment">#获取不到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name zyh</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name			<span class="comment">#查看key的类型</span></span><br><span class="line">string</span><br></pre></td></tr></table></figure>







<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;zyh&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; append name haha		<span class="comment">#追加字符串，如果不存在相当于 set，有的话就在后面追加</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;zyhhaha&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen name				<span class="comment">#查看 key 对应的字符串的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> views			<span class="comment">#可以看到redis最基本的类型就是String，没有int 那些</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; incr views			<span class="comment">#自增1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DECR views			<span class="comment">#自减1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY views 10		<span class="comment">#自增 10</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DECRBY views 5		<span class="comment">#自减 10</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>









<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;hello world&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange name 0 3		<span class="comment">#获取一个范围的值，[star，end]，左闭右闭</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange name 0 -1		<span class="comment">#-1表示到最后一个</span></span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange name 5 2		<span class="comment"># 要求start &lt; end</span></span><br><span class="line"><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setrange name 6 redis		<span class="comment"># 替换，开始下标，要替换的字符</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hello redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange name 6 redis!!		<span class="comment">#长度可以大于原来的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;hello redis!!&quot;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex age 30 <span class="string">&quot;10sui&quot;</span>		<span class="comment">#设置值时，顺便设置过期时间</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 26</span><br><span class="line">127.0.0.1:6379&gt; setnx redis redis1			<span class="comment">#setnx：set if not exits 不存在则设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx redis mongodb			<span class="comment">#设置不成功，返回0；在分布式锁中常用</span></span><br><span class="line">(<span class="built_in">integer</span>) 0									<span class="comment">#如果使用set 会覆盖</span></span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line"><span class="string">&quot;redis1&quot;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v1 k3 v3		<span class="comment">#批量增加，以空格分开</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k3&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3			<span class="comment">#批量获取</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4		<span class="comment">#批量增加每一个如果不存在增加如果存在失败，</span></span><br><span class="line">(<span class="built_in">integer</span>) 0								<span class="comment">#表示msetnx是一个原子性操作，如果一个失败全都失败</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k3&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user:1:name zhangsan	<span class="comment">#小技巧，让id复用，实际上只是让user:1:name作为key</span></span><br><span class="line">OK											<span class="comment">#但是在我们看来可以认为我们设置了一个user对象</span></span><br><span class="line">											<span class="comment">#user：&#123;id:1;name:zhangsan&#125;</span></span><br><span class="line">127.0.0.1:6379&gt; get user</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get user:1:name</span><br><span class="line"><span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:2:name lisi user:2:age 10		<span class="comment">#同上</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:2:name user:2:age</span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset db redis		<span class="comment">#先获取再设置</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongondb</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mongondb&quot;</span></span><br></pre></td></tr></table></figure>







<h2 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h2><p>大部分list 指令都是以 &#x3D;&#x3D;L&#x3D;&#x3D;  开头的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list1 two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list1 three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list1 0 -1	<span class="comment">#可以发现 list 是先进后出的，0的索引是最后放入的元素，每次都是										头插入</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush list1 right		<span class="comment">#向右，尾插入</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;right&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lpop list1			<span class="comment">#移除头元素</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list1			<span class="comment">#移除尾元素</span></span><br><span class="line"><span class="string">&quot;right&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lindex list1 0		<span class="comment">#下标获取</span></span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; llen list1			<span class="comment">#长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list1 1 one			<span class="comment">#移除元素 可以指定个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lpush list1 three</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrem list1 2 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>









<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist 4</span><br><span class="line">(<span class="built_in">integer</span>) 4							<span class="comment">#此时里面的元素应该是 4321</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2	<span class="comment">#只保留 1-2</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myanotherlist   <span class="comment">#将mylist的尾元素移除到myanotherlist的头元素</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange myanotherlist 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lset list 0 first			<span class="comment">#改变list中某个索引的值</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list 0 one			<span class="comment"># 可以连续push元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1			</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list 0 first			<span class="comment">#将0号元素设为first</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;first&quot;</span></span><br><span class="line">2) <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 0 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;4&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;1&quot;</span></span><br><span class="line">5) <span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before 3 2.5		<span class="comment">#通过before/after选择 在 某个具体的值的前后插入							目标值</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;4&quot;</span></span><br><span class="line">2) <span class="string">&quot;2.5&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">6) <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>







<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;java&quot;</span> <span class="string">&quot;C&quot;</span>		<span class="comment">#向set添加元素，可以批量添加</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd myset <span class="string">&quot;python&quot;</span>			</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset				<span class="comment">#查看所有的内容</span></span><br><span class="line">1) <span class="string">&quot;python&quot;</span></span><br><span class="line">2) <span class="string">&quot;C&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember myset java		<span class="comment">#判断存不存在   1 存在  0 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset C++</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>









<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard myset			<span class="comment">#查看set内容的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; srem myset java		<span class="comment">#移除set中的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; scard myset			</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset		<span class="comment">#随机选取一个元素</span></span><br><span class="line"><span class="string">&quot;python&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;C&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset</span><br><span class="line"><span class="string">&quot;python&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 2		<span class="comment">#随机选取指定个元素</span></span><br><span class="line">1) <span class="string">&quot;C&quot;</span></span><br><span class="line">2) <span class="string">&quot;python&quot;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;python&quot;</span></span><br><span class="line">2) <span class="string">&quot;C&quot;</span></span><br><span class="line">3) <span class="string">&quot;go&quot;</span></span><br><span class="line">4) <span class="string">&quot;C++&quot;</span></span><br><span class="line">5) <span class="string">&quot;ruby&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP myset			<span class="comment">#随机移除元素，可指定个数</span></span><br><span class="line"><span class="string">&quot;ruby&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP myset</span><br><span class="line"><span class="string">&quot;go&quot;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset java C python go</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd myset2 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 java		<span class="comment">#将某个集合中的指定元素移动到另一个集合中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;java&quot;</span></span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;python&quot;</span></span><br><span class="line">2) <span class="string">&quot;C&quot;</span></span><br><span class="line">3) <span class="string">&quot;go&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset2</span><br><span class="line">1) <span class="string">&quot;python&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff myset myset2			<span class="comment">#第一个参数中不包含再第二个参数中的元素</span></span><br><span class="line">1) <span class="string">&quot;C&quot;</span></span><br><span class="line">2) <span class="string">&quot;go&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff myset2 myset</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SINTER myset myset2			<span class="comment">#两个集合的交集</span></span><br><span class="line">1) <span class="string">&quot;python&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SUNION myset myset2			<span class="comment">#两个集合的并集</span></span><br><span class="line">1) <span class="string">&quot;C&quot;</span></span><br><span class="line">2) <span class="string">&quot;python&quot;</span></span><br><span class="line">3) <span class="string">&quot;go&quot;</span></span><br><span class="line">4) <span class="string">&quot;hello&quot;</span></span><br><span class="line">5) <span class="string">&quot;java&quot;</span></span><br></pre></td></tr></table></figure>









<h2 id="hash集合"><a href="#hash集合" class="headerlink" title="hash集合"></a>hash集合</h2><p>之前我们String 类型存的是 key -value 类型的，而现在我们存的是 key-map的一个集合。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里我们的参数多了一个字段名，存取的时候都需要指定字段名</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash name java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash name</span><br><span class="line"><span class="string">&quot;java&quot;</span></span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset myhash name python age 11		<span class="comment">#批量存储</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget myhash name age				<span class="comment">#批量取元素</span></span><br><span class="line">1) <span class="string">&quot;python&quot;</span></span><br><span class="line">2) <span class="string">&quot;11&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash					<span class="comment">#查看全部key -value</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;python&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">127.0.0.1:6379&gt; HDEL myhash name				<span class="comment">#删除指定key和value</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; hset myhash name java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash					<span class="comment">#获取hash的表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash name			<span class="comment">#判断存不存在某个key</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS myhash work</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HKEYS myhash				<span class="comment">#获取所有的key</span></span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS myhash				<span class="comment">#获取所有的value</span></span><br><span class="line">1) <span class="string">&quot;11&quot;</span></span><br><span class="line">2) <span class="string">&quot;java&quot;</span></span><br></pre></td></tr></table></figure>







<h2 id="zset有序集合"><a href="#zset有序集合" class="headerlink" title="zset有序集合"></a>zset有序集合</h2><p>增加了一个参数表示这个元素的优先级</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myzset 1 one			<span class="comment">#添加</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 3 two 2 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1			<span class="comment">#查看所有</span></span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 0 zero</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">&quot;zero&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset -inf +inf			<span class="comment">#遍历时根据得分排序，可指定范围，inf表															示∞</span></span><br><span class="line">1) <span class="string">&quot;zero&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 2 3 withscores		<span class="comment">#指定输出携带得分，指定范围2-3</span></span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">&quot;zero&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem myzset one			<span class="comment">#移除指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">&quot;zero&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br><span class="line">3) <span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zcard myzset			<span class="comment">#查看集合元素个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2		<span class="comment">#查看指定范围内的元素的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 -1 withscores		<span class="comment">#降序排序</span></span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;zero&quot;</span></span><br><span class="line">6) <span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;zero&quot;</span></span><br><span class="line">2) <span class="string">&quot;0&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;two&quot;</span></span><br><span class="line">6) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>







<h1 id="三种特殊类型"><a href="#三种特殊类型" class="headerlink" title="三种特殊类型"></a>三种特殊类型</h1><h2 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial 地理位置"></a>geospatial 地理位置</h2><p>应用包括：附件的人、打车距离等</p>
<p>需要先将地理位置加入到 集合中，一般使用java读取数据直接导入，这里还没有使用java 就只能一个个敲</p>
<p><img src="/../../images/image-20221213102408882.png" alt="image-20221213102408882"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#geoadd key  经度 纬度  名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果写错经纬度会报错</span></span><br><span class="line"><span class="comment">#127.0.0.1:6379&gt; geoadd china:city 39.90 116.40 beijing</span></span><br><span class="line"><span class="comment">#(error) ERR invalid longitude,latitude pair 39.900000,116.400000</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.230 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 36.53 chongqing 114.05 22.52 shenzheng</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing			<span class="comment">#获取指定的经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city shanghai</span><br><span class="line">1) 1) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">   2) <span class="string">&quot;31.22999903975783553&quot;</span></span><br></pre></td></tr></table></figure>





<p>给定两个具体位置求两个位置的距离，绝对距离</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai</span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai m		<span class="comment">#指定以m作为单位</span></span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km		<span class="comment">#指定以km作为单位</span></span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br></pre></td></tr></table></figure>





<p>给定一个中心，以这个中心为圆心，找出所有在指定半径内的元素(附件的人的实现，通过开启定位，实时跟新经纬度)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#待查集合 中心经度 中心维度 查找范围 单位</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzheng&quot;</span></span><br><span class="line">4) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 100 km</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km</span><br><span class="line">1) <span class="string">&quot;xian&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist		<span class="comment">#结果带上距离</span></span><br><span class="line">1) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) <span class="string">&quot;483.8340&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord 		<span class="comment">##结果带上经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment">#以集合的某个元素为中心查找</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km withcoord  </span><br><span class="line">1) 1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">      2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;36.52999959508920824&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;xian&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;108.96000176668167114&quot;</span></span><br><span class="line">      2) <span class="string">&quot;34.25999964418929977&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><p>用作基数统计的算法。什么是基数，就是一个集合去重后的真实个数。</p>
<p>所以Hyperloglog就是可以通过key去存储加入到这个集合后去重的个数，所以它只会计数不会返回具体的内容，所以他所占用的内存是很小的。</p>
<p>如：</p>
<blockquote>
<p>log &#x3D; {2,4,5,6,8,1,2,4,6,10} 这是10个元素的集合</p>
<p>经过hyperloglog的计算得到的结果就是7，因为2，4，6重复了只会被当作一个元素</p>
</blockquote>
<p>所以这个数据结构非常适合用于对于页面海量点击量的统计，记录某个页面今天有多少个独立访客访问过，或者是有多少个不同的Ip访问过这个网站。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; pfadd hyperll1 1 2 3 4 5 6 7</span><br><span class="line">(<span class="built_in">integer</span>) 1		<span class="comment">#操作成功</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd hyperll2 1 2 3 2 2 2 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount hyperll2	<span class="comment">#计数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3		<span class="comment">#去重后的结果</span></span><br><span class="line">127.0.0.1:6379&gt; PFMERGE hyperll3 hyperll1 hyperll2	<span class="comment">#将1和2两个hyperloglog聚合到ll3</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount hyperll3		<span class="comment">#同样会去重</span></span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure>





<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>这是一个由0和1表现的二进制数组，最简单的用0和1能够表示的就是有或者没有。</p>
<p>所以Bitmap也常常被用作存储是否触发某种行为或者状态统计，比如说是否签到，是否点击某个广告连接等。</p>
<p>底层实际上还是String。</p>
<p>命令：</p>
<blockquote>
<p>setbit key offset value	表示在key对应的map中的 offset这个偏移量上的值设置为 value</p>
<p>getbit key offset</p>
<p>其中 offset 是从0开始的，这个偏移占用的内存就是一个字节一组，0-7一组如果只用了0-7那就只有1字节，如果还用了第8位那就是2字节，可以通过strlen key指令查看</p>
<p>统计一个key中的1的个数</p>
<p>bitcount key</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set、get</span></span><br><span class="line">127.0.0.1:6379&gt; setbit k1 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0			<span class="comment">#100000...</span></span><br><span class="line">127.0.0.1:6379&gt; setbit k1 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0			<span class="comment">#110000...</span></span><br><span class="line">127.0.0.1:6379&gt; getbit k1 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit k1 8</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit k1 9</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit k1 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strlen</span></span><br><span class="line">127.0.0.1:6379&gt; setbit k2 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit k2 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; strlen k1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setbit k2 8 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; strlen k2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment">#bitcount</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount k2</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount k1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>











<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis中，单条命令可以保证原子性，但是事务不保证原子性。</p>
<p>Redis中的事务的本质：一组命令的集合，比如说一堆set指令，redis会先对命令进行入队，然后一条一条执行，执行过程中不会被打断，但是出错会去处理对应的错误机制。并且一个事务中的所有指令都会被序列化。</p>
<p>Redis事务没有隔离级别的概念，所有事务再开启事务之后，没有收到exec指令之前都只是入队，不会进行操作。</p>
<p>Redis事务：</p>
<ul>
<li>开启事务（multy）</li>
<li>指令入队（….）</li>
<li>执行事务（exec）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name java</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age  12 sex 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR syntax error			<span class="comment">#中间出错</span></span><br><span class="line">3) (nil)</span><br><span class="line">127.0.0.1:6379&gt; get name			<span class="comment">#事务中出错前面的语句依旧执行成功</span></span><br><span class="line"><span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; mset name python age 10 sex 1</span><br><span class="line">QUEUED		</span><br><span class="line">127.0.0.1:6379&gt; DISCARD			<span class="comment">#放弃事务，前面入队的所有指令都出队失效</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;java&quot;</span></span><br></pre></td></tr></table></figure>





<ul>
<li>编译时错误</li>
</ul>
<p>指令输入错误，使用不存在的指令，这时候整个事务里的所有指令都不会执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name java</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; sets age 10</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `sets`, with args beginning with: `age`, `10`,</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>







<ul>
<li>运行时错误</li>
</ul>
<p>语法错误，非法计算等，除了出错的其他可以正常被执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name java</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> sex 1 eat rice</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR syntax error</span><br><span class="line">4) <span class="string">&quot;java&quot;</span></span><br></pre></td></tr></table></figure>





<h1 id="redis-乐观锁-watch"><a href="#redis-乐观锁-watch" class="headerlink" title="redis 乐观锁 watch"></a>redis 乐观锁 watch</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money		<span class="comment">#监控 money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi			</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span>			<span class="comment">#正常执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>



<p>一旦事务执行成功之后监视器的就会取消掉。</p>
<p>现在再开启一个redis 服务模拟多线程并发执行的情况。</p>
<p><img src="/../../images/image-20221218184818764.png" alt="image-20221218184818764"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 10			<span class="comment">#执行之前，我们切换另一个线程修改 money的值</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment">###################################</span></span><br><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line"><span class="string">&quot;80&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 200</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span>		  <span class="comment">#修改完之后在执行提交，显示事务执行失败，所以redis的watch可以当做乐观锁使用</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>





<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; unwatch				<span class="comment">#事务提交失败之后需要先解除监视</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money			<span class="comment">#重新获取新的值</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>







<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>使用java操作redis的jar包。</p>
<p>最原始的 java官方提供的操作redis的jar包，SpringBoot对redis的封装底层都是Jedis。</p>
<ul>
<li>导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.83<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<ul>
<li>创建对象测试连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个jedis对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jedis 这个对象就可使用  redis里面的所有指令，指令名和方法名一一对应</span></span><br><span class="line">        System.out.println(jedis.ping());		<span class="comment">//输出PONG</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>测试上面写的指令</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yhz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个jedis对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jedis 这个对象就可使用  redis里面的所有指令，指令名和方法名一一对应</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;清空数据库&quot;</span>+jedis.flushDB());</span><br><span class="line">        System.out.println(<span class="string">&quot;查看是否存在key&quot;</span>+jedis.keys(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;set 一个值&quot;</span>+jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断是否存在一个key&quot;</span>+jedis.exists(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;移除一个key&quot;</span>+jedis.move(<span class="string">&quot;name&quot;</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;设置一个key并设置过期时间&quot;</span>+jedis.setex(<span class="string">&quot;name&quot;</span>,<span class="number">10</span>,<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断一个key的类型&quot;</span>+jedis.type(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;10&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;查看key对应value的字符串长度&quot;</span>+jedis.strlen(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;获取一个key&quot;</span>+jedis.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;在key对应的value后面拼接字符串&quot;</span>+jedis.append(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;岁&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;view&quot;</span>,<span class="string">&quot;100&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;自增&quot;</span>+jedis.incrBy(<span class="string">&quot;view&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;自减&quot;</span>+jedis.decrBy(<span class="string">&quot;view&quot;</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;取指定索引范围内的结果&quot;</span>+jedis.getrange(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>,<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;替换指定下标范围内的字符串&quot;</span>+jedis.setrange(<span class="string">&quot;hello&quot;</span>,<span class="number">6</span>,<span class="string">&quot;redis&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;批量添加&quot;</span>+jedis.mset(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;批量获取&quot;</span>+jedis.mget(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;view&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;money&quot;</span>,<span class="string">&quot;100&quot;</span>));</span><br><span class="line">        System.out.println(jedis.set(<span class="string">&quot;out&quot;</span>,<span class="string">&quot;0&quot;</span>));</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();          <span class="comment">//开启事务后，需要创建事务的对象，后面事务队列都是用事务对象而不是jedis对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(multi.decrBy(<span class="string">&quot;money&quot;</span>, <span class="number">20</span>));</span><br><span class="line">            System.out.println(multi.incrBy(<span class="string">&quot;out&quot;</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">            multi.set(<span class="string">&quot;object1&quot;</span>,s);</span><br><span class="line">            multi.set(<span class="string">&quot;object2&quot;</span>,s);</span><br><span class="line"></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            multi.discard();            <span class="comment">//放弃事务、</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;object1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;object2&quot;</span>));</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h1><p><img src="/../../images/image-20221219093903661.png" alt="image-20221219093903661"></p>
<p>创建SpringBoot项目 并勾选上所需要的依赖即可。</p>
<ul>
<li>依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>注意：点进依赖后会发现，SpringBoot的依赖中没有jedis的依赖，这是因为在SpringBoot2.x之后依赖都变成了 <strong>lettuce</strong> </p>
<p><img src="/../../images/image-20221219094616443.png" alt="image-20221219094616443"></p>
<p>jedis:  采用的直连，如果多个线程操作的话是不安全的，并且jedis每次连接都要去创建jedis对象，用完线程又要关闭，一来一回开销非常的大。</p>
<p>lettuce:  采用的是netty，实例可以再多个线程中进行共享，不存在不安全的情况</p>
<ul>
<li>配置文件</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">12.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">lettuce:</span>      <span class="comment">#配置线程池的时候主要使用lettuce提供的，而不是jedis提供的，因为jedis提供的线程池 默认不起作用</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>





<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作字符串的对象，后面继续用 点 访问和jedis一样的方法名</span></span><br><span class="line">    redisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作哈希</span></span><br><span class="line">    redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作Set集合</span></span><br><span class="line">    redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作List</span></span><br><span class="line">    redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//除此之外，一些常用的指令如开启事务、提交/放弃事务可以直接通过redisTemplate 进行操作</span></span><br><span class="line">    redisTemplate.multi();</span><br><span class="line">    redisTemplate.exec();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接对象</span></span><br><span class="line">    <span class="type">RedisConnection</span> <span class="variable">connection</span> <span class="operator">=</span> redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">    connection.flushAll();</span><br><span class="line">    connection.flushDb();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>现在我们要如何保存一个对象？</p>
<p>按道理，redisTemplate提供的是一个Object，Object的泛型，应该可以直接保存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是出现了序列化错误</p>
<p><img src="/../../images/image-20221219101325992.png" alt="image-20221219101325992"></p>
<p>我们让实体类实现序列化接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../../images/image-20221219101605604.png" alt="image-20221219101605604"></p>
<p>这样就能够正常执行，所以我们可以知道Redis在存对象时一定需要将对象进行序列化。</p>
<ul>
<li>除此之外，可能我们在redis-cli中查看我们插入的数据是乱码的（中文），那么在启动客户端的时候需要开启对中文支持：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 密码 -p 端口 --raw</span><br></pre></td></tr></table></figure>







<h2 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h2><p>SpringBoot所提供的RedisTemplate有一定的局限性，我们可以通过配置类的形式自定义RedisTemplate。</p>
<ul>
<li>这是默认的RedisTemplate，在RedisAutoconfiguration中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(			//当我们没有重写的时候默认才生效</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">//这里两个泛型都是Object使用时候可能还需要强制转换，不是很方便</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory 	redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<ul>
<li><p>自定义RedisTemplate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;myredisTemplate&quot;)</span>		<span class="comment">//区分底层提供的redisTemplate</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory Factory)</span> <span class="keyword">throws</span> UnknownException &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(Factory);     <span class="comment">//连接工厂</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用Jackson2JsonRedisSerializer代替 原来的JDK序列化‘</span></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer 需要指定需要序列化的类型</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Objects.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.DEFAULT);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加自定义个的配置，比如说我们要修改序列化的方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//所有的key都用 json 的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//所有hash的key都用String序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//所有的value使用JSON序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//所有的hash的value也用json序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交所有设置</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><blockquote>
<p>网络</p>
</blockquote>
<p><img src="/../../images/image-20221219122050855.png" alt="image-20221219122050855"></p>
<p>默认只绑定了本地，还可以绑定远程的ip</p>
<blockquote>
<p>通用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line"><span class="comment"># 日志的保存级别</span></span><br><span class="line">loglevel notice</span><br></pre></td></tr></table></figure>



<blockquote>
<p>快照</p>
</blockquote>
<p><img src="/../../images/image-20221219122253860.png" alt="image-20221219122253860"></p>
<p>一些持久化的配置信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三种持久化设置，</span></span><br><span class="line"><span class="comment"># 900s 内有1个key发生改变就进行一次持久化</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 300s 内有10个key发生改变就进行一次持久化</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 60s 内有10000个key发生改变就进行一次持久化</span></span><br><span class="line">save 60 10000</span><br><span class="line"><span class="comment">#可自定义修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 出错继续工作</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩rdb 持久化文件</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认rdb文件存放路径</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<blockquote>
<p>安全</p>
</blockquote>
<p><img src="/../../images/image-20221219122553633.png" alt="image-20221219122553633"></p>
<p>默认没有密码，可以在配置文件修改也可以在指令中修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">auth 123456  <span class="comment">#登录，登录后才能继续执行命令</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>内存</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy noeviction  <span class="comment">#内存满了怎么删除key的策略，noeviction是其中一种 </span></span><br></pre></td></tr></table></figure>

<p><img src="/../../images/image-20221219123116387.png" alt="image-20221219123116387"></p>
<blockquote>
<p>APPEND ONLY MODE    aof持久化 配置</p>
</blockquote>
<p>默认关闭，一般情况下 rdb就够了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同步策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always		#每次跟新都同步</span></span><br><span class="line">appendfsync everysec	<span class="comment">#每秒同步一次</span></span><br><span class="line"><span class="comment"># appendfsync no		#根据操作系统来决定什么时候同步</span></span><br></pre></td></tr></table></figure>







<h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p>首先Redis 是内存数据库，断电即失，所以数据需要持久化到硬盘上。</p>
<p>redis 在以下情况会自动生成rdb 文件：</p>
<ul>
<li>满足save 的条件</li>
<li>使用flushall命令</li>
<li>退出redis</li>
</ul>
<p>如何恢复数据：</p>
<p>只需要把rdb文件放到redis 的目录下就可以了，redis 启动时会自动检查rdb文件，恢复里面的数据</p>
<p><img src="/../../images/image-20221219124928029.png" alt="image-20221219124928029"></p>
<p><img src="/../../images/image-20221219124942023.png" alt="image-20221219124942023"></p>
<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>发布订阅是一种消息同行模式，发送者通过发送消息到一个 相当于“管道”的东西上，订阅者在“管道”上接受消息。</p>
<p><img src="/../../images/image-20221219143420559.png" alt="image-20221219143420559"></p>
<p>消息发送者将消息发送到  队列  中，订阅了这个  队列  的订阅者就可以从这个队列中拿到消息。</p>
<ul>
<li>订阅者</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel1			<span class="comment">#订阅一个频道	</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)		</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel1&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>



<ul>
<li>消息发送者</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zyh&gt;redis-cli</span><br><span class="line">127.0.0.1:6379&gt; publish channel1 ceshixiaoxi 		<span class="comment">#向频道发送消息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>



<ul>
<li>订阅者自动接收</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">&quot;message&quot;</span>			<span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;channel1&quot;</span>			<span class="comment">#来自哪个频道	</span></span><br><span class="line">3) <span class="string">&quot;ceshixiaoxi&quot;</span>		<span class="comment">#消息内容</span></span><br></pre></td></tr></table></figure>







<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主从复制是指将一台redis 服务器的数据，复制到其他redis服务器。前者为主节点，后者为从节点，数据的复制是单向的，只能从主到从。主节点以写为主，从节点以读为主。</p>
<p>默认每一台主机都是主节点，</p>
<p><img src="/../../images/image-20221219145000219.png" alt="image-20221219145000219"></p>
<p>复制三份配置文件，模拟多机的redis服务器。修改以下内容：</p>
<ul>
<li>每个服务的端口号</li>
<li>每个服务的日志文件名</li>
<li>每个服务器的pid文件</li>
<li>每个服务的dump.rdb文件</li>
</ul>
<p>分别开启三个服务，</p>
<p><img src="/../../images/image-20221219145714257.png" alt="image-20221219145714257"></p>
<p>每个服务的 role 都是 master，因为这个时候还没有进行配置，每个服务默认都是主节点，所以一般情况下也只需要配置从机。</p>
<p>所以我们在要做从机的服务下使用 SLAVEOF 指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1:6379</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1:6379</span><br></pre></td></tr></table></figure>





<ul>
<li>主机信息</li>
</ul>
<p><img src="/../../images/image-20221219150003743.png" alt="image-20221219150003743"></p>
<ul>
<li>从机信息</li>
</ul>
<p><img src="/../../images/image-20221219150046688.png" alt="image-20221219150046688"></p>
<p>主机能读能写，从机只能读不能写。</p>
<p>在主机写入一个值，可以在从机中获取，但是从机中不能够写入值。</p>
<p><img src="/../../images/image-20221219150355251.png" alt="image-20221219150355251"></p>
<p>如果主机宕机了，从机依旧可以读，并且本身还是一台从机，如果后续主机又恢复了写入的值从机依旧能够收到拿到对应的值。</p>
<p>&#x3D;&#x3D;注：如果不是在配置文件配置的从机，如果从机断开后在重新连接，默认这台设备已经不再是一台从机了，而是一台主机，不能读取主机的值。 但是只要再将这台变为从机，主机中的所有值都会重新和从机共享&#x3D;&#x3D;</p>
<p><img src="/../../images/image-20221219151111749.png" alt="image-20221219151111749"></p>
<p>这种模型有点像 BFS， 还有一种模型像DFS，是一个链表一样的，中间的那些节点后面连接另一台从机，但是实际上触了头节点其他都还是从机，不能够进行写操作。</p>
<p>当主节点宕机后，需要手动设置一台从节点为主节点，命令为  SLAVEOF no one。</p>
<p>但是上面的其实实际上都不用，手动的太不方便了，而且不够智能，所以后面出现了 哨兵模式，能够在主机宕机之后自动选出一个从机作为主机。</p>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p><img src="/../../images/image-20221219151849996.png" alt="image-20221219151849996"></p>
<p>当然实际上只用一个哨兵的话，依旧会出现问题如果哨兵  宕机了 就又出现问题了，所以还会有多哨兵模式，实际用的较多的也是多哨兵模式。</p>
<p><img src="/../../images/image-20221220084415293.png" alt="image-20221220084415293"></p>
<p>哨兵需要一个配置文件 sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心指令格式： sentinel monitor 被监视的ip  端口号  1</span></span><br><span class="line">sentinel monitor 127.0.0.1 6379 1   <span class="comment">#1表示 如果主机挂了slave投票看谁成为主机</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动哨兵</span></span><br><span class="line">redis-sentinel 配置文件路径</span><br></pre></td></tr></table></figure>



<p>如果宕机，会自动选举出一个主机，如果宕机的主机重新连接回来也没用，只能作为新主机的从机</p>
<h1 id="Redis产生的问题"><a href="#Redis产生的问题" class="headerlink" title="Redis产生的问题"></a>Redis产生的问题</h1><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-questions-02.html#redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98">javaguide</a></p>
<h1 id="进阶-linux下使用redis"><a href="#进阶-linux下使用redis" class="headerlink" title="(进阶)linux下使用redis"></a>(进阶)linux下使用redis</h1><p>下载好压缩包，然后解压。</p>
<p><img src="/../../images/image-20230305123513568.png" alt="image-20230305123513568"></p>
<p>在当前路径下执行 make 和 make install指令后，linux就会帮我们默认安装到 usr&#x2F;local&#x2F;bin这个目录下</p>
<p><img src="/../../images/image-20230305123622226.png" alt="image-20230305123622226"></p>
<ul>
<li><p>redis-benchmark：redis的性能测试工具</p>
</li>
<li><p>aof和rdb：持久化文件</p>
</li>
<li><p>cli：客户端</p>
</li>
<li><p>server：服务端</p>
</li>
<li><p>sentinel：集群配置</p>
</li>
</ul>
<p>和windows一样，启动redis服务器也需要一个配置文件，这个配置文件在我们的解压包里面</p>
<p><img src="/../../images/image-20230305124343450.png" alt="image-20230305124343450"></p>
<p>但是我们一般会保留这个配置文件，我们肯定不可能用默认的，我们拷贝一个自己的配置文件，到时候修改和读取都是使用我们自己的这个配置文件，如果发生错误还能够恢复到原来的样子。</p>
<p><img src="/../../images/image-20230305124640544.png" alt="image-20230305124640544"></p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>让redis开机在后台启动，daemonize no  —&gt;   daemonize yes</p>
<p><img src="/../../images/image-20230305125012125.png" alt="image-20230305125012125"></p>
<p>关闭redis的保护模式   yes  —&gt; no</p>
<p><img src="/../../images/image-20230305125139188.png" alt="image-20230305125139188"></p>
<p>注释掉本机绑定</p>
<p><img src="/../../images/image-20230305125423455.png" alt="image-20230305125423455"></p>
<p>启动</p>
<p><img src="/../../images/image-20230305125759993.png" alt="image-20230305125759993"></p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>上面简单介绍过redis 的持久化，但是实际上redis 持久化内容远不止这些。Redis支持多种持久化机制，RDB、AOF和RDB+AOF</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB会在指定是间内把某一时刻的数据以文件的形式写道磁盘上，这样就可以保证一定时间内的数据不会丢失。</p>
<p>快照文件就是 dump.rdb。这也是redis默认的持久化方式。</p>
<p>这个时间可以在配置文件中指定，但是redis6和redis7在设置时间上出现了一点不同。</p>
<ul>
<li>redis 6  的配置</li>
</ul>
<p><img src="/../../images/image-20230305131128192.png" alt="image-20230305131128192"></p>
<ul>
<li>redis7 的配置，redis开发者认为持久化频率不要那么频繁所以延长了持久化间隔。</li>
</ul>
<p><img src="/../../images/image-20230305131436566.png" alt="image-20230305131436566"></p>
<h3 id="RDB持久化方式"><a href="#RDB持久化方式" class="headerlink" title="RDB持久化方式"></a>RDB持久化方式</h3><h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>我们做简单的设置，如果5s内有2次修改就会进行持久化。</p>
<p><img src="/../../images/image-20230305131834063.png" alt="image-20230305131834063"></p>
<p>指定dump.rdb的保存路径</p>
<p><img src="/../../images/image-20230305132006690.png" alt="image-20230305132006690"></p>
<p>可以修改dump.rdb的文件名，单机可以不做修改，后面有多台redis时，建议加上端口号</p>
<p><img src="/../../images/image-20230305132124380.png" alt="image-20230305132124380"></p>
<p>可以在redis客户端看到我们是否修改成功。</p>
<p><img src="/../../images/image-20230305132450890.png" alt="image-20230305132450890"></p>
<ul>
<li>触发两次修改</li>
</ul>
<p><img src="/../../images/image-20230305132628462.png" alt="image-20230305132628462"></p>
<p>进入到我们的文件夹中，可以看到生成了一个新的dump文件。</p>
<p><img src="/../../images/image-20230305132659352.png" alt="image-20230305132659352"></p>
<p>我们现在用flushdb，先将当前的数据清空，然后重启服务看看能不能将文件读入我们的redis。</p>
<p>注意：我们执行flushdb的时候，redis为了保证数据一致性也会生成一次rdb文件。shutdown同理。所以在执行这两个命令之前就需要把我们的数据备份，不然我可能flushdb 清空了之后关机就会替换掉原有的有数据的rdb文件。</p>
<p>保存好有数据的rdb文件后，重启我们的redis服务，redis会在我们指定的 持久化文件中读取对应的内容。</p>
<p><img src="/../../images/image-20230305154737771.png" alt="image-20230305154737771"></p>
<h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p>redis提供了两种手动保存rdb文件的方法，save 和 bgsave。</p>
<p>bgsave：redis 会 fork出一个子进程，在不影响主进程的情况下将当前的数据写入一个零时文件中，写入完成后子进程退出，将临时文件写道rdb文件中。</p>
<p>save命令：一般不允许使用，因为他会阻塞主进程，在备份结束前不会执行任何指令。会完全保证数据一致性。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>每次持久化要fork出一个和父进程相同的子进程，费时费资源。如果同步数据量过大可能会严重影响服务器性能。</p>
</li>
<li><p>可能会丢失最近时间内的数据。</p>
</li>
<li><p>当大数据同步时，如果服务出现宕机，可能会使得rdb文件破损不完整。但是这个是可以解决的，解决方式如下：</p>
<ul>
<li>进入我们的usr&#x2F;local&#x2F;bin</li>
</ul>
<p><img src="/../../images/image-20230305171042007.png" alt="image-20230305171042007"></p>
<p>可以看到有一个检查rdb文件的命令</p>
<ul>
<li>执行这个命令可以修复简单的rdb文件破损。否则要通过其他方式找回</li>
</ul>
</li>
</ul>
<h3 id="禁用RDB"><a href="#禁用RDB" class="headerlink" title="禁用RDB"></a>禁用RDB</h3><ul>
<li><p>命令方式，本次客户端关闭前生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>conf文件设置</p>
</li>
</ul>
<p><img src="/../../images/image-20230305171738834.png" alt="image-20230305171738834"></p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF:Append Only file，这种持久化机制会，存储每一次的写指令。要恢复的时候就直接将这些指令在重新执行一遍。存储到一个 appendonly.aof文件里。</p>
<p>开启AOF模式：  no—&gt; yes</p>
<p><img src="/../../images/image-20230305172550256.png" alt="image-20230305172550256"></p>
<ul>
<li><p>为了避免频繁的IO，AOF模式开启时，不会立马将指令写入磁盘而是会在内存中开辟一个区域临时存放这些指达到一定数量时在同一写入磁盘。</p>
</li>
<li><p>AOF有三种同步策略：Always、everysec、no</p>
</li>
</ul>
<p><img src="/../../images/image-20230306085755746.png" alt="image-20230306085755746"></p>
<blockquote>
<p>Always：同时写回，有写指令就写入磁盘</p>
<p>everysec：每隔一秒写入磁盘</p>
<p>no：由操作系统指定什么时候写入磁盘</p>
</blockquote>
<p><img src="/../../images/image-20230306090042183.png" alt="image-20230306090042183"></p>
<ul>
<li>随着AOF文件内容的增加为了避免膨胀，会根据一定规则将指令合并又称AOF重写，达到压缩文件的目的。</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>开启AOF模式并且使用默认的同步策略之后我们还可以指定AOF文件的保存路径。</p>
<ul>
<li>redis6 之前，AOF和RDB公用一个指定路径</li>
<li>redis7有专门指定的存储路径。 是我们rdb指定的路径 + appenddirname</li>
</ul>
<p><img src="/../../images/image-20230306090759915.png" alt="image-20230306090759915"></p>
<p><img src="/../../images/image-20230306091656927.png" alt="image-20230306091656927"></p>
<ul>
<li>redis6之前的aof文件只有一个，但是redis7之后配置文件由三部分构成</li>
</ul>
<p><img src="/../../images/image-20230306091213182.png" alt="image-20230306091213182"></p>
<p><img src="/../../images/image-20230306091303095.png" alt="image-20230306091303095"></p>
<ul>
<li>插入数据</li>
</ul>
<p><img src="/../../images/image-20230306091932563.png" alt="image-20230306091932563"></p>
<ul>
<li>结果</li>
</ul>
<p><img src="/../../images/image-20230306092040953.png" alt="image-20230306092040953"></p>
<p>同样在执行shutdown和flushdb时候，都会被写入到aof中，所以执行这两步操作前需要多 appenddir进行备份。主要记录都是在 incr.aof中</p>
<p><img src="/../../images/image-20230306092807337.png" alt="image-20230306092807337"></p>
<p>注意：在服务器出现异常时，aof文件同样可能被破坏，并且aof文件被破坏无法启动 客户端。</p>
<p><img src="/../../images/image-20230306093031432.png" alt="image-20230306093031432"></p>
<p>和RDB一样需要到解压目录下去修复。</p>
<p><img src="/../../images/image-20230306093506302.png" alt="image-20230306093506302"></p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>当aof文件达到指定的大小之后，redis就会自动对aof文件进行压缩，会保留能够恢复数据的最小指令集。</p>
<p>也可以通过bgrewriteaof指令手动压缩。</p>
<p><img src="/../../images/image-20230306094544358.png" alt="image-20230306094544358"></p>
<p>什么叫能够恢复数据的最小指令集？</p>
<blockquote>
<p>比如说我们执行了好多次的set k1  value，重写后只会保留一句set k1 最后一次修改的值</p>
<p>set k1 v1</p>
<p>set k1 v2</p>
<p>set k1 v3</p>
<p>重写后：</p>
<p>set k1 v3</p>
</blockquote>
<ul>
<li>自动触发，修改64mb为1kb，当我们一直插入数据到1024时候发生如下变化</li>
</ul>
<p><img src="/../../images/image-20230306095221427.png" alt="image-20230306095221427"></p>
<ul>
<li>手动 bgrewriteaof效果和上面也是一样的。每次触发重写序号都会发生改变</li>
</ul>
<h2 id="AOF-RDB混合模式"><a href="#AOF-RDB混合模式" class="headerlink" title="AOF+RDB混合模式"></a>AOF+RDB混合模式</h2><ul>
<li>两种模式对比</li>
</ul>
<blockquote>
<p>对AOF而言：数据不容易丢失、灵活性较高，对于最后执行了清空操作只需要在aof文件中将对应的命令删除即可。</p>
<p>但是同样效果的aof文件比rdb文件大。</p>
</blockquote>
<p>当两种模式共存时，redis会优先加载aof文件。</p>
<ul>
<li>开启混合模式</li>
</ul>
<p><img src="/../../images/image-20230306100543852.png" alt="image-20230306100543852"></p>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>redis是客户端到服务端的模型，客户端的指令都要发给服务端在从服务端返回，那么这样大量的数据如果都要经过这样的RTT的话，除去RTT可能还会存在系统IO的时间开销，那redis速度肯定不可能这么快。</p>
<p>所以redis会和 mset指令一样，将多条指令打包一起发给服务端，服务端只需要做一次响应。</p>
<ul>
<li>管道通信模型</li>
</ul>
<p><img src="/../../images/image-20230306102807681.png" alt="image-20230306102807681"></p>
<p>使用管道需要将所有命令写道一个txt文件中，然后用cat xxx.txt 打开并通过linux管道 传给redis客户端</p>
<p><img src="/../../images/image-20230306103136349.png" alt="image-20230306103136349"></p>
<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>为了防止单点故障，所以redis实际中也是以集群的形式存在的。</p>
<p>redis分为master 主机，slave从机，master以写为主、slave以读为主。当master 数据发生变化的时，自动将数据异步跟新到slave中。</p>
<p>使用slaveof 配置的方式，前面已经演示过了，下面用配置文件配置</p>
<h2 id="配置文件配置主从设备"><a href="#配置文件配置主从设备" class="headerlink" title="配置文件配置主从设备"></a>配置文件配置主从设备</h2><ul>
<li><p>master配置</p>
<ul>
<li>daemonlize yes</li>
<li>注释bind 127.0.0.1</li>
<li>protected-mode no</li>
<li>指定端口</li>
<li>指定工作目录，dir</li>
<li>日志文件 logfile </li>
<li>dump文件的名字，dump6379.rbd</li>
<li>requirepass 指定密码</li>
</ul>
</li>
<li><p>slave配置，大部分和上面相同，多配一个指定谁为master</p>
</li>
</ul>
<p><img src="/../../images/image-20230306142113943.png" alt="image-20230306142113943"></p>
<ul>
<li>启动master，不需要指定端口</li>
</ul>
<p><img src="/../../images/image-20230306142613159.png" alt="image-20230306142613159"></p>
<ul>
<li>启动slava，必须指定端口</li>
</ul>
<p><img src="/../../images/image-20230306142637748.png" alt="image-20230306142637748"></p>
<p><img src="/../../images/image-20230306142645392.png" alt="image-20230306142645392"></p>
<p>可以在日志中查看是否出现错误，我们配置了主机的日志为  6379.log</p>
<p><img src="/../../images/image-20230306143021097.png" alt="image-20230306143021097"></p>
<p><img src="/../../images/image-20230306143334111.png" alt="image-20230306143334111"></p>
<ul>
<li>info replication 查看状态<ul>
<li>master</li>
</ul>
</li>
</ul>
<p><img src="/../../images/image-20230306143546708.png" alt="image-20230306143546708"></p>
<ul>
<li><ul>
<li>slave</li>
</ul>
</li>
</ul>
<p><img src="/../../images/image-20230306143657767.png" alt="image-20230306143657767"></p>
<ul>
<li><p>master  添加数据，slave也能够查看到数据</p>
<ul>
<li><p>master，可读写</p>
<p><img src="/../../images/image-20230306143826637.png" alt="image-20230306143826637"></p>
</li>
<li><p>slave，只可读，并且中途加进来的slave也能够获得主机写入的所有数据</p>
<p><img src="/../../images/image-20230306144017030.png" alt="image-20230306144017030"></p>
</li>
</ul>
</li>
<li><p>master宕机，slave等待master的重连。主从关系不变，<strong>这也是主从复制最大的问题所在，master宕机就会出现问题。并且master到slave信息同步会出现延迟，slave数量越多延时越明显。</strong> </p>
</li>
<li><p>slave机同样可以挂载slave，但是身份依旧是从机不能够进行写操作。</p>
</li>
</ul>
<h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p>之前的哨兵模式也讲了一些基本的内容，这边偏向实操。</p>
<p>案例中会开启三个哨兵，一主二从，共六台  ”机器“。</p>
<p><img src="/../../images/image-20230306151212339.png" alt="image-20230306151212339"></p>
<p>首先先来看一下 哨兵的配置文件 sentinel.conf。</p>
<p><img src="/../../images/image-20230306151557253.png" alt="image-20230306151557253"></p>
<ul>
<li><p>里面也包括和redis配置文件类似的很多内容：</p>
<ul>
<li>端口</li>
<li>deamonlize</li>
<li>protect-mode</li>
<li>log</li>
<li>比较重要的是</li>
</ul>
<p><img src="/../../images/image-20230306152521807.png" alt="image-20230306152521807"></p>
</li>
</ul>
<p>由于网络是不可靠的，所以有些时候是因为网络拥堵导致了哨兵无法获得主机的心跳包，让哨兵误以为主机已经宕机了，需要和其他哨兵发起投票替换这个master，只有超过了指定的quorum让这个master 进行下线。</p>
<ul>
<li>sentinel配置</li>
</ul>
<p><img src="/../../images/image-20230306154724896.png" alt="image-20230306154724896"></p>
<ul>
<li>启动主从服务</li>
</ul>
<p><img src="/../../images/image-20230306155839373.png" alt="image-20230306155839373"></p>
<ul>
<li>启动哨兵</li>
</ul>
<p><img src="/../../images/image-20230306161833306.png" alt="image-20230306161833306"></p>
<ul>
<li>查看状态</li>
</ul>
<p><img src="/../../images/image-20230306162255737.png" alt="image-20230306162255737"></p>
<p>查看sentinel的日志</p>
<p><img src="/../../images/image-20230306162736779.png" alt="image-20230306162736779"></p>
<ul>
<li>master 宕机</li>
</ul>
<p><img src="/../../images/image-20230306162936533.png" alt="image-20230306162936533"></p>
<ul>
<li>从机测试</li>
</ul>
<p><img src="/../../images/image-20230306163031276.png" alt="image-20230306163031276"></p>
<p>居然发现，出现了服务器关闭的异常？？</p>
<p>这是因为，sentinel可能在内部还在进行选举，这个时候整个系统无法进行服务。等待sentinel选举完成就能够正常运行。</p>
<p><img src="/../../images/image-20230306163149369.png" alt="image-20230306163149369"></p>
<ul>
<li>查看两个从机的状态，发现6381变成了master</li>
</ul>
<p><img src="/../../images/image-20230306163339954.png" alt="image-20230306163339954"></p>
<ul>
<li>sentinel.log，能知道就算6339回来也会变成从机</li>
</ul>
<p><img src="/../../images/image-20230306163644569.png" alt="image-20230306163644569"></p>
<p>并且原先的6379的配置文件会被追加写入，</p>
<p><img src="/../../images/image-20230306164128783.png" alt="image-20230306164128783"></p>
<p>原master的conf会新增  replicaof 新的master</p>
<p>新的master 会删掉原来的  replicaof 就的master</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>上面的log文件中有一个 SDOWN，这个就是主管下线的意思。</p>
<ul>
<li>第一步主观下线</li>
</ul>
<blockquote>
<p>SDOWN(主观不可用)是单个sentinel自己主观上检测到的关于master的状态，从sentinel的角度来看，如果发送了PING心跳后，在一定时间内没有收到合法的回复，就达到了SDOWN的条件。</p>
<p>可以在sentinel的配置文件中修改down-after-milliseconds设置主观下线的时长</p>
</blockquote>
<ul>
<li>哨兵leader</li>
</ul>
<blockquote>
<p>ODOWN  客观下线，多个哨兵达成一致让一个master下线</p>
<p>master 客观下线后，哨兵之间会选举出一个leader，来指定谁从 slave变成master，可以在log日志中的 vote-for-leader看到。</p>
<p>选举算法是通过Raft算法选举出来的，基本原理是先到先得。谁最先拿到最高票数就会被选举为leader</p>
</blockquote>
<ul>
<li>新master会根据下面这个流程图来选举</li>
</ul>
<p><img src="/../../images/image-20230307092222716.png" alt="image-20230307092222716"></p>
<blockquote>
<p>第一个比较的就是slave机的权限谁高谁就是新的master，可以在redis.conf中 slave-priority设置，越小优先级越高。</p>
<p>第二个比较的是复制的偏移量，也就是从原主机那复制的消息最新的作为新master</p>
<p>最后一个比ID，ASCII 码小的作为新master</p>
</blockquote>
<ul>
<li><p>新master执行 slave of on one成为master节点，并通过slave of其他节点控制别的从机</p>
</li>
<li><p>由于需要重新选举，选举期间服务器不可用，所以不能完全保证数据不丢失。所以推荐使用redis集群。</p>
</li>
</ul>
<h1 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h1><p>由上面引出的问题，主从+哨兵并不能保证数据不丢失，所以引出了使用redis集群。</p>
<p>主要原因也是master节点负责写，单点压力太大，所有写操作都压在一个master上容易引起单点故障。</p>
<p>拓扑图的变化</p>
<p><img src="/../../images/image-20230307093604177.png" alt="image-20230307093604177"></p>
<ul>
<li>官方的说法：</li>
</ul>
<p><img src="/../../images/image-20230307093752825.png" alt="image-20230307093752825"></p>
<ul>
<li>其他的都好理解，新多了一个槽位的概念，什么是槽位？</li>
</ul>
<p>​	首先要解释槽位需要知道redis集群另一个概念—-分片，分片其实和大学里不同的校区有点类似，每个数据都会根据某种算法映射到redis机器上。每个redis机器都是redis集群的一个分片。取数据的时候也会经过这个算法找到具体的值。</p>
<p>​	而槽位就是映射算法中槽位映射算法中的概念，根据上面的那个拓扑图，我们假设现在有三个redis集群，客户使用redis服务写入数据时并不是乱分配的，而是会先经过一个哈希算法。 会把&#x3D;&#x3D;key经过CRC16算法&#x3D;&#x3D; 和&#x3D;&#x3D;16384&#x3D;&#x3D; 进行取模，得到的结果就是一个槽位。 那么新的问题又来了为什么是16384？</p>
<p>​	16384 是因为redis集群一共有16384个槽位，每个redis服务器负责一部分的槽位，比如说第一个负责 0-5460，第二个负责5461-10922，第三个负责10923-16383，通过哈希算法得到的槽位在哪个范围就会被分配给哪个服务器。</p>
<p><img src="/../../images/image-20230307100631957.png" alt="image-20230307100631957"></p>
<ul>
<li>redis集群使用槽位和分片有什么优势？</li>
</ul>
<p>最大的优势在于，如果我们要新增和删除某个redis机器时，我们只需要对槽位进行重新分配，而不需要重新启动整个redis服务，整个redis服务器可以一直对外进行服务。</p>
<h2 id="映射算法"><a href="#映射算法" class="headerlink" title="映射算法"></a>映射算法</h2><h3 id="哈希取余映射"><a href="#哈希取余映射" class="headerlink" title="哈希取余映射"></a>哈希取余映射</h3><p>这种算法的思想和简单，根据有多少台redis机器，就把传进来的key对机器个数进行取余。</p>
<p><img src="/../../images/image-20230307100900131.png" alt="image-20230307100900131"></p>
<p>这种算法的优点就是：简单。</p>
<p>缺点：对于集群可拓展性不高，每次增加或者减少一台设备，哈希算法的取余就要改变，原先的数据要重新映射到新的机器上，在修改期间可能造成服务不可用的情况。</p>
<h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>这个算法就是为了解决分布式缓存数据变动和映射的问题，上面的问题主要就是因为分母会发生改变，如果分母不变就能够保证映射的不变性。</p>
<p> 算法提出将我们的整数的线性空间0-65535，逻辑上将0&#x3D;&#x3D;655635，使得这个线性空间在逻辑上变成一个环形空间。</p>
<p><img src="/../../images/image-20230307103621821.png" alt="image-20230307103621821"></p>
<p>然后我们将redis机器的分布到这个哈希环中，我们对redis机器的ip地址做一个hash映射，分别落在环上的不同位置。</p>
<p><img src="/../../images/image-20230307103739004.png" alt="image-20230307103739004"></p>
<p>对于用户输入的key，我们使用相同的映射方法，将key映射到环上对应的位置上，在按照顺时针方向，距离哪个节点最近就把这个key分配给哪个redis机器。</p>
<p><img src="/../../images/image-20230307103924153.png" alt="image-20230307103924153"></p>
<ul>
<li>优点</li>
</ul>
<blockquote>
<p>容错性好，一台服务器宕机了不会对其他的服务器造成影响，但是宕机的服务器逆时针到上一台服务器之间存的值会受到影响。需要将这部分数据转移到宕机服务器的下一个服务器进行存储。</p>
<p>可拓展性好，增加和减少一台机器方便。</p>
</blockquote>
<ul>
<li>缺点</li>
</ul>
<blockquote>
<p>容易造成分布不均匀，当redis节点较少的时候，可能会造成数据倾斜。数据都存到同一台服务器上。</p>
</blockquote>
<p><img src="/../../images/image-20230307104353031.png" alt="image-20230307104353031"></p>
<h3 id="哈希槽算法"><a href="#哈希槽算法" class="headerlink" title="哈希槽算法"></a>哈希槽算法</h3><p>哈希槽的本质就是一个数组，数组从0到16383。用户数据到来时，不先去找redis节点而是先去找槽，计算方法上面也说过，用CRC16计算key的哈希值，再和16383进行取模得到的结果就是对应的槽位。redis的每个节点都会平均分配槽点在某个范围内的槽点属于某个redis节点。</p>
<p><img src="/../../images/image-20230307105014872.png" alt="image-20230307105014872"></p>
<p><strong><font size=5>为什么redis的槽的个数是16384？</font></strong></p>
<p>首先为什么会提出这个问题，因为我们CRC16校验码获得的是 16bit的数据，而2<sup>16</sup> 是65536，而16384是2<sup>14</sup> ，也就是说为什么没用65536进行取余而用了 16384？</p>
<p>​	首先redis节点每过一段时间需要发送一个心跳包，让别的节点知道自己的状态。心跳包包含的内容有一个最占空间的部分就是自己负责的槽信息。</p>
<p>​	如果采用16bit的数据做槽位的话，需要发送一次心跳包的数据的大小就为 2<sup>16</sup> ➗8➗1024 &#x3D; 8kb，也就是说一次一个节点发送的心跳包的数据最少需要8kb，如果采用2<sup>14</sup> 个槽位的话就只要 2kb，相比之下8kb所占用的带宽太大的。</p>
<p>​	另一点，官网建议redis的节点不要超过1000，因为可能造成发送心跳包时网络拥堵，既然只需要1000个节点平分槽位，根本没必要拓展到65536，16384就已经够了。</p>
<p><strong><font size=5>redis集群是否保证强一致性</font></strong></p>
<p>​	不保证。因为主从复制肯定会存在延时，如果当用户写入完成还没来得及同步的时候主节点宕机了，这时候从节点就没有收到上次写入的数据，从而导致了数据的丢失。</p>
<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>三主三从，81–&gt;82，83–&gt;84，85–&gt;86</p>
<ul>
<li>配置文件，六个配置文件</li>
</ul>
<p><img src="/../../images/image-20230307120835229.png" alt="image-20230307120835229"></p>
<ul>
<li>开启所有的redis服务，可以看到备注多了一个cluster，标识当前以集群的形式启动的</li>
</ul>
<p><img src="/../../images/image-20230307121201933.png" alt="image-20230307121201933"></p>
<ul>
<li>进入cli，创建集群，分配从节点。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 1 --cluster create --cluster-replicas 1 192.168.73.129:6381 192.168.73.129:6382 192.168.73.129:6383 192.168.73.129:6384 192.168.73.129:6385 192.168.73.129:6386</span><br></pre></td></tr></table></figure>



<p>指令的意思就是 创建集群，</p>
<ul>
<li>–cluster-replicas 1 参数表示为每个master分配一个从节点</li>
<li>后面就是一个master 和一个slave的ip和端口号</li>
</ul>
<p><img src="/../../images/image-20230307122048709.png" alt="image-20230307122048709"></p>
<p><img src="/../../images/image-20230307122304059.png" alt="image-20230307122304059"></p>
<ul>
<li>6381 查看redis客户端的状态</li>
</ul>
<p><img src="/../../images/image-20230307122458562.png" alt="image-20230307122458562"></p>
<ul>
<li>cluster node查看个节点状态</li>
</ul>
<p><img src="/../../images/image-20230307122706182.png" alt="image-20230307122706182"></p>
<p>&#x3D;&#x3D;后面的端口号变成了 6391、6392、6393、6394、6395、6396&#x3D;&#x3D;</p>
<ul>
<li>尝试插入数据</li>
</ul>
<p><img src="/../../images/image-20230307185621839.png" alt="image-20230307185621839"></p>
<p>发现上来就报错了，再次尝试又可以了</p>
<p><img src="/../../images/image-20230307185700439.png" alt="image-20230307185700439"></p>
<p>这是因为我们现在的配置，属于哪个节点的key就只能在对应的节点上set，他提示的错误也很明显，说k1这个key的槽位是 12706 属于6393 这个节点上的。</p>
<p>解决：我们在启动客户端时，需要加上一个参数 c 表示会自动路由。这样就会将我们的k1自动set到6393 那个节点上了</p>
<p><img src="/../../images/image-20230307190152462.png" alt="image-20230307190152462"></p>
<ul>
<li>尝试让某个主节点宕机，演示主从切换</li>
</ul>
<p><img src="/../../images/image-20230307190715594.png" alt="image-20230307190715594"></p>
<ul>
<li>shutdown 6319，然后看94的情况</li>
</ul>
<p><img src="/../../images/image-20230307190841194.png" alt="image-20230307190841194"></p>
<ul>
<li>重连6391</li>
</ul>
<p><img src="/../../images/image-20230307191145013.png" alt="image-20230307191145013"></p>
<ul>
<li>此时可能希望恢复到原来的从属关系，可以通过指令cluster failover，执行主从调换</li>
</ul>
<p><img src="/../../images/image-20230307191305169.png" alt="image-20230307191305169"></p>
<ul>
<li>如果要新增一个节点，启动redis实例后再执行以下指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 密码 --cluster add-node 自己的ip+端口号 原来创建集群的那个节点的ip+端口号(执行redis-cli -a 1 --cluster create --cluster-replicas指令的节点)</span><br></pre></td></tr></table></figure>



<ul>
<li>加入集群后还需要重新分配槽位</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 密码 --cluster reshard ip+端口号(已经分配的节点)</span><br></pre></td></tr></table></figure>





<ul>
<li>注意，不在同一槽位的key无法使用批处理指令  mset，mget</li>
</ul>
<p><img src="/../../images/image-20230307192955506.png" alt="image-20230307192955506"></p>
<p>但是我们可以为每个key都用{}取一个备注，让他们都被set到当前的节点上。</p>
<p><img src="/../../images/image-20230307193257487.png" alt="image-20230307193257487"></p>
<p>类似于将这些key都打包。mget也是一样。</p>
<h1 id="SpringBoot整合redis连接集群"><a href="#SpringBoot整合redis连接集群" class="headerlink" title="SpringBoot整合redis连接集群"></a>SpringBoot整合redis连接集群</h1><p>集群配置</p>
<p><img src="/../../images/image-20230308095048427.png" alt="image-20230308095048427"></p>
<ul>
<li>yml</li>
</ul>
<p><img src="/../../images/image-20230308095527409.png" alt="image-20230308095527409"></p>
<ul>
<li>手动宕机 6391</li>
</ul>
<p>reids侧能够正常运行，但是java侧，直接报错找不到6391。不符合我们的需求。这是因为，java一开始正常运行感知到的时3主3从的配置，但是将6391宕机后导致redis集群变成了3主2从的拓扑结构，但是java没有收到最新的结构跟新的消息，从而出现错误。</p>
<p>解决方法：</p>
<ul>
<li>使用jedis</li>
<li>重写lettcue源码</li>
<li>增加配置项，动态感应集群拓扑</li>
</ul>
<p> <img src="/../../images/image-20230308104335694.png" alt="image-20230308104335694"></p>
<h1 id="高级部分-redis各种问题"><a href="#高级部分-redis各种问题" class="headerlink" title="(高级部分)redis各种问题"></a>(高级部分)redis各种问题</h1><h2 id="redis单线程VS多线程？"><a href="#redis单线程VS多线程？" class="headerlink" title="redis单线程VS多线程？"></a>redis单线程VS多线程？</h2><p>redis是单线程的指的是，redis对各种读写指令的完成时由一个主线程来完成的，也就是从用户输入指令，服务器端从socket中读取，解析，执行，返回等一系列过程都是redis主线程来完成的，所以对于单条指令来说redis是单线程的。</p>
<p>redis4.0之前是单线程的，因为redis是基于内存操作的，所以他的瓶颈一般是内存或者网络带宽，而不是CPU。并且单线程的设计较为简单，采用IO多路复用和非阻塞IO使得redis一样能够解决并发处理客户端的请求。但是后面随着硬件的发展硬件已经很容易出现多核的情况，redis为了跟上硬件的发展提高硬件使用率，也开始加入多线程的使用，如rdb文件存储、集群数据同步等这些又是多线程的。</p>
<p>redis单线程最大的问题：大key删除的问题。</p>
<p>上面我们已经知道redis一开始是只有一个主线程的，所有指令都是主线程来完成，所以不需要加锁但是也和加锁是一个效果。如果我们存在一个k-v，v是hash嵌套hash的结构是一个巨大的结构，此时如果要对这个key进行删除，可能会导致主线程卡顿，是得其他在使用服务的用户能够很明显感觉到相应时间变慢。</p>
<p>为了解决这个问题4.0就开始引入多线程的使用，这个时候的多线程主要是为了解决删除操作导致系统不稳定的问题。包含以下几种指令：</p>
<ul>
<li><p>unlink key</p>
</li>
<li><p>flhshdb async</p>
</li>
<li><p>flushall async</p>
</li>
</ul>
<p>这些指令redis都会再后台启动一个子线程来完成，让主线程不至于一直阻塞。</p>
<p>Redis单线程的第二个问题：redis性能真实瓶颈，到底是什么？</p>
<p><img src="/../../images/clip_image002.jpg" alt="img"></p>
<p>首先是CPU，这个官方都直接明确的说明了CPU不可能成为redis的性能瓶颈，因为他是操作内存的。而现在对于大部分电脑的内存基本上都是16-32G的，所以内存也不再是redis的瓶颈，所以如今影响redis性能主要因素是网络IO。</p>
<p>对于一开始redis一向都是以单线程为人们所熟知的，除了一些异步操作指令以外，从网络IO到实际的处理读写命令都是单线程的。这样会出现一个什么问题？随着网络硬件的提升，redis的性能瓶颈本身就有可能会出现在网络IO上，单线程对于网络IO的处理速度已经远远不如硬件的速度，导致没法充分的使用底层硬件。</p>
<p>同样为了解决这一问题，redis6&#x2F;7开始全面支持多线程。</p>
<p>这时候多线程主要为了解决的问题的是，多线程处理网络IO请求，而对于具体的单条指令的执行仍然是单线程的，这样让多个IO线程并行处理网络操作，而对于指令的执行不需要额外的进行加锁操作。</p>
<p>主线程和IO线程执行流程分为一下四个阶段：</p>
<ul>
<li>第一阶段：客户端和服务端建立socket链接，主线程会创建链接，并讲socket放入等待队列中，主线程轮询将socket绑定到IO线程</li>
<li>第二阶段：一旦主线程将socket和IO线程进行绑定之后，主线程会先进入阻塞，等待IO线程读取解析完成指令，但是因为有多个线程同时处理所以这个过程是很快的。</li>
<li>第三阶段：IO线程解析完成之后，主线程会依次按照单线程的形式来完成这些指令</li>
<li>第四阶段：主线程完成之后会将结果写入缓冲区，并且阻塞等待IO线程将结果写入socket，并返回给客户端，这个过程也是多线程并发执行的，所以也很快。</li>
</ul>
<h2 id="初谈redis为什么那么快？"><a href="#初谈redis为什么那么快？" class="headerlink" title="初谈redis为什么那么快？"></a>初谈redis为什么那么快？</h2><p>首先最基本的答案肯定是：因为redis是操作内存的并且是单线程的不需要加锁的各种处理所以redis快。但是这只是最表面的解释，往更深层次的将redis快的最主要原因是因为IO多路复用和epoll函数的使用。</p>
<h3 id="什么是IO多路复用？"><a href="#什么是IO多路复用？" class="headerlink" title="什么是IO多路复用？"></a>什么是IO多路复用？</h3><p>IO多路复用是一个网络的IO模型，uninx常见的IO模型包括： 同步阻塞 I&#x2F;O、同步非阻塞 I&#x2F;O、I&#x2F;O 多路复用、信号驱动 I&#x2F;O 和异步 I&#x2F;O。</p>
<p>同步阻塞 I&#x2F;O：应用程序发起系统调用时，整个应用程序都是阻塞的状态(无论数据是否准备完成)，直到系统调用结束，返回后应用程序才继续往下执行。这种模型不存在并发能力。</p>
<p>同步非阻塞 I&#x2F;O：应用程序发起系统调用时，应用程序不会直接处于阻塞状态，而是如果数据没有准备完成的话，程序一直会发起系统调用，直到数据准备完成，再进入阻塞状态等待系统进入内核态完成调用返回数据。相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行</strong> <strong>I&#x2F;O</strong> <strong>系统调用轮询数据是否已经准备好的过程是十分消耗 CPU</strong> <strong>资源的。</strong></p>
<p>因此还有另外的两种模式异步阻塞和异步非阻塞，同步和异步的最大区别就是应用程序被通知方式，同步都是应用程序自己去等待或者轮询，而异步是应用程序不需要去等待或者轮询，只需要发起请求后去干别的事情(<strong>非阻塞</strong>)或者也可以一直等待但是不轮询(<strong>阻塞</strong>)，等到数据准备完成之后会通过回调函数通知应用程序。</p>
<p>IO多路复用：把这个名词分成三个部分来解释，</p>
<ul>
<li><p>IO：指的就是网络IO，在操作系统层面上来看就是内核态和用户态之间的读写操作。</p>
</li>
<li><p>多路：多个客户端的链接</p>
</li>
<li><p>复用：一个线程或者多个线程的重复使用</p>
</li>
</ul>
<p>连在一起就是：一个或多个线程重复处理大量的客户端的请求操作。</p>
<p>在IO多路复用模型中通过 select&#x2F;poll&#x2F;epoll来实现调用，每一个都是前一个调用方式的优化。Redis采用的式epoll调用。后面会具体讲epoll调用。</p>
<p>举个例子：当假如有30个线程发起了系统调用，常见的有一下几种解决方式，</p>
<ul>
<li><p>依次执行系统调用，如果中间有线程的数据没有准备好，则一直等待，这种方式很像阻塞IO。</p>
</li>
<li><p>为所有的线程提供一对一的服务，有几个线程就创建一个IO线程为其服务。并发量小还能接受，如果几十万的并发量，极度浪费资源。</p>
</li>
<li><p>每个要发起系统调用的线程自己检查自己的数据准备情况，当自己的数据准备完成之后，再发起epoll系统调用，IO线程只会根据谁发起了epoll系统调用再为其服务。否则处于空闲状态。此时之后调用了epoll时，IO线程才会进入阻塞，这种模式也被称为时间驱动模式，reactor模式。</p>
</li>
</ul>
<p>Redis采用IO多路复用，充分利用单线程处理多个连接请求，一个服务端进程可以处理多个请求。</p>
<p>在redis7中，多线程默认是关闭的，可以在配置文件中开启，但是一般使用单线程就已经足够了，除非你发现自己的cpu开销不大，但是吞吐量没有明显提升可以尝试开启多线程。</p>
<p><img src="/../../images/clip_image002-16788604904412.jpg" alt="img"></p>
<h2 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h2><p>这是实际开发中肯定会遇到和需要解决的问题。常见面试可能会出现下面这些问题：</p>
<p><img src="/../../images/clip_image002-16788605036854.jpg" alt="img"></p>
<p>上面这些问题，可以分成几个分支，MoreKey问题、BigKey调优、BigKey案例。</p>
<h3 id="MoreKey问题"><a href="#MoreKey问题" class="headerlink" title="MoreKey问题"></a>MoreKey问题</h3><p>海量数据如何遍历，keys * 可以用吗？</p>
<p>答案显然是不可以的。除了key * 以外，还有flushdb、flushall 在生产上都是属于危险指令，是被明令禁止使用的指令。可能会导致cpu飙升，并且上面我们也讲过redis在执行指令时是单线程的，而keys * 依次遍历所有的key，时间复杂度为o(n)，其他指令在遍历期间都得不到执行，keys *遍历结束后，在遍历期间的所有请求一次性打到redis服务器上，出现雪崩效应，导致redis服务器宕机。</p>
<p><strong>如何禁用这些危险指令？</strong></p>
<p>在redis.conf里的有一个 security的相关配置，</p>
<p><img src="/../../images/clip_image002-16788605415306.jpg" alt="img"></p>
<p>只需要讲对应的命令设置为空即可。</p>
<p><img src="/../../images/clip_image004.jpg" alt="img"></p>
<p><strong>如果不能使用keys 那要使用什么指令进行遍历呢？</strong></p>
<p>Scan命令。Scan和mysql的limit有点类似，scan用于迭代数据库中的数据库键，类似的还有hscan，zscan，sscan</p>
<p><img src="/../../images/clip_image002-16788605515519.jpg" alt="img"></p>
<p>基本语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count] [TYPE <span class="built_in">type</span>]</span><br></pre></td></tr></table></figure>



<p>基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程以0作为游标开始一次新的代 ,直到命令返回游标0完成一次遍历不保证每次执行都返回某个给定数量的元素,支持模糊查询 一次返回的数量不可控 ,只能是大概率符合count参数。</p>
<p>游标以0开始，第一次执行游标一定是0，scan 0 [MATCH pattern] [COUNT count] [TYPE type]，他返回的第一个结果是下一次得带要用到的游标，第二个结果是默认的count条左右的数据，默认是10条。</p>
<p><img src="/../../images/clip_image002-167886058199811.jpg" alt="img"></p>
<p>比如说我现在要查找，以k开头的15个key，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scan 0 match k* count 15</span><br></pre></td></tr></table></figure>



<p><img src="/../../images/clip_image002-167886060510013.jpg" alt="img"></p>
<p>下一次遍历：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scan 458752 match k* count 15</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/clip_image002-167886062304215.jpg" alt="img"></p>
<h3 id="BigKey-案例"><a href="#BigKey-案例" class="headerlink" title="BigKey 案例"></a>BigKey 案例</h3><p><strong>一些规范</strong>：</p>
<p>String类型控制在10kb以内，hash、list、zset元素控制在5k个以内。否则就会被认为是bigkey。</p>
<p>非字符串bigkey，不要用del删除，用scan渐进式删除，并且避免同时到期触发的del自动删除。</p>
<p><strong>如何发现bigkey？</strong></p>
<p>Redis-cli –bigkeys，会给出每种数据结构的Top1的bigkey，同时给出每种数据类型的key-value个数，以及平均大小。</p>
<p>不足：只能查Top1 和平均，要查出所有的大于指定条件的bigkey无法完成，要使用的另一个指令。</p>
<p>Memory usage “key”，计算每一个key的占用的大小。</p>
<p><strong>如何删除bigkey?</strong></p>
<p>上面介绍也说过了要渐进式的删除。根据不同的类型有不同的删除方式。</p>
<ul>
<li><p>string：可以直接用del删除</p>
</li>
<li><p>hash：先使用hscan获取少量的key-value，在使用hdel，删掉对应的key，最后再讲hash的key用del删掉。</p>
</li>
<li><p>list：先使用ltrim min max，指定min-max的范围的元素才会被保留，最后在删除list的key</p>
</li>
<li><p>set：和hash一样，先使用sscan扫描出部分的元素，使用srem开始一点点删，最后删掉set对应的key</p>
</li>
<li><p>zset：zscan扫描，zrem删除，del删</p>
</li>
</ul>
<h2 id="双写一致性原则"><a href="#双写一致性原则" class="headerlink" title="双写一致性原则"></a>双写一致性原则</h2><p>双写一致性指的是，怎么保证两个数据库之间的数据是一致的，这是开发中不可能避免的问题。拿最简单的来举例，对数据跟新时，到底是先跟新redis还是先跟新mysql，不同的跟新策略有什么优劣？等各种问题。</p>
<p>常见问题：</p>
<p><img src="/../../images/image-20230315180937974.png" alt="image-20230315180937974"></p>
<p>redis充当的角色：</p>
<ul>
<li>只读缓存：这种是最简单的，我所有数据都是启动时直接输入进去的，后续我也不允许修改，也就不会存在双写的问题。</li>
<li>读写缓存：这就是会出现双写问题的，跟新策略也有以下几种<ul>
<li>同步直写策略：跟新完数据库后立刻重写redis缓存，尽可能短的时间内让数据一致。一般用于需要即时生效的场景。如：热点数据，VIP充值等</li>
<li>异步缓写策略：正常执行的过程中允许redis延迟跟新。</li>
</ul>
</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>先最简单的实现来完成以下要求：</p>
<p>根据userId查找user。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Users <span class="title function_">getUserById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userkey</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span>;</span><br><span class="line">    <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//去redis 查找</span></span><br><span class="line">    user = (Users) redisTemplate.opsForValue().get(userkey+id);</span><br><span class="line">    <span class="comment">//redis 没找到</span></span><br><span class="line">    <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">        <span class="comment">//数据库查找</span></span><br><span class="line">        user = UserMapper.selectUserById(id);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="comment">//数据库也没找到直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//数据库找到了，重写回redis，保证下次查找可以直接命中</span></span><br><span class="line">            redisTemplate.opsForValue().set(userkey+id,user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>上面这种写法是最简单的，对于并发度低的系统可以这么干。但是，在并发度很高的情况下，同时有大量的线程都去查找同一个user，并且redis都没缓存，所以一瞬间所有的请求都打到mysql服务器上了。而且mysql如果查找结果每次都会重新写入redis，导致重复写入。这些都是需要解决的问题。</p>
<p><strong><font size=5>优化</font></strong></p>
<p>利用双重校验锁的思想，我们再查数据库之前，在查一次redis，并且这次查找用互斥锁包住。这样可以保证只有一个线程会进入数据库查找，并且讲数据写入redis，后续线程在第二次查找redis的时候就可以直接从redis中拿到数据。这样可以防止大量请求压到mysql上，打爆mysql。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    Users <span class="title function_">getUserById</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userkey</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span>;</span><br><span class="line">        <span class="type">Users</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//去redis 查找</span></span><br><span class="line">        user = (Users) redisTemplate.opsForValue().get(userkey+id);</span><br><span class="line">        <span class="comment">//redis 没找到</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span>(UserService.class)&#123;</span><br><span class="line">                <span class="comment">//第二次查找redis</span></span><br><span class="line">                user = (Users) redisTemplate.opsForValue().get(userkey+id);</span><br><span class="line">                 <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">                     <span class="comment">//数据库查找</span></span><br><span class="line">                 	 user = UserMapper.selectUserById(id);</span><br><span class="line">                    <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">                        <span class="comment">//数据库也没找到直接返回null</span></span><br><span class="line">                        <span class="keyword">return</span> user;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//数据库找到了，重写回redis，保证下次查找可以直接命中</span></span><br><span class="line">                        redisTemplate.opsForValue().set(userkey+id,user);</span><br><span class="line">                    &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="一致性跟新几种策略"><a href="#一致性跟新几种策略" class="headerlink" title="一致性跟新几种策略"></a>一致性跟新几种策略</h3><p>这里的一致性需要保证的是最终一致性，因为两个数据库同步肯定会有时间开销。</p>
<p>既然是要保证最终一致性，那么就要看你到底是以谁为准了。对于redis，redis一般都是做缓存的，并且我们为了防止缓存过大，我们一般也都会给key设置过期时间，key过期了下次查找自然会将mysql里的最新数据回写到redis里。所以对于读写，切记！！我们一定是以mysql为准的。</p>
<p>所以我们确定了要以mysql为准，所以我们的跟新策略就变成了要保证mysql一定能够稳定得到跟新。在这种情况下跟新策略就分为两大类情况：</p>
<ul>
<li>可停机：这种情况就比较简单，就比如说凌晨的停机跟新，专心的搞redis和mysql数据一致。</li>
<li>&#x3D;&#x3D;不可停机&#x3D;&#x3D; ：大部分情况是不允许停机跟新的，那自然就会出现先跟新谁的问题了：<ul>
<li>先跟新数据库，在跟新redis</li>
<li>先跟新redis，在跟新数据库</li>
<li>先删除redis，在跟新数据库</li>
<li>先跟新数据库，再删除redis</li>
</ul>
</li>
</ul>
<p><strong><font size=5>先跟新数据库，在跟新redis</font></strong></p>
<p>这种跟新方式可能会出现以下两种异常情况：</p>
<ul>
<li><p>redis回写失败，当我跟新了mysql，但是准备回写的时候，redis集群可能正在执行主节点选举，导致无法响应回写。导致redis的数据没有跟新，导致redis和mysql数据不一致。下次用户读取时会读取到redis中的脏数据</p>
</li>
<li><p>高并发情况下，理想并且是预期顺序如下：</p>
<blockquote>
<p>A 跟新 mysql  –&gt;2</p>
<p>A 跟新 redis   –&gt;2</p>
<p>B 跟新 mysql –&gt;4</p>
<p>B 跟新 redis  –&gt;4</p>
<p>mysql：4，redis：4</p>
</blockquote>
<p>但是实际情况可能和这个不一样:</p>
<blockquote>
<p>A 跟新 mysql  –&gt;2</p>
<p>B 跟新 mysql –&gt;4</p>
<p>B 跟新 redis  –&gt;4</p>
<p>A 跟新 redis   –&gt;2</p>
<p>mysql：4，redis：2</p>
</blockquote>
</li>
</ul>
<p><strong><font size=5>先跟新redis，在跟新数据库</font></strong></p>
<p>这种方式可上面可能出现同样的问题</p>
<blockquote>
<p>A 跟新 redis   –&gt;2</p>
<p>B 跟新 redis  –&gt;4</p>
<p>B 跟新 mysql –&gt;4</p>
<p>A 跟新 mysql  –&gt;2</p>
<p>mysql：2，redis：4</p>
</blockquote>
<p><strong><font size=5>先删除redis，在跟新数据库</font></strong></p>
<p>这种方式看似非常合理的利用了缓存的回写机制，先把redis中的数据删除，然后下一次请求就会到mysql，并且返回结果后，mysql会回写redis。但是真实情况真的这么完美嘛？</p>
<p>考虑以下异常情况：</p>
<p>线程A准备跟新数据，此时把redis中的数据删除，但是准备跟新数据库时可能出现网络延迟等问题，导致跟新还没完成，此时线程B访问redis没有获得数据，就去mysql中查找，找到对应值时，mysql没有被跟新完成，此时线程B不仅拿到了旧数据，而且还把旧数据写回了redis。并且后续的请求都会从redis中获取旧数据。</p>
<p>这种情况也是有解决办法的，并且也经常作为面试题出现。解决办法就是延时双删。</p>
<p>延时双删是一种悲观的策略，我们本来上来直接删除redis中的数据，然后去跟新数据库，上面出现的异常情况也来自这里，就是我们在跟新数据库的时候可能有其他线程来到查询数据，发现redis没有去查mysql并且写回redis。此时我们悲观的认为，我们在写数据库的时候一定会有线程查询了数据，所以我们在执行完写数据库之后，再对redis的key做一次删除。这就叫延迟双删。</p>
<p><img src="/../../images/image-20230320183525014.png" alt="image-20230320183525014"></p>
<p>这种策略可以保证，写完数据库之后的查询一定会将新数据重写入redis，保证了双写一致性。</p>
<p><strong><font size=5>先跟新数据库，再删除redis</font></strong></p>
<p>这种方式是目前比较主流也比较合理的一种形式。以mysql为基准，跟新数据库后删除redis，等后续线程访问时，将新数据写入redis。</p>
<p>当然这个方式也不是完美的，因为可能在mysql跟新时和redis删除之前有别的线程进行数据访问，导致这些线程拿到了旧数据。但是这是上面这么多种情况中对系统伤害最小的，只有在删除redis之前的访问线程会出现脏读的情况。</p>
<p>虽然好像一切都很美好了，但是还是可能出现删除缓存异常的情况。</p>
<p>这也是实际开发中我们肯定会存在无法保证强一致性的情况，所以我们的目标是要保证最终一致性。也就是出现了删除缓存异常的情况怎么不补救？</p>
<p>我们会跟新mysql，跟新mysql就有一个binlog日志存储mysql数据变更情况，我们可以单独启动一个服务去订阅这个binlog当binlog发生改变时，这个程序会提取出改变的数据和key，去删除redis。我们还需要将删除缓存的值或者要跟新的数据暂存到消息队列中。如果删除失败，我们还可以从消息队列中取得这些值，用于下次删除或者跟新。成功操作的话，我们就要把这些值从消息队列中删除，以免重复操作，否则要再次进行尝试，超出一定次数就要向业务层汇报。</p>
<p><img src="/../../images/image-20230320201739824.png" alt="image-20230320201739824"></p>
<p>要实现这个业务我们首先就是需要有一个技术能够监听mysql数据库的binlog并且还能够通知到redis。这是一个经常要面对的东西，所以Alibaba也做了这么一个技术的开源—-canal。除了redis，他还可以通知给其他各种中间件，甚至还可以通知另一个mysql服务器。</p>
<p><img src="/../../images/image-20230321103651545.png" alt="image-20230321103651545"></p>
<p>主要的做法就是，canal回订阅 mysql主机的binlog，然后模拟自己是一台mysql从机，就可以操作mysql主机的binlog。在探讨canal工作原理之前我们先回顾一下mysql的主从复制的原理。</p>
<p>首先master有一个binlog，有修改就会跟新到这个日志文件中，从机会定时的向master的binlog日志文件进行探测，判断其是否发生改变，如果发生改变，会启动一个I&#x2F;O线程请求最新的binlog文件，同时master会启动一个dump线程向从机发送log文件，从机接收到log文件之后会将其放到本地，然后启动一个Sql线程读取二进制日志。完成一致性同步。</p>
<p>canal的工作原理就是对mysql主从复制的一个优化，几乎就是一样的。canal会向master发送dump协议，伪装自己是从机，master将binlog发送给canal，canal收到之后会以字节流的形式发送给别的中间件。</p>
<p><strong><font size=5>canal使用</font></strong></p>
<ul>
<li>先保证查询结果为on，否则要修改配置文件</li>
</ul>
<p><img src="/../../images/image-20230321110545551.png" alt="image-20230321110545551"></p>
<ul>
<li>要新增canal的授权，在mysql的user表中</li>
</ul>
<p><img src="/../../images/image-20230321110711341.png" alt="image-20230321110711341"></p>
<p>新增canal授权</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> IF <span class="keyword">EXISTS</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED <span class="keyword">BY</span><span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;canal&quot;;FLUSH PRIVILEGES;</span></span><br></pre></td></tr></table></figure>



<p><img src="/../../images/image-20230321110753222.png" alt="image-20230321110753222"></p>
<ul>
<li>mysql配置完了在配置canal</li>
</ul>
<p>配置mysql的ip地址，一个在linux一个在window，一个是虚拟机所以是通过网卡通信。</p>
<p><img src="/../../images/image-20230321111754630.png" alt="image-20230321111754630"></p>
<p>启动 &#x2F;bin&#x2F;startup.sh</p>
<p>在log里面能够看到，启动就表示启动成功</p>
<p><img src="/../../images/image-20230321112110672.png" alt="image-20230321112110672"></p>
<p><strong><font size=5>Java 操作</font></strong></p>
<ul>
<li>依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>直接使用官网的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yhz.search.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.Column;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.Entry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.EntryType;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.EventType;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.RowChange;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.RowData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCanalClientExample</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="comment">// 创建链接</span></span><br><span class="line">    <span class="type">CanalConnector</span> <span class="variable">connector</span> <span class="operator">=</span> CanalConnectors.newSingleConnector(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(AddressUtils.getHostIp(),</span><br><span class="line">                                                                                        <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);		<span class="comment">//后两个是canal的账号密码，而不是canal注册到mysql的账号密码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">emptyCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connector.connect();</span><br><span class="line">        connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);		<span class="comment">//订阅的数据库名和表明，根据具体情况改变</span></span><br><span class="line">        connector.rollback();</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalEmptyCount</span> <span class="operator">=</span> <span class="number">120</span>;</span><br><span class="line">        <span class="keyword">while</span> (emptyCount &lt; totalEmptyCount) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> connector.getWithoutAck(batchSize); <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">batchId</span> <span class="operator">=</span> message.getId();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> message.getEntries().size();</span><br><span class="line">            <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                emptyCount++;</span><br><span class="line">                System.out.println(<span class="string">&quot;empty count : &quot;</span> + emptyCount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                emptyCount = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// System.out.printf(&quot;message[batchId=%s,size=%s] \n&quot;, batchId, size);</span></span><br><span class="line">                printEntry(message.getEntries());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            connector.ack(batchId); <span class="comment">// 提交确认</span></span><br><span class="line">            <span class="comment">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;empty too many times, exit&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        connector.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEntry</span><span class="params">(List&lt;Entry&gt; entrys)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry entry : entrys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getEntryType() == EntryType.TRANSACTIONBEGIN || entry.getEntryType() == EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">RowChange</span> <span class="variable">rowChage</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rowChage = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),</span><br><span class="line">                                       e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">EventType</span> <span class="variable">eventType</span> <span class="operator">=</span> rowChage.getEventType();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;================&amp;gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                                         entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                                         entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                                         eventType));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventType == EventType.DELETE) &#123;</span><br><span class="line">                printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                printColumn(rowData.getAfterColumnsList());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------&amp;gt; before&quot;</span>);</span><br><span class="line">                printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                System.out.println(<span class="string">&quot;-------&amp;gt; after&quot;</span>);</span><br><span class="line">                printColumn(rowData.getAfterColumnsList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printColumn</span><span class="params">(List&lt;Column&gt; columns)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">        System.out.println(column.getName() + <span class="string">&quot; : &quot;</span> + column.getValue() + <span class="string">&quot;    update=&quot;</span> + column.getUpdated());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="mysql8的问题"><a href="#mysql8的问题" class="headerlink" title="mysql8的问题"></a>mysql8的问题</h4><p>canal对 mysql8 密码支持性不好，如果按照官网给出的设置方法会无法连接，我们可以在log&#x2F;example&#x2F;example.log下面看到：连接数据库异常</p>
<p><img src="/../../images/image-20230601113709836.png" alt="image-20230601113709836"></p>
<p>我们要先删掉原来的canal在数据库中的注册，然后重新用mysql5的密码编码格式注册：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;canal&#x27;@&#x27;%&#x27;;	#删除原来的canal注册</span><br><span class="line">CREATE USER &#x27;canal&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;	#重新以mysql_native_password加密方式注册，canal注册到mysql的用户密码</span><br><span class="line"></span><br><span class="line">GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;		#创建权限</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>



<p>java连接时，能够看到它帮我们订阅了我们要求的数据库的表才算成功：</p>
<p><img src="/../../images/image-20230601114207106.png" alt="image-20230601114207106"></p>
<p>数据库变化：</p>
<p><img src="/../../images/image-20230601114313898.png" alt="image-20230601114313898"></p>
<h2 id="大数据统计"><a href="#大数据统计" class="headerlink" title="大数据统计"></a>大数据统计</h2><p>现在也都知道是大数据的时代，数据需要被统计，就需要先被记录下来，Java就是这些数据的上游采集者。</p>
<p>面试题：</p>
<blockquote>
<p>1、要统计某个页面的访问量，如何统计</p>
<p>2、每个商品对应的评论，要支持排序、取topK如何实现</p>
<p>3、如何实现对某个app连续打卡用户的统计</p>
<p>。。。。</p>
</blockquote>
<p>这些题都是考察对大数据如何存取、如何展现的问题。</p>
<p>常见的统计策略：</p>
<ul>
<li>聚合统计</li>
</ul>
<p>就是通过 交集、并集、差集来实现的，最经典的实现就是QQ、微信可能认识的人，就是通过对好友之间做交集，在做差集来实现的。</p>
<ul>
<li>排序统计</li>
</ul>
<p>对于大量的评论数据，要方便实现排序展现要使用什么数据结构好呢？</p>
<blockquote>
<p>zset 我们再插入时候可以将按照时间戳为key  评论内容为value</p>
<p>有着很方便的正序遍历和逆序遍历的指令，已经分页也有直接对应的命令来实现。</p>
<p>这里说的排序是对实时性有要求的，比如说抖音视频的评论，而不是后台系统那样的</p>
</blockquote>
<ul>
<li>二值排序</li>
</ul>
<p>二值就是只有0和1，比如说记录今天是否打卡，最常用的就是bitmap</p>
<ul>
<li>基数统计</li>
</ul>
<p>这是指只统计一个集合中不重复的个数，常用在某个页面的访问量，使用hyperloglog数据结构。</p>
<p>一些专业性术语（用于和产品经理撕逼）：</p>
<ul>
<li>UV：Unque Visitor 独立访客，一般理解为客户端Ip，需要考虑去重</li>
<li>PV：Page View  页面访问量，一个页面被访问的次数，不需要考虑去重</li>
<li>DAU：Daily Active User，日活跃用户</li>
<li>MAU：Month Active User，月活跃用户</li>
</ul>
<h3 id="大数据去重方法"><a href="#大数据去重方法" class="headerlink" title="大数据去重方法"></a>大数据去重方法</h3><p>说到去重，我们应该很自然的会反应想到HashSet数据结构能够去重。并且HashSet还很友好的提供了通过一个集合构造一个set的构造方法。所以我们可以将一个集合先存起来，然后通过这个集合去生成一个HashSet。</p>
<p>这样的做法在小数据的时候是可行的，但是如果是上亿的数据量还能这样做吗？就假设我们现在的情景就是要统计一个网站的UV数量。</p>
<p>解决方法：</p>
<p>1、bitmap+hash：用hash去存储每个ip对应的bitmap的位置，bitmap就存储表示这一位上ip是否访问过。然后再通过bitcount计算出1的个数，就能够求出UV的数量。并且bitmap的存储空间占用很小对于1亿的数据存储也只需要1亿&#x2F;8 ≈ 12M，但是这里还有一个hash，这样虽然能够解决但是不是最优的办法。但是结果绝对精确</p>
<p>2、牺牲精确性来减少存储成本，因为这里只需要给我一个数量，所以hyperloglog能够很好的实现这个需要。并且再这么大量的数据情况下的UV差一点也不是很重要了，hyperloglog会有一个0.81%的误差率。</p>
<ul>
<li>java操作hyperloglog</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟不同的IP访问，加入hll</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> random.nextInt(<span class="number">256</span>)+<span class="string">&quot;.&quot;</span>+</span><br><span class="line">                    random.nextInt(<span class="number">256</span>)+<span class="string">&quot;.&quot;</span>+</span><br><span class="line">                    random.nextInt(<span class="number">256</span>)+<span class="string">&quot;.&quot;</span>+</span><br><span class="line">                    random.nextInt(<span class="number">256</span>);</span><br><span class="line">            redisTemplate.opsForHyperLogLog().add(<span class="string">&quot;hll&quot;</span>,ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHyperLogLog().size(<span class="string">&quot;hll&quot;</span>);      <span class="comment">//就相当于PFcount指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="GEO使用"><a href="#GEO使用" class="headerlink" title="GEO使用"></a>GEO使用</h2><p>现在各种app都和GPS绑定，附近的人、打车app、外卖app等等。 那这些东西又是如何实现的，这些数据又是如何存储的。</p>
<p>如果要满足实时性mysql肯定不会是选择，并且mysql只能表述一个二维的矩阵式的数据，而地理空间坐标一般是通过经纬度确定，确定之后根据这个点圆形向四面辐射的一种形式，所以mysql也不适合存储。</p>
<p>Redis的Geo就为我们解决了这些问题，指令上面有记录过这里不复写。主要就是可以通过指定某个地点的经纬度，计算两个地点之间的距离，以某个地点的经纬度为中心查找半径范围为多少的xxx。</p>
<p>Java操作，案例背景：要求可以对附近的xxx进行crud，能够找出指定范围内的xxx。</p>
<ul>
<li>添加，对饮指令：geoadd key   x   y   name</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CITY</span> <span class="operator">=</span> <span class="string">&quot;city&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">geoAdd</span><span class="params">()</span>&#123;</span><br><span class="line">    HashMap&lt;String, Point&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;天安门&quot;</span>,<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">116.39747</span>,<span class="number">39.908823</span>));</span><br><span class="line">    map.put(<span class="string">&quot;故宫&quot;</span>,<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">116.397027</span>,<span class="number">39.91799</span>));</span><br><span class="line">    map.put(<span class="string">&quot;长城&quot;</span>,<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">116.015483</span>,<span class="number">40.356585</span>));</span><br><span class="line">    redisTemplate.opsForGeo().add(CITY,map);</span><br><span class="line">    <span class="keyword">return</span> JSON.toJSONString(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取纬度坐标和hash值，对应指令：GEOPOS   key   name</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Point <span class="title function_">position</span><span class="params">(String member)</span>&#123;</span><br><span class="line">    List&lt;Point&gt; position = redisTemplate.opsForGeo().position(CITY , member);</span><br><span class="line">    <span class="keyword">return</span> position.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hash</span><span class="params">(String member)</span>&#123;</span><br><span class="line">    List&lt;String&gt; hash = redisTemplate.opsForGeo().hash(CITY , member);</span><br><span class="line">    <span class="keyword">return</span> hash.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>获取两个地点之间的距离，对应指令：GEODIST key  place1   place2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Distance <span class="title function_">distance</span><span class="params">(String place1,String plcae2)</span>&#123;</span><br><span class="line">    <span class="comment">//第四个参数是用于指定要显示为什么单位Metrics类型</span></span><br><span class="line">    <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> redisTemplate.opsForGeo().distance(CITY, place1, plcae2, Metrics.MILES);</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>给定位置为 中心，要找出半径10公里的东西，对应指令：GEORADIUS key  x   y    distance   metrics  withcoord  withcoord</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GeoResults <span class="title function_">radiusByxy</span><span class="params">(Double x,Double y)</span>&#123;</span><br><span class="line">    <span class="comment">//以 下x,y为中心，半径单位为KM</span></span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(x, y, <span class="number">10</span>*Metrics.KILOMETERS.getMultiplier());</span><br><span class="line">    <span class="comment">//指令构造器，包含中心，包含半径，限制条数</span></span><br><span class="line">    RedisGeoCommands.<span class="type">GeoRadiusCommandArgs</span> <span class="variable">args</span> <span class="operator">=</span></span><br><span class="line">            RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeCoordinates().includeDistance().limit(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; radius = redisTemplate.opsForGeo().radius(CITY, circle, args);</span><br><span class="line">    <span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>给定成员，查找出半径以内的东西。对应指令：GEORADIUSBYMEMBER   key   member   distance  metrics 	                 withcoord  withcoord</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GeoResults <span class="title function_">radiusByxyMember</span><span class="params">(String member)</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">position</span> <span class="operator">=</span> position(member);</span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(position, Metrics.KILOMETERS.getMultiplier());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    RedisGeoCommands.<span class="type">GeoRadiusCommandArgs</span> <span class="variable">args</span> <span class="operator">=</span></span><br><span class="line">                    RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeCoordinates().includeDistance().limit(<span class="number">50</span>);</span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; radius = redisTemplate.opsForGeo().radius(CITY, circle, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="海量数据的二值判断"><a href="#海量数据的二值判断" class="headerlink" title="海量数据的二值判断"></a>海量数据的二值判断</h2><p>有超大量的数据，但是这些数据只需要判断Yes&#x2F;No，比如说，有10亿的ip地址，判断这些是否在公司的白名单或者黑名单中。应该如何处理。</p>
<p>数据库肯定不现实，我们之前有学过一个 由hash函数和初始值全零的bit数组构成的数据结构，叫做布隆过滤器。它可以将一个key经过多次hash函数映射到bit数组里面，并将这一位设置为1，当查找时，当且仅当 输入的key到每一个hash函数映射的位置都为1才表示已存在。</p>
<p>回一下布隆过滤器的特点：</p>
<blockquote>
<p>查找速度块，占用的存储空间小。</p>
<p>但是只要和hash函扯上关系的都不是完美的，都不能够保证准确性的，都可能会存在hash冲突。并且布隆过滤器容易添加，但是不容易删除，当删除一个key之后无法保证能否将其对应的位置设位为1。</p>
</blockquote>
<p>布隆过滤器是否和我们上面学过的一种redis的数据类型很相似呢？Bitmap。这两者确实有很多相似之处，下面尝试用BitMap模拟实现布隆过滤器。</p>
<ul>
<li>插入流程：</li>
</ul>
<blockquote>
<p>key –&gt; 计算hash—&gt;取余–&gt;得到在bitmap中的偏移量，在这里设置为true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">whitelist</span> <span class="operator">=</span> <span class="string">&quot;poeplewhitelist:&quot;</span>;</span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">redis_key</span> <span class="operator">=</span> <span class="string">&quot;people:12&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> Math.abs(redis_key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash映射到对应的bitmap的偏移位置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">place</span> <span class="operator">=</span> (<span class="type">long</span>)(abs%Math.pow(<span class="number">2</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将偏移位置设置为1</span></span><br><span class="line">    redisTemplate.opsForValue().setBit(whitelist,place,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>查找流程</li>
</ul>
<blockquote>
<p>key—&gt;hash—&gt;取余—&gt;得到偏移量—&gt;getBit—&gt;是否为true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> Math.abs(key.hashCode());</span><br><span class="line">    <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">long</span>)(abs%Math.pow(<span class="number">2</span>,<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().getBit(whitelist,index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>除了自己实现之外，redisson提供了可直接操作的布隆过滤器，在商城项目中也使用过了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取布隆过滤器</span></span><br><span class="line">RBloomFilter&lt;Object&gt; bloomFilter = redissonClient.getBloomFilter(RedisConst.SKU_BLOOM_FILTER);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化过滤器大小和误判率</span></span><br><span class="line">bloomFilter.tryInit(<span class="number">10000</span>,<span class="number">0.001</span>);</span><br><span class="line"><span class="comment">//向过滤器中添加数据</span></span><br><span class="line">bloomFilter.add(xxxxx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">bloomFilter.contains()</span><br></pre></td></tr></table></figure>



<p>市面上用的较多的还有一个谷歌开源的Guava实现的布隆过滤器，下面尝试使用以下</p>
<ul>
<li>依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>使用‘</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">iinint</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建布隆过滤器，第一个参数要过滤的数据类型，第二个样本的数量，第三个是误判率</span></span><br><span class="line">    <span class="comment">//和redisson提供的一样，根据我们输入的样本数和误判率会自动帮我们计算会提供多少长度的bit数组，以及hash函数的个数</span></span><br><span class="line">    BloomFilter&lt;Integer&gt; integerBloomFilter = BloomFilter.create(Funnels.integerFunnel(), <span class="number">1000</span>,<span class="number">0.03</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入数据</span></span><br><span class="line">    integerBloomFilter.put(<span class="number">1</span>);</span><br><span class="line">    integerBloomFilter.put(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数据是否在布隆过滤器里面</span></span><br><span class="line">    System.out.println(integerBloomFilter.mightContain(<span class="number">1</span>));</span><br><span class="line">    System.out.println(integerBloomFilter.mightContain(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="预热、雪崩、击穿、穿透"><a href="#预热、雪崩、击穿、穿透" class="headerlink" title="预热、雪崩、击穿、穿透"></a>预热、雪崩、击穿、穿透</h2><p>预热：就是对于预防某些时刻高并发数据到达数据库，先将数据库内容写入redis，让高并发请求能够到达redis中就能够获取数据。如秒杀商品。</p>
<p>雪崩：出现雪崩的情况有两种：</p>
<blockquote>
<p>1、redis服务器突然在某一时刻宕机了，大量的请求全打到mysql中，硬件问题，运维背锅</p>
<p>2、redis的大面积的key都在同一时刻过期，比如某个活动只维持一天的，活动过期后，redis删除了，但是没有做服务降级，活动还能被访问导致大量的请求打到mysql。软件问题，开发背锅。</p>
</blockquote>
<p>解决：</p>
<blockquote>
<p>对于硬件问题，实际上主要还是预防单点故障，可以启用redis集群，保证redis的高可用，启用主从+哨兵</p>
<p>对于软件问题：</p>
<p>1、错开key的过期时间</p>
<p>2、启用多缓存，redis属于是远程的缓存，如果在必要的时候还可以通过本地缓存如currentHashMap</p>
<p>3、服务降级</p>
<p>4、充值，阿里云redis</p>
</blockquote>
<p>穿透：大量redis中不存在的key请求，导致mysql压力暴增。</p>
<p>解决：</p>
<blockquote>
<p>1、空值缓存，实际上会用，但是不配合布隆过滤器缺陷过大，因为恶意攻击可定不会一直都携带同一个key来请求，肯定是每次不同的，如果每次都存不同的key，同样拦不住恶意请求。</p>
<p>2、布隆过滤器</p>
</blockquote>
<p>击穿：和穿透看着很像，但是还是有点不同，击穿指的是，对于那些热点key，在访问过程中突然失效，导致大量的请求到达mysql，打爆mysql。 相比于穿透，发生穿透的key是一直都不存在的，而发生击穿的key是一开始存在但是突然失效的。</p>
<p>解决：</p>
<blockquote>
<p>1、错峰失效</p>
<p>2、互斥跟新、双检枷锁</p>
</blockquote>
<h3 id="击穿的案例"><a href="#击穿的案例" class="headerlink" title="击穿的案例"></a>击穿的案例</h3><ul>
<li>将数据存入redis，每30s从mysql中查找数据存入redis，假设数据是会变化的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查mysql</span></span><br><span class="line">    List&lt;People&gt; list = list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入redis</span></span><br><span class="line">    <span class="comment">//先删除原来的key，要把新的数据放进去</span></span><br><span class="line">    redisTemplate.delete(PEOPLES);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存入redis</span></span><br><span class="line">    redisTemplate.opsForList().leftPushAll(PEOPLES,list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止30s，模拟旧数据删除，新数据跟新，并且为缓存击穿做准备</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">30</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>正差查询出结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/getresult&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;People&gt; <span class="title function_">getresult</span><span class="params">(<span class="type">int</span> page,<span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="comment">//用于模拟分页，给用户一般都是从1开始，但是我们下标要求从0开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> (page-<span class="number">1</span>)*size;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start+size-<span class="number">1</span>;</span><br><span class="line">    List&lt;People&gt; peoples = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        peoples = redisTemplate.opsForList().range(<span class="string">&quot;peoples&quot;</span>, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(peoples))&#123;</span><br><span class="line">            <span class="comment">//TODO,mysql查询</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="comment">//如果出现异常，表示redis出现问题了，被击穿了</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> peoples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>正常情况下，上述代码是不会出现问题的。但是在高并发的环境下是否也能够正常运行呢？如果不可以哪部分的代码会出现问题？</p>
<blockquote>
<p>我们有个后台程序每30s会模拟进行数据的替换，先删除redis，再从mysql查找出结果存入redis。</p>
<p>这个删除和重新存入的操作，是会花费时间的，并且不是原子性操作，所以当并发量上来之后这里肯定是会出现问题的。比如如下情况：</p>
<p>此时redis正好被删除，又刚好大量的并发发起了请求，导致redis中找不到数据，直接请求了mysql，导致mysql宕机。  </p>
</blockquote>
<ul>
<li>解决方法</li>
</ul>
<blockquote>
<p>1、双检枷锁，之前已经介绍过了</p>
<p>2、差异失效时间，构建两个redis，同一份数据再两个redis中存储的过期时间间隔几秒钟。并且要求，跟新时一定先跟新过期时间晚的redis，请求时一定请求过期时间早的redis。这样再没过期之前的请求都可以由过期早的返回，过期了就能够去找过期时间晚的redis保底。</p>
<p>当过期时间早的redis失效时，有新的请求到来时候不会因为找不到redis的数据而打爆mysql，而是查找了慢过期的redis的旧数据。</p>
</blockquote>
<ul>
<li>差异失效时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=========存数据============</span></span><br><span class="line"></span><br><span class="line">redisTemplate.delete(PEOPLESB);</span><br><span class="line"><span class="comment">//存入redis，先过期时间长的跟新</span></span><br><span class="line">redisTemplate.opsForList().leftPushAll(PEOPLESB,list);</span><br><span class="line">redisTemplate.expire(PEOPLESB,<span class="number">70</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redisTemplate.delete(PEOPLESA);</span><br><span class="line"><span class="comment">//存入redis</span></span><br><span class="line">redisTemplate.opsForList().leftPushAll(PEOPLESA,list);</span><br><span class="line">redisTemplate.expire(PEOPLESA,<span class="number">60</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//===========取数据===========</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    peoples = redisTemplate.opsForList().range(<span class="string">&quot;peoplesa&quot;</span>, start, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(peoples))&#123;</span><br><span class="line">        <span class="comment">//A的过期了，可以去找B的保底获得旧数据</span></span><br><span class="line">        peoples = redisTemplate.opsForList().range(<span class="string">&quot;peoplesb&quot;</span>, start, end);</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(peoples))&#123;</span><br><span class="line">            <span class="comment">//TODO,mysql查询</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">//如果出现异常，表示redis出现问题了，被击穿了</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>这一部分可谓是重中之重了，有大量的东西需要了解。</p>
<p>简单的面试题：</p>
<p>redis除了被你用作缓存，还用过做什么？</p>
<blockquote>
<p>1、分布式锁</p>
<p>2、简单的消息队列，list</p>
<p>3、实现打开签到，bitmap</p>
<p>4、布隆过滤器，list+map</p>
<p>5、共同好友，list的交集、并集、差集</p>
<p>6、附近的xxxx，GEO</p>
<p>7、浏览量、点赞，hyperloglog </p>
</blockquote>
<p>难面试题</p>
<p><img src="/../../images/image-20230410103613521.png" alt="image-20230410103613521"></p>
<p>简单谈谈为什么要出现分布式锁？synchronized无法完成嘛？</p>
<blockquote>
<p>synchronized是本地锁，他只能管理自己的进程或者是自己的JVM的部分，在集群部署下，每个服务的本地锁都只能保证自己的数据一致，无法保证其他模块也能够一致。因此synchronized这样的本地锁就无法完成在分布式环境下的数据安全。我们一般通过setnx指令来实现分布式锁，当多个服务要进入同步代码块之前要通过setnx指令查看自己能否获取进入同步代码块的权限，只有setnx成功才能够往下执行，否则一直重试。执行完同步代码块的程序也需要释放掉自己的setnx上的锁，让其他等待的服务进入。</p>
</blockquote>
<p>如果要你考虑实现一个分布式锁，需要考虑哪些条件？</p>
<blockquote>
<p>1、独占性：只有一个线程能够占有锁</p>
<p>2、可重入：对于同一个线程进入同一个代码不需要重新申请资源，如递归函数中线程A获取锁再调用这个函数时候不会要等待重新申请</p>
<p>3、高可用：redis集群下，不会因为某个节点宕机了而出现获取锁和释放锁的情况</p>
<p>4、不死锁：不会出现死锁</p>
<p>5、不乱抢：不会出现别的线程将另一个线程的锁释放的情况</p>
</blockquote>
<h3 id="搭建base版本的模块"><a href="#搭建base版本的模块" class="headerlink" title="搭建base版本的模块"></a>搭建base版本的模块</h3><p>​	案例背景：就是两个同样的服务通过请求会去减少redis中库存的数量，初始数量是100。</p>
<ul>
<li>业务：单机加锁防止数据不安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> StringUtils.isEmpty(ticket)? <span class="number">0</span>:Integer.parseInt(ticket);</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,String.valueOf(--num));</span><br><span class="line">             message = <span class="string">&quot;成功输出一张票，剩余&quot;</span>+num;</span><br><span class="line">            System.out.println(message+<span class="string">&quot;端口号：&quot;</span>+port);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            message = <span class="string">&quot;已售空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面代码在单机情况下肯定是不会出现问题的，但是我们拷贝一份7777程序。端口号为7778，并且用nginx做反向代理和负载均衡，再次访问。</p>
<p><img src="/../../images/image-20230410144421479.png" alt="image-20230410144421479"></p>
<p><img src="/../../images/image-20230410144427565.png" alt="image-20230410144427565"></p>
<p>同样一切都是那么的美好，我们先回复一下数据为100，然后用 jemeter模拟高并发测试。</p>
<ul>
<li>添加一个线程组，1秒钟100次请求</li>
</ul>
<p><img src="/../../images/image-20230410150810811.png" alt="image-20230410150810811"></p>
<ul>
<li>添加要用于测试的http请求</li>
</ul>
<p><img src="/../../images/image-20230410150830229.png" alt="image-20230410150830229"></p>
<ul>
<li>测试结果</li>
</ul>
<p><img src="/../../images/image-20230410151139859.png" alt="image-20230410151139859"></p>
<p>发现明明我们加了锁，但是还是出现了数据异常的情况。</p>
<p>原因和我们上面讲的也是一样的：由于在分布式环境下，竞争的节点可能不在同一个JVM中，而lock和sync这样的本地锁都只能控制自己的JVM环境，因此无法锁住。要想解决这个问题需要有一个锁能够同时被不同的节点反问。</p>
<h3 id="代码优化1"><a href="#代码优化1" class="headerlink" title="代码优化1"></a>代码优化1</h3><p>​	上面也说了本地lock无法解决不同节点之间对于同步资源的访问，在商城项目中我们也做过简单的了解，就是使用redis的setnx可以实现分布式锁。下面我们就用setxn对上上面的代码进行优化。</p>
<ul>
<li>setnx优化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock_flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(lock, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lock_flag)&#123;</span><br><span class="line">        <span class="comment">//加锁成功，可以去操作redis</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> StringUtils.isEmpty(ticket)? <span class="number">0</span>:Integer.parseInt(ticket);</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,String.valueOf(--num));</span><br><span class="line">            message = <span class="string">&quot;成功输出一张票，剩余&quot;</span>+num;</span><br><span class="line">            System.out.println(message+<span class="string">&quot;端口号：&quot;</span>+port);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            message = <span class="string">&quot;已售空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.delete(lock);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//没有拿到锁的，递归重试获取锁</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        sell();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message+<span class="string">&quot;端口号：&quot;</span>+port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>测试，这样我们的数据就没有再出现异常了</li>
</ul>
<p><img src="/../../images/image-20230410154231088.png" alt="image-20230410154231088"></p>
<ul>
<li>1000次测试，也能够通过</li>
</ul>
<p><img src="/../../images/image-20230410154941234.png" alt="image-20230410154941234"></p>
<p>上面的代码只是实现了我们希望完成的功能，但是是否存在问题呢？</p>
<blockquote>
<p>大问题没有，但是性能非常的差，1000次的并发虽然通过了那如果我并发量达到一万甚至十万呢?递归尝试不仅非常耗时，而且递归调用JVM的堆非常容易溢出。</p>
</blockquote>
<p>在并发变成中，一般会使用自旋锁代替递归获取锁，通过while自旋获取锁</p>
<ul>
<li>while自旋锁优化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stringRedisTemplate.opsForValue().setIfAbsent(lock, <span class="string">&quot;1&quot;</span>))&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁成功，可以去操作redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> StringUtils.isEmpty(ticket)? <span class="number">0</span>:Integer.parseInt(ticket);</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,String.valueOf(--num));</span><br><span class="line">        message = <span class="string">&quot;成功输出一张票，剩余&quot;</span>+num;</span><br><span class="line">        System.out.println(message+<span class="string">&quot;端口号：&quot;</span>+port);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        message = <span class="string">&quot;已售空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stringRedisTemplate.delete(lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message+<span class="string">&quot;端口号：&quot;</span>+port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>上面的代码已经可以应对大部分的问题了，但是还是不够完美还有部分会出现问题：</p>
<blockquote>
<p>一般来说我们的redis的key都是需要设置时间的，尤其是分布式锁的key。因为如果不设置过期时间，有一个线程获取锁之后，如果在业务逻辑中出现了死循环，或者redis服务器整个宕机了，导致这个redis分布式锁的key一直无法被释放，所以我们还需要对key设置相应的过期时间。</p>
</blockquote>
<p>加上了过期时间解决了锁无法被释放的隐患，同时带来了另外一个麻烦：</p>
<blockquote>
<p>如果我的锁过期了但是业务逻辑还没有执行完怎么办，锁已经被释放了，下一个线程会进来执行自己的业务，在新线程执行的过程中，我旧线程又执行完成了，又会手动的释放锁，一来一回导致锁根本无法起效。</p>
<p>出现这个问题的主要原因就是我们使用了同一个key-value作为分布式锁，我们可以将锁对应的value设置为每个线程唯一的值，如线程Id，每次线程要释放的时候可以去判断当前的锁是不是自己上的，如果不是就不予释放。</p>
</blockquote>
<ul>
<li>过期和误删优化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加上线程Id，唯一标识是哪个线程上的锁，防止误删 设置锁的过期时间</span></span><br><span class="line">    <span class="keyword">while</span>(!stringRedisTemplate.opsForValue().</span><br><span class="line">            setIfAbsent(lock, String.valueOf(Thread.currentThread().getId()),<span class="number">10</span>,TimeUnit.MINUTES))&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁成功，可以去操作redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> StringUtils.isEmpty(ticket)? <span class="number">0</span>:Integer.parseInt(ticket);</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,String.valueOf(--num));</span><br><span class="line">        message = <span class="string">&quot;成功输出一张票，剩余&quot;</span>+num;</span><br><span class="line">        System.out.println(message+<span class="string">&quot;端口号：&quot;</span>+port);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        message = <span class="string">&quot;已售空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(lock);</span><br><span class="line">    <span class="comment">//自己上的锁才能被释放</span></span><br><span class="line">    <span class="keyword">if</span>(String.valueOf(Thread.currentThread().getId()).equals(threadId))&#123;</span><br><span class="line">        stringRedisTemplate.delete(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> message+<span class="string">&quot;端口号：&quot;</span>+port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>上面的优化已经能够解决95%以上的问题了，但是还是有一些比较刁钻的角度可以让上面的代码出现问题：</p>
<blockquote>
<p>上面的代码我们加上了对是否是自己的上的锁防止误删的优化，但是能够100%保证不会误删呢？</p>
<p>考虑这么一种情况，当前线程判断通过了在准备删除时候，key过期了，并且又在这时另一个线程加上了锁，然后当前线程又对这个锁进行了删除，导致了误删。虽然条件比较苛刻，但是还是有可能会出现的。</p>
</blockquote>
<p>导致上述问题的根本原因在于：查询和删除两个操作不是原子操作，中间的时间间隔可能会出现上下文切换，所以我们需要保证查找和删除是原子操作，需要用到啊lua脚本。</p>
<p><strong><font size=5>简单介绍一下lua脚本</font></strong></p>
<p>lua脚本使用C语言编写的，lua脚本通过eval命令可以保证里面执行的代码是原子性的，并且可以用c语言的return作为脚本执行的结果。</p>
<p><img src="/../../images/image-20230410170203546.png" alt="image-20230410170203546"></p>
<p>eval命令的格式：eval  lua脚本  key的个数  key   参数</p>
<ul>
<li>helloworld：</li>
</ul>
<p><img src="/../../images/image-20230410170407270.png" alt="image-20230410170407270"></p>
<p>脚本要求一定要有返回值，所以需要用return来表示执行结果。</p>
<p>在lua脚本中，如果我们要调用redis的命令，直接通过redis.call(命令，参数)。</p>
<ul>
<li>用lua脚本执行一个redis命令</li>
</ul>
<p><img src="/../../images/image-20230410171045806.png" alt="image-20230410171045806"></p>
<ul>
<li>lua脚本执行多条redis命令</li>
</ul>
<p><img src="/../../images/image-20230410171315832.png" alt="image-20230410171315832"></p>
<ul>
<li>key的个数，我们上面写的都是0，所以不需要传递别的参数，如果我们给的是大于零的数，比如说2，那么我们就需要传递两个参数，这两个参数对应于lua脚本中的 KEYS数组，并且这个数组是用1开始的。除此之外，还有一个ARGV参数，写完KEYS参数剩下的就都是ARGV参数，lua脚本会从左到右依次读取存值到ARGV数组里面，同样是以1下标开始。</li>
</ul>
<p><img src="/../../images/image-20230410172822515.png" alt="image-20230410172822515"></p>
<ul>
<li>if else，在lua脚本里面，用了if 或者elseif一定要配合一个then，用了if一定要又end结尾，使用的是else 不需要then。</li>
</ul>
<p><img src="/../../images/image-20230410173633091.png" alt="image-20230410173633091"></p>
<p>对应的lua脚本为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> KEYS[<span class="number">1</span>]&gt;KEYS[<span class="number">2</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">elseif</span> KEYS[<span class="number">1</span>]&lt;KEYS[<span class="number">2</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> ARGV[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<ul>
<li>回到redis的优化，我们要通过lua脚本完成判断和删除的原子性操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//尝试加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加上线程Id，唯一标识是哪个线程上的锁，防止误删 设置锁的过期时间</span></span><br><span class="line">    <span class="keyword">while</span>(!stringRedisTemplate.opsForValue().</span><br><span class="line">            setIfAbsent(lock, String.valueOf(Thread.currentThread().getId()),<span class="number">10</span>,TimeUnit.MINUTES))&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加锁成功，可以去操作redis</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> StringUtils.isEmpty(ticket)? <span class="number">0</span>:Integer.parseInt(ticket);</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,String.valueOf(--num));</span><br><span class="line">        message = <span class="string">&quot;成功输出一张票，剩余&quot;</span>+num;</span><br><span class="line">        System.out.println(message+<span class="string">&quot;端口号：&quot;</span>+port);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        message = <span class="string">&quot;已售空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(lock);</span><br><span class="line">    <span class="comment">//lua脚本完成key的判断和删除</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]==ARGV[1]) then\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    return redis.call(&#x27;del&#x27;,KEYS[1])\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建议使用有指定返回值的构造方法</span></span><br><span class="line">    DefaultRedisScript&lt;Boolean&gt; luascrpit = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行lua脚本 </span></span><br><span class="line">    stringRedisTemplate.execute(luascrpit, Arrays.asList(lock),threadId);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> message+<span class="string">&quot;端口号：&quot;</span>+port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>以上就是自研redis作为分布式锁的最基本的功能的实现，大部分常见场景已经能够完全应付。但是还有一些更为细致的东西还可以优化。</p>
<h3 id="代码优化2"><a href="#代码优化2" class="headerlink" title="代码优化2"></a>代码优化2</h3><p>简单回顾一下实现一个分布式锁需要做到那些方面：</p>
<blockquote>
<p>独占性</p>
<p>可重入</p>
<p>高可用</p>
<p>不死锁</p>
<p>不乱抢</p>
</blockquote>
<p>上面的优化1我们实现了哪些：</p>
<blockquote>
<p>独占、不死锁、不乱抢、高可用好像我们都实现了。但是还有一个可重入，上面的代码好像暂时无法实现。</p>
<p>可重入的定义是：对于同一个线程要多次进入同步代码块时，不需要阻塞等待。</p>
<p>可重入锁的定义：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p>
<p>在JUC中我们知道了，可重入锁的最重要的实现规则就是加锁了几次就要对应释放几次锁，否则无论是sycn关键字还是 reentrylock都会记录挂载在自己身上的lock的个数，只有自己身上的lock清零了才表示没有线程占有锁，允许其他线程进入。</p>
<p>所以我们这里对于分布式锁的可重入优化同样要能够做到上面的这种要求。</p>
</blockquote>
<p>分析完上述的要求，我们现在要要求我们使用的redis的数据结构既能够互斥反问，又能够在lock的key唯一的情况下表示出是哪个线程上的锁，还要能够计数用于表示进入了几次同步代码块。</p>
<p>这样以来我们之前所使用的setnx好像已经不足以满足我们现在的需求的，现在我们希望的格式应该是下面这样的：</p>
<p>lock_key   线程标识   进入次数，其中lock_key和线程标识都是不会发生改变的，只有进入次数会改变，所以我只有 hash结构能够满足我们的要求。</p>
<p>要互斥上锁我们可以通过 exists指令进行判断，自增就可以通过hincrby  lock_key  线程标识  1，退出的时候就可以用hincrby  lock_key  线程标识  -1来完成。</p>
<p>也正是如此，这意味着我们每次加锁或者重入锁都有两步 1、判断是否存在；2、hincrby  1 这两步肯定不是原子性操作，所以要用lua脚本来完成，离开锁和解锁也是一样的道理。</p>
<p>预期改进代码 如下：</p>
<p><img src="/../../images/image-20230411090941111.png" alt="image-20230411090941111"></p>
<p>加锁和解锁两个模块我们单独封装出来实现。</p>
<ul>
<li>加锁的lua脚本</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;exists&#x27;</span>,KEYS[<span class="number">1</span>])==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">elseif</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])==<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>,<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li>hincrby 即包括创建和自增的功能，所以可以用hincryby代替hset</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;exists&#x27;</span>,KEYS[<span class="number">1</span>])==<span class="number">0</span> <span class="keyword">or</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])==<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>





<ul>
<li>解锁的lua脚本</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">elseif</span> redis.call(<span class="string">&#x27;hincryby&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">-1</span>)==<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<ul>
<li>优化后的代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        mylock();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> StringUtils.isEmpty(ticket)? <span class="number">0</span>:Integer.parseInt(ticket);</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,String.valueOf(--num));</span><br><span class="line">            message = <span class="string">&quot;成功输出一张票，剩余&quot;</span>+num;</span><br><span class="line">            System.out.println(message+<span class="string">&quot;端口号：&quot;</span>+port);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            message = <span class="string">&quot;已售空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        myunlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message+<span class="string">&quot;端口号：&quot;</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">myunlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scrpit</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;if redis.call(&#x27;hexists&#x27;,KEYS[1],ARGV[1])==0 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return nil &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;elseif redis.call(&#x27;hincrby&#x27;,KEYS[1],ARGV[1],-1)==0 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里有三个值 不好用boolean</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; booleanDefaultRedisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(scrpit, Long.class);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(booleanDefaultRedisScript, Arrays.asList(lock), <span class="string">&quot;Thread:&quot;</span>+String.valueOf(Thread.currentThread().getId()));</span><br><span class="line">        <span class="keyword">if</span>(execute==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果返回为空</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;锁异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mylock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scrpit</span> <span class="operator">=</span></span><br><span class="line">                <span class="string">&quot;if redis.call(&#x27;exists&#x27;,KEYS[1])==0 or redis.call(&#x27;hexists&#x27;,KEYS[1],ARGV[1])==1 then &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;hincrby&#x27;,KEYS[1],ARGV[1],1) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],30) &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 1 &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"></span><br><span class="line">        DefaultRedisScript&lt;Boolean&gt; booleanDefaultRedisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(scrpit, Boolean.class);</span><br><span class="line">        <span class="keyword">while</span>(!stringRedisTemplate.execute(booleanDefaultRedisScript,Arrays.asList(lock),<span class="string">&quot;Thread:&quot;</span>+String.valueOf(Thread.currentThread().getId())))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>如还需优化，则就是为了防止在执行过程中key过期，我们还需要考虑在线程加锁后，开启一个后台程序定时扫描key的情况，如果快过期了还没执行结束需要给key续上一些时间。</p>
<h2 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h2><p>上面我们手写的分布式锁基本上能够应对普通并发的情况了，但是实际上市面上分布式锁也有比较成熟的框架。如redis就为我们提供了自己的分布式锁的实现——RedLock。RedLock只是一种实现分布式锁的规范和算法，具体的实现分为不同的语言，有不同的名字，对于Java来说就是Redisson。</p>
<p>官网对于RedLock的描述的优点：</p>
<p><img src="/../../images/image-20230411145210087.png" alt="image-20230411145210087"></p>
<p>他觉得它有优点为什么？明明我们上面的代码好像已经考虑的非常周全了难道还存在什么问题嘛？</p>
<p><img src="/../../images/image-20230411145913750.png" alt="image-20230411145913750"></p>
<p>实际中我们对于redis分布式锁的实现，对于锁的获取是需要用另外的一个redis服务器的，而不是和数据放在一起。也就是说这样的用于存放锁的redis同样会出现单点故障，当然也很容易想到通过集群的方式来解决单点故障。但是官网告诉我们集群无法解决分布式锁的单点故障问题。原因如下：</p>
<blockquote>
<p>我们回忆一下Redis对于CAP原则的支持</p>
<p>对于单机redis支持的是CP原则，它能够保证数据一致性但是不能保证高可用，最极端的例子就是单点故障整台redis就不可用了。</p>
<p>对于redis集群支持的是AP原则，因为redis主从之间的数据复制是异步的 ，并且写入数据时，只要写入了主机就会反馈写入成功，再后台另启线程执行数据同步，这也是为什么redis集群无法解决单点故障的主要原因。因为如果一个线程已经加锁，master节点已经接收到了，但是在数据同步之前master节点宕机了，根据哨兵机制，会选举出一个slave节点作为master节点，但是这个新的master节点没有刚刚上锁的数据，如果其他线程此时再来上锁，就会导致同样能够进入同步代码，出现问题。</p>
</blockquote>
<p>来看看官网如何解决上述问题:</p>
<p><img src="/../../images/image-20230411153727178.png" alt="image-20230411153727178"></p>
<p>主要就是，可以通过启用五个都为master节点的redis服务器，获取锁时会依次获取，并且在每个节点上都会设置相应时间，如果超过了相应时间就表示当前节点无法上锁，马上到下一个节点，只有大于一半的节点都获得了锁才表示上锁成功，否则就要释放掉已经上锁的节点的锁。</p>
<p>这里的master节点数也不是一定都是5，它是通过一个公式计算得到的，N &#x3D; 2X+1，N就是部署的服务器数量，X表示允许多少台出现故障。如我允许1台出现故障并且redis还能够对外服务，所以要部署 N &#x3D; 2X1+1 &#x3D; 3台redis服务器。</p>
<h3 id="使用Redisson"><a href="#使用Redisson" class="headerlink" title="使用Redisson"></a>使用Redisson</h3><ul>
<li>依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>配置类，要告诉redisson单机还是多机，ip和密码，并创建注入spring容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Redisson <span class="title function_">redisson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">    </span><br><span class="line">    config.useSingleServer()        <span class="comment">//单机</span></span><br><span class="line">            .setAddress(<span class="string">&quot;redis://192.167.73.129:6379&quot;</span>)  <span class="comment">//IP</span></span><br><span class="line">            .setPassword(<span class="string">&quot;1&quot;</span>);      <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">return</span> (Redisson) Redisson.create(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>替换业务代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Redisson redisson;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用redisson实现分布式锁</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;lock:&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">ticket</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> StringUtils.isEmpty(ticket)? <span class="number">0</span>:Integer.parseInt(ticket);</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,String.valueOf(--num));</span><br><span class="line">        message = <span class="string">&quot;成功输出一张票，剩余&quot;</span>+num;</span><br><span class="line">        System.out.println(message+<span class="string">&quot;端口号：&quot;</span>+port);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        message = <span class="string">&quot;已售空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message+<span class="string">&quot;端口号：&quot;</span>+port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里要注意一个问题，解锁之前最好加上判断避免出错，因为redisson有极低的可能性出现持有锁的线程与解锁线程不一致的情况，建议解锁时候修改为如下的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.isLocked()&amp;&amp;lock.isHeldByCurrentThread())&#123;</span><br><span class="line">    lock.unlock();            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="看看redisson如何实现的"><a href="#看看redisson如何实现的" class="headerlink" title="看看redisson如何实现的"></a>看看redisson如何实现的</h3><p>从lock方法进入</p>
<p><img src="/../../images/image-20230411165526139.png" alt="image-20230411165526139"></p>
<ul>
<li>尝试加锁</li>
</ul>
<p><img src="/../../images/image-20230411170712415.png" alt="image-20230411170712415"></p>
<ul>
<li>加锁的lua脚本</li>
</ul>
<p><img src="/../../images/image-20230411172542138.png" alt="image-20230411172542138"></p>
<ul>
<li>watchdog</li>
</ul>
<p><img src="/../../images/image-20230411173129367.png" alt="image-20230411173129367"></p>
<p><img src="/../../images/image-20230411173324595.png" alt="image-20230411173324595"> </p>
<ul>
<li>续时间的lua脚本</li>
</ul>
<p><img src="/../../images/image-20230411173355049.png" alt="image-20230411173355049"></p>
<p>解锁实际上也是类似的，只不过里面很多异步的执行策略。</p>
<h3 id="多机策略"><a href="#多机策略" class="headerlink" title="多机策略"></a>多机策略</h3><p>上面我们还是再单机上进行测试的，还没有到能够解决单点故障的地方。</p>
<p>官网介绍：但是实际上Rlock已经被弃用了</p>
<p><img src="/../../images/image-20230411175526606.png" alt="image-20230411175526606"></p>
<p>现在推荐使用MultiLock，但是实际上都差不多，都是把多个锁并作同一个当作单锁处理。</p>
<p>。。。。。。。。</p>
<h2 id="缓存过期淘汰策略"><a href="#缓存过期淘汰策略" class="headerlink" title="缓存过期淘汰策略"></a>缓存过期淘汰策略</h2><ul>
<li>一些面试题</li>
</ul>
<p><img src="/../../images/image-20230411211646445.png" alt="image-20230411211646445"></p>
<p><img src="/../../images/image-20230411211652215.png" alt="image-20230411211652215"></p>
<p>redis最大内存配置</p>
<p><img src="/../../images/image-20230411211852488.png" alt="image-20230411211852488"></p>
<p>以字节为单位。默认是0，这个0表示的并不是内存为0，而是默认不限制大小(64位系统下)，理论上可以占用你物理内存的上限。一般推荐为物理内存的 3&#x2F;4。</p>
<ul>
<li>修改方式：</li>
</ul>
<p><img src="/../../images/image-20230411212657433.png" alt="image-20230411212657433"></p>
<p>或配置文件写死。 通过info memory指令查看内存情况。</p>
<p>redis超过最大内存的限制同样会出现OOM错误。为了避免出现OOM的情况所以redis有了key的缓存淘汰策略。</p>
<p>问题：对于一个key到期了是马上被删除嘛？</p>
<blockquote>
<p>答案肯定不是的。因为如果此时redis如果是在忙于业务的话，还要专门来处理这个要被删除的key？</p>
<p>再说了要时时刻刻遍历所有key的过期时间也不合理。对CPU太不友好了。所以立即删除是不合适的。但是内存很友好，典型的时间换空间的做法。</p>
<p>惰性删除：不会马上删除，只有下次使用到这个key的时候，会去检查这个key的状态，如果已经过期就将其删除。对CPU友好，对内存不友好。空间换时间的做法。并且可能存在一直不被释放的风险。</p>
<p>两者结合，定时删除策略。并且定时策略也不是对所有的key都进行扫描，而是随机抽取。所以这样以来我们就需要确定定时的频率，和抽取的数量。如果设置的不合理就会退化成上述两种情况。</p>
<p>看来这些方法都不是很好，因此衍生出了redis的缓存淘汰策略。</p>
</blockquote>
<p>先看看如何设置:</p>
<p><img src="/../../images/image-20230411215014957.png" alt="image-20230411215014957"></p>
<p>看到后缀都是 random、lru和lfu。random好理解，lru和lfu我们也知道一个是最近最久未使用，一个是最近使用频率最低，具体有什么区别呢？</p>
<blockquote>
<p>LRU比较看重的是最久未使用的那一个</p>
<p>LFU会比较均衡一点通过使用频率来判断，虽然说比较均衡但是实际上效果LRU甚至还是好一点。</p>
</blockquote>
<p>对比一下几个策略：这里会涉及到一些redis的数据结构，过期key的存放、所有key的存放等</p>
<p><img src="/../../images/image-20230411215716807.png" alt="image-20230411215716807"></p>
<h2 id="五大类型的底层实现"><a href="#五大类型的底层实现" class="headerlink" title="五大类型的底层实现"></a>五大类型的底层实现</h2><p>面试题：</p>
<ul>
<li><p>String、list、hash、set、zset的底层数据结构？</p>
</li>
<li><p>跳表？优缺点？</p>
</li>
<li><p>底层数据结构：</p>
</li>
</ul>
<p><img src="/../../images/image-20230412091532630.png" alt="image-20230412091532630"></p>
<p>源码位置：解压后的src目录。</p>
<p><img src="/../../images/image-20230412091933569.png" alt="image-20230412091933569"></p>
<p>怎么看？看重要的，如数据类型的实现。</p>
<p><img src="/../../images/image-20230412092849297.png" alt="image-20230412092849297"></p>
<p>还有几个忘记标了，</p>
<p>1、dict.c这是一个字典类型，它和object贯穿了整个redis源码。</p>
<p>2、db.c这是数据库的实现，它和dict.c构建出数据库对Java暴露出Object对象以供调用。</p>
<p>我们也知道一般我们的key是不会变的，所以key一般都是String类型，Value  就五花八门了可以是String、Hash、List、Set、Zset。</p>
<p>redis底层是C语言编写的，对于redis而言，一切皆KV也就是dict，也就是所有数据结构都会再被封装成dict类型存储，但是为了使用的方便设计者在各种数据结构上层又加了一层的封装，就是Object类型，对于我们而言redis每个类型都是这个Object类型的，底层是什么都被屏蔽了。</p>
<p>所以我们先来看看dict如何成为Objcet类型的。</p>
<ul>
<li>dictEntry定义</li>
</ul>
<p><img src="/../../images/image-20230412100901433.png" alt="image-20230412100901433"></p>
<ul>
<li>server.h中的redisObjcet定义</li>
</ul>
<p><img src="/../../images/image-20230412100957557.png" alt="image-20230412100957557"></p>
<blockquote>
<p>type就是用于表示当前值的数据类型</p>
<p>encoding当前值对象底层存储的编码类型，同一种数据类型可能有不同的编码形式 如string有三种编码类型，int、embstr、raw</p>
<p>lru就是记录当前这个值最近被使用的时间戳</p>
<p>refcount用于记录有多少个指针指向了我</p>
</blockquote>
<ul>
<li>编码格式</li>
</ul>
<p><img src="/../../images/image-20230412142310568.png" alt="image-20230412142310568"></p>
<p>我们可以通过debug object key 指令去调试一个key，但是这个指令不允许客户端直接使用，要求将配置文件中的enable-debug-command 设置为true才允许使用。</p>
<p><img src="/../../images/image-20230412143507619.png" alt="image-20230412143507619"></p>
<p>我们再配置文件设置对应的值，然后重启服务器。</p>
<p><img src="/../../images/image-20230412143727574.png" alt="image-20230412143727574"></p>
<p><img src="/../../images/image-20230412143950846.png" alt="image-20230412143950846"></p>
<p><img src="/../../images/image-20230412144130638.png" alt="image-20230412144130638"></p>
<p>可以看到里面redisObject结构体的各个属性的值。</p>
<ul>
<li>五大数据类型的底层结构</li>
</ul>
<blockquote>
<p>redis 6：</p>
<p>String &#x3D;&#x3D;&#x3D;&#x3D; SDS</p>
<p>Set &#x3D;&#x3D;&#x3D;&#x3D; intset+hashtable</p>
<p>Zset &#x3D;&#x3D;&#x3D;&#x3D; skipList + zipList</p>
<p>List &#x3D;&#x3D;&#x3D;&#x3D; quickList + zipList</p>
<p>Hash &#x3D;&#x3D;&#x3D;&#x3D; hashTable+zipList</p>
<p>redis7: 7之后不在使用zipList</p>
<p>String &#x3D;&#x3D;&#x3D;&#x3D; SDS</p>
<p>Set &#x3D;&#x3D;&#x3D;&#x3D; intset+hashtable</p>
<p>Zset &#x3D;&#x3D;&#x3D;&#x3D; skipList + listpack</p>
<p>List &#x3D;&#x3D;&#x3D;&#x3D; quickList </p>
<p>Hash &#x3D;&#x3D;&#x3D;&#x3D; hashTable+listpack</p>
</blockquote>
<h2 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h2><p>String有3大物理编码方式：embstr、int、raw</p>
<blockquote>
<p>int：保存long型的数字，最大64位8字节，最大到2的63次方-1，只有整数会使用int编码，小数都embstr</p>
<p>embstr：表示SDS（Simple Dynamic String），保存长度小于44字节的字符串</p>
<p>raw：保存大于44字节的字符串</p>
</blockquote>
<h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>redis在存储字符串时，没用使用C语言提供的String，而是自己实现了一个SDS，C语言实现String 实际上是由char[] 实现的，默认遇到 \0表示结束。</p>
<ul>
<li>SDS的定义</li>
</ul>
<p><img src="/../../images/image-20230412150230563.png" alt="image-20230412150230563"></p>
<p>为什么要重新涉及SDS？</p>
<p>相比于C语言提供的char[]，SDS提供了记录字符串长度的属性，每次要获取长度时不需要遍历，从O(n)降低到了O(1)。</p>
<p>char[]根据 \0 来判定是否结束，容易出现歧义，SDS直接使用len来遍历获取一般不会出现问题。</p>
<p>SDS会自动记录当前字符串的长度和剩余空间的长度，从而避免缓冲区溢出的问题。缩短时，SDS短时间不会回收多余的空间，而是用free将多出来的记录下来，以供后续扩容直接使用。</p>
<p>执行set k1 v1的过程:</p>
<p>实际上调用的是t_string.c文件中的setCommand函数：</p>
<p><img src="/../../images/image-20230412153436589.png" alt="image-20230412153436589"></p>
<p>拿到编码格式之后去执行setGenericCommand函数。没必要细看。只要记住大致的流程。</p>
<p>执行setCommand，里面会根据value获取编码类型，然后完成设置。</p>
<p>数据编码格式大致的逻辑：</p>
<p>会上来先判断set的value能不能由64位long类型数据表示，如果可以就便是int类型。内部还有一些小细节，设计者参考了Java Integer的实现方式，提供了常用的数据的共享变量，Java中Integer-128~128 是属于不会变化的常量，如果一个long是在这个范围内的话，是直接指向常量区域的不会创建新的对象。</p>
<p>redis中int的实现也有异曲同工之妙，一开始初始化了0~10000的常量这些数据都是直接获取的，如果value被解析成了这个范围内的数据，redisObject的ptr指针就直接指向常量区域对应的位置。</p>
<p><img src="/../../images/image-20230412154257535.png" alt="image-20230412154257535"></p>
<ul>
<li>int编码格式</li>
</ul>
<p><img src="/../../images/image-20230412154703229.png" alt="image-20230412154703229"></p>
<ul>
<li>embstr编码格式</li>
</ul>
<p><img src="/../../images/image-20230412155345076.png" alt="image-20230412155345076"></p>
<p><img src="/../../images/image-20230412155811918.png" alt="image-20230412155811918"></p>
<ul>
<li>raw也是类似</li>
</ul>
<p>有一个小细节，embstr实现是只读的，如果通过append方法或者其他方法修改了值的话，都需要将embstr转成raw再进行操作，就会导致embstr没有达到44字节的长度也变成了raw编码格式。</p>
<h2 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h2><ul>
<li>默认的hash有关的配置</li>
</ul>
<p><img src="/../../images/image-20230412160932781.png" alt="image-20230412160932781"></p>
<p>entry表示的是 hash的 hk-hv的个数，value表示的是hv的长度，配置在redis6里的意思表示如果hk-hv的个数在512个以内，并且长度在64字节以内就是用ziplist编码格式，否则使用hashtable，同理在redis7中如果在 64 512范围内使用listpack，否则使用hashtable</p>
<p><img src="/../../images/image-20230412161338096.png" alt="image-20230412161338096"></p>
<p>Ziplist 压缩列表是一种紧凑编码格式，总体思想是多花时间来换取节约空间，即以部分读写性能为代价，来换取极高的内存空间利用率，因此只会用于字段个数少，且字段值也较小的场景。压缩列表内存利用率极高的原因与其连续内存的特性是分不开的。</p>
<p>Ziplist是经过特殊编码的双向链表，但是它不存储前一个和后一个节点的指针，而是存储上一个节点和当前节点的长度。</p>
<p><img src="/../../images/image-20230412163320247.png" alt="image-20230412163320247"></p>
<p>zltail比较不好理解：他记录的是开始节点到尾节点的字节数，好处就是可以不需要遍历就能够知道结束的地址。</p>
<p>entry就是一个个ziplist的节点，是一个zipentry节点</p>
<p><img src="/../../images/image-20230412164551766.png" alt="image-20230412164551766"></p>
<p>最重要的就是，记录了前一个entry的长度、当前的数据、当前数据的编码格式。</p>
<p>前一个entry的长度只有两种取值，一个是1字节，另一个是5字节。1字节是当前一个entry长度小于254时候就记位1，否则就是5，为什么是254，因为上面那张图说了zlend用0XFF表示，这就是255，所以中间最好不要出现255。</p>
<p>常规的链表是不连续的，并且遍历速度慢，redis设计者希望让链表保持删除增加快的特性的同时又遍历速度块，所以设计了这样的数据结构，他让entry在内存中是连续的，相比于其他的双向链表存储前后的指针，它存储的是前一个节点的长度和当前节点的长度，这样就可以根据当前位置很容易的找到前一个和后一个节点的起始位置，从而完成增加和删除元素。</p>
<p>但是他也有一个致命的缺点就是可能会出现连锁跟新的现象。所以这个最后被listpack替换。</p>
<p>还记得压缩链表保存前置节点长度的规矩嘛，前置节点的长度小于254就用1字节，大于254就用5字节 。</p>
<p>这样的话如果我原来有一个节点是ziplist的，但是我突然把它的key设置成了超长的key，变成了hashtable结构的，从而导致后置节点要用5个字节来保存我的长度，而一种极端的现象后置节点也需要变成hashtable结构，一直延续下去，这就是连锁跟新现象。</p>
<ul>
<li>listpack结构</li>
</ul>
<p><img src="/../../images/image-20230417170313875.png" alt="image-20230417170313875"></p>
<h2 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h2><p>我们知道List可以 lpush也可以 rpush，所以实际上是一个双端的链表。他的底层实现是 quicklist。</p>
<p>。。。。。</p>
<h2 id="Redis到底为什么那么快？"><a href="#Redis到底为什么那么快？" class="headerlink" title="Redis到底为什么那么快？"></a>Redis到底为什么那么快？</h2><p>之前我们浅浅的讲了一下 为什么Redis快，这里我们做个比较详细的论述。</p>
<p>首先回顾一下上面讲到过的内容，当有TCP连接，连接到客户端时，服务器要怎么为线程服务，一个链接创建一个进程为其服务？还是一个进程管理多个TCP连接？</p>
<p>答案当然时一个进程管理多个TCP连接，因为如果一个连接就对应一个进程这也太浪费资源了。所以更好的办法就是一个进程连接多个TCP连接。</p>
<p>那么问题就来了如何能够让进程知道哪些连接有数据需要被读取，最笨的方式就是进程一个个去轮询遍历，但是这样效率实在低。有没有快一点的解决方式？那就是我们之前说到过的IO多路复用，让链接主动告诉线程我这里有数据需要读取。</p>
<p>linux为我们实现好了IO多路复用，可以分为三个函数 select–&gt;poll—&gt;epoll，这也是Linux内核自己一步步优化的结果。而epoll函数是redis快的根本原因。</p>
<p>我们也都知道redis是跑在单线程上的，指令都是顺序执行的，而指令IO又会引起系统阻塞，导致服务无法被其他连接使用，这样的系统是快不起来的，所以Redis用IO多路复用来解决这个问题。</p>
<p>当有多个socket连接连接到redis时候，通过IO多路复用程序连接对应的socket，然后它会根据连接的指令的先后顺序将指令加入文件事件队列，然后会将队列中事件根据FIFO的原则传给内部的事件派发器，它会将不同的指令分配给不同的处理器。</p>
<p>这里有一个因果关系：</p>
<blockquote>
<p>正确的关系应该是，Redis的文件事件队列是单线程的所以导致了Redis是单线程的，而不是Redis是单线程的所以文件事件队列是单线程的。</p>
</blockquote>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>在讲IO多路复用之前，我们先来讲讲，在IO多路复用出现之前，Redis肯定是经历过BIO和NIO的，简单聊聊BIO和NIO以及一些模拟实现。</p>
<p><img src="/../../images/image-20230418103226212.png" alt="image-20230418103226212"></p>
<p>可以发现我们的服务器执行accept后就会一直等待连接，并且accept是不可少的，所以BIO的形式等待客户端连接就会出现依次等待。</p>
<p><img src="/../../images/image-20230418104213291.png" alt="image-20230418104213291"></p>
<p><img src="/../../images/image-20230418104233900.png" alt="image-20230418104233900"></p>
<p>同样在read中也会有一个阻塞，等待客户端写入数据。但是好像也还不错每次输入都能够获取到对应的结果，但是我现在再开启二号客户输入，服务器能否读取到呢？</p>
<p><img src="/../../images/image-20230418104435616.png" alt="image-20230418104435616"></p>
<p>显然是不会的，因为服务器现在被read阻塞了，1号客户端不结束，server根本不会跳出read的阻塞。这就是BIO的痛点。服务器只会依次为一个连接服务，其他的必须等待。</p>
<p>优化：</p>
<p>现在的问题就是只有一个线程为客户端服务，那我就只需要开多个线程服务客户端不就可以了嘛？</p>
<p>开启多线程</p>
<p><img src="/../../images/image-20230418110131231.png" alt="image-20230418110131231"></p>
<p>现在每个客户端的连接都能够被及时处理。但是这种方式只能够适应小并发的，如果来多了线程，就需要new 大量的线程，并且每次创建线程都需要涉及到用户态到内核态的切换，并且线程多了也会被频繁切换非常耗费资源。</p>
<p>同样用线程池好像能够很好的解决，但是线程池的各种参数的设置又需要经过各种调试，所以后面出现了NIO的方式。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>上面的BIO的模型主要是因为会卡在 read函数一直阻塞，或者new 新线程。那是不是只要有不会阻塞的函数代替read函数就能够解决了。jdk1.4后出现了NIO的一个包，可以实现这种功能。NIO中他只有一个线程，所有链接上来的socket都会被放在一个数组里面，服务器每次会去遍历里面的socket是否有数据需要被读取，如果有就会去读取对应的数据。 也就是轮询代替阻塞的方式。</p>
<p> <img src="/../../images/image-20230418142313141.png" alt="image-20230418142313141"></p>
<p>NIO解决了BIO的多线程处理socket连接的问题，只需要一个线程就能够处理多个socket连接，但是与之相对应的问题就是server端在高并发的情况下轮询检查每个socket连接非常费时，而且可能会做很多无用功，如果1w的socket只有2个有数据，剩下的都是无用功，而且还需要调用read，同样会发生用户态到内核态的转换。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>上面说过NIO会出现大量的状态转换，所以我们希望那些代码能够在内核态就被完成，并且尽量减少轮询，谁有数据我直接找到谁。</p>
<ul>
<li>select</li>
</ul>
<p>select函数是一种多路复用I&#x2F;O模型，它会以文件描述符的形式管理多个socket连接，监控期间select是阻塞的，直到有一个或多个socket要读取或写入数据，select就会去执行相应的业务，并且会修改对应socket的文件描述符标记位，并返回文件描述列表，服务器的代码就只需要去遍历对应的文件描述列表就能够直到哪些socket要读写数据。然后调用相应的系统调用即可。</p>
<p>可以看到select已经减少了大量的状态切换了，只有返回文件描述符列表时，需要将列表从内核态拷贝到用户态，以及后面的 read、write相应的系统调用。但是拷贝数据依然是一个开销非常大的活，所以还需要对其优化。</p>
<p>并且select管理的socket连接是一个类似bitmap的形式它有最大上限是1024。这个问题被poll函数解决了，相比于select，poll主要也是做了这个优化。 拷贝和遍历的问题依旧存在。</p>
<ul>
<li>epoll</li>
</ul>
<p>epoll分为三个步骤：create、ctl、wait。</p>
<ol>
<li><code>epoll_create(int size)</code>：创建一个 <code>epoll</code> 实例，并返回一个文件描述符，用于后续的 <code>epoll</code> 操作。其中，<code>size</code> 参数指定的是需要监视的文件描述符数目的一个估计值。</li>
<li><code>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code>：向 <code>epoll</code> 实例中注册或者修改一个需要监视的文件描述符。其中，<code>epfd</code> 参数是 <code>epoll_create</code> 返回的文件描述符，<code>op</code> 参数指定操作类型，可以是 <code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code> 或者 <code>EPOLL_CTL_DEL</code> 中的一个，分别表示添加、修改或删除一个文件描述符的监视事件；<code>fd</code> 参数表示要注册或修改的文件描述符；<code>event</code> 参数则是一个 <code>epoll_event</code> 结构体，用来指定事件的类型和其他属性。</li>
<li><code>epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code>：等待 <code>epoll</code> 实例中的事件发生，如果有事件发生则返回。其中，<code>epfd</code> 参数是 <code>epoll_create</code> 返回的文件描述符，<code>events</code> 参数是一个指向 <code>epoll_event</code> 结构体数组的指针，用来存储发生事件的文件描述符和事件类型；<code>maxevents</code> 参数指定 <code>events</code> 数组的最大长度；<code>timeout</code> 参数是等待事件的超时时间，单位是毫秒，如果设置为 <code>-1</code> 则表示一直等待直到事件发生。<code>epoll_wait</code> 函数返回发生事件的文件描述符数量。</li>
</ol>
<p>并且基于事件机制，socket有数据会主动通知内核，并加入就绪链表，而wait会返回发生事件的文件描述符的数量，所以最后只需要遍历确实有发生事件的socket即可，避免了无效的遍历。</p>
<p>因此redis底层使用了epoll实现IO多路复用，极大的减少了切换的开销所以速度很快。</p>
<h2 id="小业务"><a href="#小业务" class="headerlink" title="小业务"></a>小业务</h2><p>发红包的业务，肯定是高并发的所以要用Redis实现</p>
<p>主要分为几部分：发红包、抢红包、记录红包、金额的分配算法。</p>
<ul>
<li>金额的分配算法：这里采用一个用得较多的二倍均值法，主要是为了让每个红包金额都能够在大致相同的区间内。</li>
</ul>
<blockquote>
<p>公式：金额范围M &#x3D; (0，（剩余金额➗当前剩余的红包个数）X 2)；</p>
<p>比如说发了  100元，10个人抢</p>
<p>第一个人的范围  (0，（100➗10）X 2) &#x3D; （0，20），假设抢了18，剩余82，9个人</p>
<p>第二个人的范围（0，（82➗9）X 2）&#x3D;（0，18.222）……………</p>
</blockquote>
<ul>
<li>发红包：需要考虑用redis的什么数据结构？</li>
</ul>
<blockquote>
<p>一般我们选定了金额和个数之后，都会通过上面的分配算法得到每个红包的金额。也就是说我们需要一个key对应多个value，那这样的数据结构也就只有一个，list</p>
<p>并且分配到list中后续也很方便抢，每次pop就行了</p>
</blockquote>
<ul>
<li>抢红包：高并发、是否加锁、什么数据结构？</li>
</ul>
<blockquote>
<p>上面发红包用了list，我们抢红包同样只需要从list中取出数据即可，并且这还是属于单条指令，redis天生能够保证原子性，线程安全的，因此也不需要加锁，而且也不能够加锁，如果加锁抢一个红包都得等好几秒谁顶得住。</p>
</blockquote>
<ul>
<li>红包记录：什么数据结构</li>
</ul>
<blockquote>
<p>每个红包记录，肯定需要标识是谁抢了，抢了多少钱，而且还要能够表明是哪个红包，所以需要用到hash。</p>
<p>key表示具体的红包，hk和hv就是哪个用户抢了多少钱。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io">异梦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io/2022/08/22/Redis/Redis/">https://yimeng436.github.io/2022/08/22/Redis/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yimeng436.github.io" target="_blank">异梦的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/top.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/23/Nginx/nginx/"><img class="prev-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/22/Project/Project/"><img class="next-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Project</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/04/%E5%A4%9A%E6%80%81%E4%BE%8B%E9%A2%98/%E5%A4%9A%E6%80%81%E4%BE%8B%E9%A2%98/" title="多态例题"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-04</div><div class="title">多态例题</div></div></a></div><div><a href="/2022/06/06/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/" title="自动拆装箱"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-06</div><div class="title">自动拆装箱</div></div></a></div><div><a href="/2022/06/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-15</div><div class="title">多线程</div></div></a></div><div><a href="/2022/06/30/JavaWeb/JavaWeb/" title="JavaWeb"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-30</div><div class="title">JavaWeb</div></div></a></div><div><a href="/2022/07/25/Mybatis/Mybatis/" title="Mybatis"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-25</div><div class="title">Mybatis</div></div></a></div><div><a href="/2022/07/26/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/" title="注解和反射"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-26</div><div class="title">注解和反射</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">异梦</div><div class="author-info__description">欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yimeng436" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2441844062@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">I&#x2F;O多路复用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-key"><span class="toc-number">4.1.</span> <span class="toc-text">Redis-key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">String 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E9%9B%86%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">List 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">4.4.</span> <span class="toc-text">set集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E9%9B%86%E5%90%88"><span class="toc-number">4.5.</span> <span class="toc-text">hash集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zset%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">4.6.</span> <span class="toc-text">zset有序集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">三种特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#geospatial-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.1.</span> <span class="toc-text">geospatial 地理位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hyperloglog"><span class="toc-number">5.2.</span> <span class="toc-text">Hyperloglog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap"><span class="toc-number">5.3.</span> <span class="toc-text">Bitmap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E4%B9%90%E8%A7%82%E9%94%81-watch"><span class="toc-number">7.</span> <span class="toc-text">redis 乐观锁 watch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Jedis"><span class="toc-number">8.</span> <span class="toc-text">Jedis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E5%90%88SpringBoot"><span class="toc-number">9.</span> <span class="toc-text">整合SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89RedisTemplate"><span class="toc-number">9.1.</span> <span class="toc-text">自定义RedisTemplate</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">Redis 持久化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">12.</span> <span class="toc-text">发布订阅</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">13.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">15.</span> <span class="toc-text">Redis产生的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6-linux%E4%B8%8B%E4%BD%BF%E7%94%A8redis"><span class="toc-number">16.</span> <span class="toc-text">(进阶)linux下使用redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE"><span class="toc-number">16.1.</span> <span class="toc-text">修改配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB"><span class="toc-number">17.1.</span> <span class="toc-text">RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">17.1.1.</span> <span class="toc-text">RDB持久化方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">17.1.1.1.</span> <span class="toc-text">自动触发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91"><span class="toc-number">17.1.1.2.</span> <span class="toc-text">手动触发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">17.1.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8RDB"><span class="toc-number">17.1.3.</span> <span class="toc-text">禁用RDB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF"><span class="toc-number">17.2.</span> <span class="toc-text">AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">17.2.1.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">17.2.2.</span> <span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-RDB%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.3.</span> <span class="toc-text">AOF+RDB混合模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">18.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">19.</span> <span class="toc-text">复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E8%AE%BE%E5%A4%87"><span class="toc-number">19.1.</span> <span class="toc-text">配置文件配置主从设备</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%A8%E5%85%B5"><span class="toc-number">20.</span> <span class="toc-text">哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">20.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4"><span class="toc-number">21.</span> <span class="toc-text">redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%AE%97%E6%B3%95"><span class="toc-number">21.1.</span> <span class="toc-text">映射算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%8F%96%E4%BD%99%E6%98%A0%E5%B0%84"><span class="toc-number">21.1.1.</span> <span class="toc-text">哈希取余映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">21.1.2.</span> <span class="toc-text">一致性哈希算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E7%AE%97%E6%B3%95"><span class="toc-number">21.1.3.</span> <span class="toc-text">哈希槽算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">21.2.</span> <span class="toc-text">集群搭建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88redis%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4"><span class="toc-number">22.</span> <span class="toc-text">SpringBoot整合redis连接集群</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86-redis%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98"><span class="toc-number">23.</span> <span class="toc-text">(高级部分)redis各种问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%8D%95%E7%BA%BF%E7%A8%8BVS%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">23.1.</span> <span class="toc-text">redis单线程VS多线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%B0%88redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">23.2.</span> <span class="toc-text">初谈redis为什么那么快？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-number">23.2.1.</span> <span class="toc-text">什么是IO多路复用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigKey"><span class="toc-number">23.3.</span> <span class="toc-text">BigKey</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MoreKey%E9%97%AE%E9%A2%98"><span class="toc-number">23.3.1.</span> <span class="toc-text">MoreKey问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigKey-%E6%A1%88%E4%BE%8B"><span class="toc-number">23.3.2.</span> <span class="toc-text">BigKey 案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E5%88%99"><span class="toc-number">23.4.</span> <span class="toc-text">双写一致性原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Code"><span class="toc-number">23.4.1.</span> <span class="toc-text">Code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%B7%9F%E6%96%B0%E5%87%A0%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="toc-number">23.4.2.</span> <span class="toc-text">一致性跟新几种策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">23.4.2.1.</span> <span class="toc-text">mysql8的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1"><span class="toc-number">23.5.</span> <span class="toc-text">大数据统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95"><span class="toc-number">23.5.1.</span> <span class="toc-text">大数据去重方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GEO%E4%BD%BF%E7%94%A8"><span class="toc-number">23.6.</span> <span class="toc-text">GEO使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E5%80%BC%E5%88%A4%E6%96%AD"><span class="toc-number">23.7.</span> <span class="toc-text">海量数据的二值判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E7%83%AD%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F"><span class="toc-number">23.8.</span> <span class="toc-text">预热、雪崩、击穿、穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BB%E7%A9%BF%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">23.8.1.</span> <span class="toc-text">击穿的案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">23.9.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAbase%E7%89%88%E6%9C%AC%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">23.9.1.</span> <span class="toc-text">搭建base版本的模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%961"><span class="toc-number">23.9.2.</span> <span class="toc-text">代码优化1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%962"><span class="toc-number">23.9.3.</span> <span class="toc-text">代码优化2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RedLock"><span class="toc-number">23.10.</span> <span class="toc-text">RedLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redisson"><span class="toc-number">23.10.1.</span> <span class="toc-text">使用Redisson</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8Bredisson%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">23.10.2.</span> <span class="toc-text">看看redisson如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%9C%BA%E7%AD%96%E7%95%A5"><span class="toc-number">23.10.3.</span> <span class="toc-text">多机策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">23.11.</span> <span class="toc-text">缓存过期淘汰策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">23.12.</span> <span class="toc-text">五大类型的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">23.13.</span> <span class="toc-text">String数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS"><span class="toc-number">23.13.1.</span> <span class="toc-text">SDS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%BB%93%E6%9E%84"><span class="toc-number">23.14.</span> <span class="toc-text">Hash结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E7%BB%93%E6%9E%84"><span class="toc-number">23.15.</span> <span class="toc-text">List结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%88%B0%E5%BA%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">23.16.</span> <span class="toc-text">Redis到底为什么那么快？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BIO"><span class="toc-number">23.16.1.</span> <span class="toc-text">BIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO"><span class="toc-number">23.16.2.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">23.16.3.</span> <span class="toc-text">IO多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E4%B8%9A%E5%8A%A1"><span class="toc-number">23.17.</span> <span class="toc-text">小业务</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="MySQL原理"/></a><div class="content"><a class="title" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理">MySQL原理</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="算法笔记"/></a><div class="content"><a class="title" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记">算法笔记</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="前端知识"/></a><div class="content"><a class="title" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识">前端知识</a><time datetime="2023-06-05T16:00:00.000Z" title="发表于 2023-06-06 00:00:00">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="FSAF论文"/></a><div class="content"><a class="title" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文">FSAF论文</a><time datetime="2022-10-13T16:00:00.000Z" title="发表于 2022-10-14 00:00:00">2022-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="Faster-RCNN论文"/></a><div class="content"><a class="title" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文">Faster-RCNN论文</a><time datetime="2022-08-24T16:00:00.000Z" title="发表于 2022-08-25 00:00:00">2022-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 异梦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>