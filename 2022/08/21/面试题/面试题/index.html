<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试题 | 异梦的博客</title><meta name="keywords" content="Java"><meta name="author" content="异梦"><meta name="copyright" content="异梦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常见面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="https://yimeng436.github.io/2022/08/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="异梦的博客">
<meta property="og:description" content="常见面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yimeng436.github.io/img/top.png">
<meta property="article:published_time" content="2022-08-20T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-14T13:05:54.953Z">
<meta property="article:author" content="异梦">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yimeng436.github.io/img/top.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yimeng436.github.io/2022/08/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-14 21:05:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">异梦的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-20T16:00:00.000Z" title="发表于 2022-08-21 00:00:00">2022-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-14T13:05:54.953Z" title="更新于 2023-08-14 21:05:54">2023-08-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong><center><font size=8>面试题</font></center></strong></p>
<h1 id="Java基础题"><a href="#Java基础题" class="headerlink" title="Java基础题"></a>Java基础题</h1><h2 id="1、abstract-、final能否同时修饰一个类-x2F-方法？"><a href="#1、abstract-、final能否同时修饰一个类-x2F-方法？" class="headerlink" title="1、abstract 、final能否同时修饰一个类 &#x2F;方法？"></a><strong><font color=red>1、abstract 、final能否同时修饰一个类 &#x2F;方法？</font></strong></h2><blockquote>
<p>不可以。 </p>
<p>1、abstract 修饰的类是一个抽象类&#x2F;方法，抽象类只有被继承才有意义；</p>
<p>2、final修饰的类是一个最终类&#x2F;方法，不允许被继承。</p>
<p>所以这两个关键词在目的上是相互矛盾的，不能够同时修饰类或者方法。</p>
<p>final还可以修饰变量，修饰的时候表示这个变量的引用地址不可变，但是地内容是可变的(如果是基本数据类型，地址和值都不能变)</p>
<p><img src="/../../images/image-20230802152945387.png" alt="image-20230802152945387"></p>
<p>被final修饰的变量可以选择不再一开始初始化，但是这样就必须要有构造函数并且构造函数需要初始化被final修饰的变量</p>
</blockquote>
<h2 id="2、接口和抽象类对比"><a href="#2、接口和抽象类对比" class="headerlink" title="2、接口和抽象类对比"></a><strong><font color=red>2、接口和抽象类对比</font></strong></h2><blockquote>
<p><strong>jdk8之前:</strong></p>
<ul>
<li>接口<ul>
<li>可以多继承</li>
<li>只允许有方法的声明</li>
<li>没有构造函数</li>
<li>不能够被实例化</li>
<li>实现接口的类必须重写方法</li>
</ul>
</li>
<li>抽象类<ul>
<li>只能单继承</li>
<li><strong><font color=red>可以有实例方法，也可以有抽象方法。有抽象方法的类一定是抽象类，要用abstract修饰</font></strong></li>
<li>不能够被实例化</li>
<li>可以有构造函数、静态&#x2F;普通属性</li>
<li>继承抽象类的子类<ul>
<li>如果是抽象类，可以选择不实现父类的抽象方法</li>
<li>不是抽象类，必须重写父类的抽象方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>jdk8之后:</strong></p>
<p>比较大的区别就在于，接口可以通过default关键字来声明实例方法。也可以用static来声明类方法。</p>
<p>接口也可以有成员变量，并且默认是public static final的，方法默认是public abstract。</p>
</blockquote>
<h2 id="3、作用域对比"><a href="#3、作用域对比" class="headerlink" title="3、作用域对比"></a><strong><font color=red>3、作用域对比</font></strong></h2><table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同一个包下</th>
<th>子类</th>
<th>其他包类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="4、相等的比较"><a href="#4、相等的比较" class="headerlink" title="4、相等的比较"></a><strong><font color=red>4、相等的比较</font></strong></h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">“&#x3D;&#x3D;”和equals和hashcode()</a></p>
<h2 id="5、try-catch-finally，return覆盖问题"><a href="#5、try-catch-finally，return覆盖问题" class="headerlink" title="5、try-catch-finally，return覆盖问题"></a><strong><font color=red>5、try-catch-finally，return覆盖问题</font></strong></h2><blockquote>
<p>首先，不建议在finally里面写return 语句，因为可能会覆盖掉 try 代码块里面的return 。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<p>其次finally是在方法返回之前执行的，但是如果try代码块里面已经有return ，同样会先将要返回的结果放到本地变量中，只要finally没有return语句，就无法修改返回的值。</p>
</blockquote>
<h2 id="6、序列化和反序列化"><a href="#6、序列化和反序列化" class="headerlink" title="6、序列化和反序列化"></a><strong><font color=red>6、序列化和反序列化</font></strong></h2><blockquote>
<p>序列化：对象转为字节序列的过程。</p>
<p>反序列化：字符序列恢复为对象的过程。</p>
<p>我们只在本地JVM运行的Java实例时，是不需要进行序列化和反序列化的。但是当我们需要将内存中的对象持久化到磁盘、数据库。或者要和浏览器进行交互时，就需要使用序列化和反序列化。</p>
<p>一个实体类要实现序列化需要实现Serializable接口，JVM在加载类的时候会发现这个类实现了这个接口，然后在初始化实例对象的时候就会在底层帮我们实现序列化和反序列化。如果没有实现这个接口，在进行序列化的时候就会抛出NotSerializableException。</p>
<p>一般实现序列化接口后，需要显示的指定 一个序列化ID，如果不指定，JVM在序列化的时候会根据属性自动生成一个序列化ID，然后和属性一起序列化。</p>
<p>反序列化的时候，JVM会根据属性自动生成一个新的序列化ID，然后用这个新的ID和序列化时的旧的ID进行比较，相同则反序列化成功，否则失败报错。</p>
<p>显示指定了的话，序列化和反序列化的ID值就永远是一致的，不会出现异常情况。如果不指定序列化ID，可能会出现我们更改了类，自动生成的序列化ID就会发生改变，从而导致反序列化的时候报错。所以一般要求显示指定序列化ID。</p>
<p>Static属性不能够被序列化，因为static属性是属于类的，而不是属于对象的。</p>
</blockquote>
<h2 id="7、String-创建几个对象"><a href="#7、String-创建几个对象" class="headerlink" title="7、String 创建几个对象"></a><strong><font color=red>7、String 创建几个对象</font></strong></h2><blockquote>
<p>String s &#x3D; “abc”。  直接赋值创建的对象个数可能是 0或者1，因为直接赋值，s指向的是常量池，原来常量池中如果有  “abc” 则不会创建新的对象，如果没有就会在常量池中创建一个 “abc”对象，这个变量无论怎么样都只是指向常量池的，床不创建对象和它无关。</p>
<p>String s &#x3D; new String(“abc”)；new 首先肯定会在堆 创建一个对象，其次  abc字符串 常量又要看常量池是否有  abc这个字符串如果没有就会创建一个常量对象，否则就不会。所以答案是 1或2。</p>
<p>String s &#x3D; “abc” + “bcd” +”efg” 。看着好像会创建  3或4个对象。但是 Java会做编译时的优化，对于常量的字符串拼接会在编译期间就完成。所以运行的时候 就已经是 “abcbcdefg”了，只会取常量池对比是否有这个常量对象，没有创建，有不创建。所以答案是 0或者1个对象。</p>
<p>String a &#x3D; “a”; String b &#x3D; “b” ;  String c &#x3D; a+b;  </p>
<p>这里先假设常量池为空，所以 String a &#x3D; “a”; String b &#x3D; “b” ; 肯定会在常量池创建两个常量。</p>
<p>String c &#x3D; a+b;  这是变量之间的拼接，相比于常量拼接，这个需要在运行的时候才能确定c的值，所以不会在常量池创建一个ab 对象，而是在堆中创建一个 String 对象值为 ab。</p>
<p>因此只要字符串拼接的时候出现了new 就会创建新的字符串对象，创建的对象指向堆空间，和直接赋值的一定不是指向同一个对象</p>
</blockquote>
<h2 id="8、基本数据类型占用的内存"><a href="#8、基本数据类型占用的内存" class="headerlink" title="8、基本数据类型占用的内存"></a><strong><font color=red>8、基本数据类型占用的内存</font></strong></h2><p>1、整数类型byte（1个字节）short（2个字节）int（4个字节）long（8个字节） </p>
<p>  2、字符类型char（2个字节） </p>
<p>  3、浮点类型float（4个字节）double（8个字节）</p>
<h2 id="9、Switch支持那些数据类型"><a href="#9、Switch支持那些数据类型" class="headerlink" title="9、Switch支持那些数据类型"></a><strong><font color=red>9、Switch支持那些数据类型</font></strong></h2><p>jdk1.7之前byte,short ,int ,char </p>
<p>jdk1.7之后加入String </p>
<p>java8，switch支持10种类型 </p>
<ul>
<li>基本类型：byte char short int </li>
<li>包装类 ：Byte,Short,Character,Integer String enum </li>
<li>实际只支持int类型 Java实际只能支持int类型的switch语句，那其他的类型时如何支持的 <ul>
<li>a、基本类型byte char short 原因：这些基本数字类型可自动向上转为int, 实际还是用的int。 </li>
<li>b、基本类型包装类Byte,Short,Character,Integer 原因：java的自动拆箱机制 可看这些对象自动转为基本类型 </li>
<li>c、String 类型 原因：实际switch比较的string.hashCode值，它是一个int类型 </li>
<li>d、enum类型 原因 ：实际比较的是enum的ordinal值（表示枚举值的顺序），它也是一个int类型 所以也可以说 switch语句只支持int类型</li>
</ul>
</li>
</ul>
<h2 id="10、枚举类型"><a href="#10、枚举类型" class="headerlink" title="10、枚举类型"></a><strong><font color=red>10、枚举类型</font></strong></h2><p>枚举类中每一个枚举量都是一个常量，并且就是当前类的一个实体。</p>
<p>枚举类中<strong>所有属性和构造方法</strong>都只能是private的 ，有几个枚举量，就会调用几次枚举类的构造函数。</p>
<p><img src="/../../images/image-20230727153432987.png" alt="image-20230727153432987"></p>
<h2 id="11、成员变量和局部变量"><a href="#11、成员变量和局部变量" class="headerlink" title="11、成员变量和局部变量"></a><strong><font color=red>11、成员变量和局部变量</font></strong></h2><p>成员变量每个类型都有初始，但是局部变量没有，所以局部变量不能直接使用，需要赋初w垡通过编译。</p>
<p><img src="/../../images/image-20230728152347015.png" alt="image-20230728152347015"></p>
<h2 id="12、this-、super"><a href="#12、this-、super" class="headerlink" title="12、this()、super()"></a><strong><font color=red>12、this()、super()</font></strong></h2><p>这两个特殊的方法都是用来调用构造函数的，</p>
<p>this()：调用本类的其他构造函数</p>
<p>super()：调用父类的构造函数</p>
<p>他们都有一个要求在使用的时候必须出现在第一行，因此这两个方法就不能够同时出现在一个构造函数里面。</p>
<p>由于他们调用的是构造函数，因此可能会访问非静态变量，所以这两个方法无法在静态方法或者代码块中使用。</p>
<h2 id="13、类和接口继承和实现"><a href="#13、类和接口继承和实现" class="headerlink" title="13、类和接口继承和实现"></a><strong><font color=red>13、类和接口继承和实现</font></strong></h2><p>类和类只能单继承，类和接口一个类可以实现多个接口。</p>
<p><strong>接口和接口可以单继承、也可以多继承</strong></p>
<p>当实现多个接口的时候，只需要一个implement  不同的接口用逗号隔开。<strong>先继承后实现</strong></p>
<h2 id="14、泛型"><a href="#14、泛型" class="headerlink" title="14、泛型"></a><strong><font color=red>14、泛型</font></strong></h2><p>在JVM中，其实没有泛型的概念，JVM里面只有普通类和普通方法，没有泛型类和泛型方法。所有泛型在编译的到时候就已经全都变成普通类和普通方法了。</p>
<p>JVM理解泛型是通过：类型擦除来实现的。类型擦除是指，在编译的时候将代码中的泛型类型都转为原始的类型，如List&lt; User &gt;，在JVM中表现的就是 List&lt; Object&gt; ，并且加上必要的类型转换。</p>
<p>但是运行时JVM 可以通过反射来动态的获取泛型的一些元数据信息。</p>
<h2 id="15、内部类"><a href="#15、内部类" class="headerlink" title="15、内部类"></a><strong><font color=red>15、内部类</font></strong></h2><p> <strong>1.为什么使用内部类?</strong><br> 使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现， 对于内部类都没有影响<br> 1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:</p>
<ul>
<li><p>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。</p>
</li>
<li><p>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</p>
</li>
<li><p>创建内部类对象的时刻并不依赖于外围类对象的创建。</p>
</li>
<li><p>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</p>
</li>
<li><p>内部类提供了更好的封装，除了该外围类，其他类都不能访</p>
<p><strong>2.内部类分类:</strong></p>
<p> (一).成员内部类:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(Outer.<span class="built_in">this</span>.name);</span><br><span class="line">				System.out.println(name);</span><br><span class="line">				System.out.println(age);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Inner <span class="title function_">getInnerClass</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">			<span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">			<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> o.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">			in.show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> 1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类<strong>可以使用任意访问控制符</strong>， 如 public 、 protected 、 private 等</p>
<p>2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而<strong>不受访问控制符的影响</strong>，如直接访问 Outer 类中的私有属性age</p>
<p>3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，<br> 即：内部类 对象名 &#x3D; 外部类对象.new 内部类( );</p>
<p>4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{</p>
<p> 5.成员内部类中<strong>不能存在任何 static 的变量和方法</strong>,可以定义常量:<br> (1).因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,<br> 简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;<br> 非静态内部类的作用域是实例级别<br> (2).常量是在编译器就确定的,放到所谓的常量池了</p>
<p> ★★友情提示:<br> 1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;<br> 2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字,如:Outer.this.name</p>
<p> (二).静态内部类: 是 static 修饰的内部类,<br> 1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问<br> 2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；<br> 如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员<br> 3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 &#x3D; new 内部类();</p>
<p> 4.静态内部类也可以被 public、private、protected修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">			<span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">			<span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Coco&quot;</span>;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Jayden&quot;</span>;</span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">					System.out.println(Outer.name);</span><br><span class="line">					System.out.println(name);					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">				<span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">				i.show();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>(三).方法内部类：其作用域仅限于方法内，方法外部无法访问该内部类<br> (1).局部内部类就像是方法里面的一个局部变量一样，<strong>是不能有 public、protected、private 以及 static 修饰符的</strong><br> (2).<strong>只能访问方法中定义的 final 类型的局部变量</strong>,因为:<br> 当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,<br> 直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;<br> &#x3D;&#x3D;&gt;使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期.<br> 局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，<br> 自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;<br> 防止被篡改数据,而导致内部类得到的值不一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用的形参为何要为 final???</span></span><br><span class="line"><span class="comment">在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，</span></span><br><span class="line"><span class="comment">毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Show</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">			<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;访问外部类:&quot;</span> + a);</span><br><span class="line">					System.out.println(<span class="string">&quot;访问内部类:&quot;</span> + c);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">			i.print();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">			<span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">			o.show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;    </span><br></pre></td></tr></table></figure>

<p>   <strong>(3).注意:在JDK8版本之中,方法内部类中调用方法中的局部变量,可以不需要修饰为 final,匿名内部类也是一样的，主要是JDK8之后增加了 Effectively final 功能</strong>   </p>
<p>   <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html"><strong>http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</strong></a>   </p>
<p>   <strong>反编译jdk8编译之后的class文件,发现内部类引用外部的局部变量都是 final 修饰的</strong>    </p>
<p>  (四).匿名内部类: </p>
<p>  (1).匿名内部类是直接使用 new 来生成一个对象的引用; </p>
<p> (2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用;<br> (3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;<br> (4).匿名内部类中是不能定义构造函数的,匿名内部类中<strong>不能存在任何的静态成员变量和静态方法</strong>;<br> (5).匿名内部类中不能存在任何的静态成员变量和静态方法,<strong>匿名内部类不能是抽象的</strong>,它必须要实现继承的类或者实现的接口的所有抽象方法<br> (6).匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">          <span class="keyword">public</span> InnerClass <span class="title function_">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span>   num,String str2)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>()&#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> num + <span class="number">3</span>;</span><br><span class="line">                  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>&#123;</span><br><span class="line">                      <span class="keyword">return</span> number;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;;        <span class="comment">/* 注意：分号不能省 */</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">              <span class="type">OuterClass</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">              <span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> out.getInnerClass(<span class="number">2</span>, <span class="string">&quot;chenssy&quot;</span>);</span><br><span class="line">              System.out.println(inner.getNumber());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">interface</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span>;</span><br><span class="line">      &#125;     </span><br></pre></td></tr></table></figure>





<h1 id="Java程序题"><a href="#Java程序题" class="headerlink" title="Java程序题"></a>Java程序题</h1><h2 id="1、下面程序运行结果（类初始化的过程，实例初始化的过程，方法重写）"><a href="#1、下面程序运行结果（类初始化的过程，实例初始化的过程，方法重写）" class="headerlink" title="1、下面程序运行结果（类初始化的过程，实例初始化的过程，方法重写）"></a><strong><font color=red>1、下面程序运行结果（类初始化的过程，实例初始化的过程，方法重写）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yhz.First;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;1、&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;2、&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;3、&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;4、&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;5、&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> test();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;6、&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son()&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;7、&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;8、&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;9、&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;10、&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.print(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：类初始化的过程，实例初始化的过程，方法重写。</p>
<ul>
<li>类初始化的过程：什么时候会出现类初始化，创建一个类的对象的时候，但是还有一个情况会出现类初始化，那就是main方法所在的类同样会先做一些类的初始化。并且初始化一个类的时候会先去初始化它的父类。</li>
</ul>
<p>类初始化由&lt; clinit &gt; 来完成，&lt; clinit &gt; 会完成静态代码块和静态变量赋值。按照顺序执行，并且只执行一次。我们把上面的代码主函数中的内容删掉运行一下。</p>
<p><img src="/../../images/image-20230419100356035.png" alt="image-20230419100356035"></p>
<p>可以看到结果和我们上面讲的一致，先初始化父类，并且静态变量和静态代码块按照顺序执行。</p>
<ul>
<li>实例初始化的过程：在创建一个类的对象的时候会完成初始化。通过&lt; init &gt;来完成，&lt; init &gt;主要执行的是非静态成员变量赋值、非静态代码块、构造方法，会执行多次。并且非静态变量和代码块按照顺序执行，构造方法最后执行，有父类同样会先加载父类。如果子类有非静态方法的重写，那么父类执行的也是子类的重写方法。那么结果就显而易见了</li>
</ul>
<p><img src="/../../images/image-20230419102225762.png" alt="image-20230419102225762"></p>
<h2 id="2、下面代码运行结果是什么（参数传递、特殊类型不可变性）"><a href="#2、下面代码运行结果是什么（参数传递、特殊类型不可变性）" class="headerlink" title="2、下面代码运行结果是什么（参数传递、特殊类型不可变性）"></a><strong><font color=red>2、下面代码运行结果是什么（参数传递、特殊类型不可变性）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        change(str,i,j,nums,data);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;str=&quot;</span>+str);</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">        System.out.println(<span class="string">&quot;j=&quot;</span>+j);</span><br><span class="line">        System.out.println(<span class="string">&quot;nums=&quot;</span>+nums[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;data.a=&quot;</span>+data.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String s,<span class="type">int</span> i,Integer j,<span class="type">int</span>[] nums,Data data)</span>&#123;</span><br><span class="line">        s+=<span class="string">&quot; world&quot;</span>;</span><br><span class="line">        i+=<span class="number">1</span>;</span><br><span class="line">        j+=<span class="number">1</span>;</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        data.a = <span class="number">22</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：参数传递、特殊类型不可变性</p>
<blockquote>
<p>Java中基本数据类型都是值传递，引用数据类型传递的是地址的值所以也可以看作是值传递。只不过形参同样可以操作对应的地址。</p>
<p>特殊类型不可变性：这个特殊类型指的是String和包装类，这些本身是传递的是地址值给形参，但是如果在形参要对这两种类型进行修改的话，不会改变原来地址的指向的值，而是会重新创建一个新的常量或对象将其地址赋值给操作的变量。所以原本的实参的值也是不会发生改变的。</p>
</blockquote>
<p><img src="/../../images/image-20230419105413890.png" alt="image-20230419105413890"></p>
<h2 id="3、下面代码运行结果是什么"><a href="#3、下面代码运行结果是什么" class="headerlink" title="3、下面代码运行结果是什么"></a><strong><font color=red>3、下面代码运行结果是什么</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo3</span> <span class="variable">demo3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br><span class="line">        <span class="type">Demo3</span> <span class="variable">demo31</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br><span class="line">        demo3.test(<span class="number">10</span>);</span><br><span class="line">        demo3.test(<span class="number">20</span>);</span><br><span class="line">        demo31.test(<span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo3.i=&quot;</span>+demo3.i);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo3.j=&quot;</span>+demo3.j);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo3.s=&quot;</span>+demo3.s);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo3.i=&quot;</span>+demo31.i);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo3.j=&quot;</span>+demo31.j);</span><br><span class="line">        System.out.println(<span class="string">&quot;demo3.s=&quot;</span>+demo31.s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：局部变量、类加载</p>
<blockquote>
<p>首先是类加载，第11题刚刚讲了类加载和实例加载的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Demo3</span> <span class="variable">demo3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br><span class="line"><span class="type">Demo3</span> <span class="variable">demo31</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br></pre></td></tr></table></figure>

<p>两次创建实例，只调用一次&lt; clinit &gt;方法，两次&lt; init &gt;方法，demo3创建的过程，先会创建静态的s，并且也只会创建一次，然后执行非静态成员变量和非静态代码块，i和j都是demo3的成员变量只属于demo3，非静态代码块的i是局部变量，不会改变成员变量的值，所以demo3中的结果是 i&#x3D;0，j&#x3D;1，s&#x3D;1。</p>
<p>创建demo31时候，只需要执行非静态代码块了，因为静态的已经被加载了，而且操作静态变量两个对象的值都会发生改变，所以demo31创建结束后的结果是，demo3：i&#x3D;0,j&#x3D;1,s&#x3D;2;demo31的结果i&#x3D;0,j&#x3D;1,s&#x3D;2。</p>
<p>demo3执行两次test，j是局部变量不会改变成员变量的值，所以实际上就是对 i和s加了2，而s是静态变量所以demo3的改变会影响demo31的结果，demo3：i&#x3D;2,j&#x3D;1,s&#x3D;4;demo31：i&#x3D;0,j&#x3D;1,s&#x3D;4</p>
<p>demo31执行一次test，同理最终的结果是：demo3：i&#x3D;2,j&#x3D;1,s&#x3D;5;demo31：i&#x3D;1,j&#x3D;1,s&#x3D;5</p>
</blockquote>
<h2 id="4、下面代码运行结果是什么（自动拆装箱，参数传递形式，”-x3D-x3D-”和equals比较-）"><a href="#4、下面代码运行结果是什么（自动拆装箱，参数传递形式，”-x3D-x3D-”和equals比较-）" class="headerlink" title="4、下面代码运行结果是什么（自动拆装箱，参数传递形式，”&#x3D;&#x3D;”和equals比较  ）"></a><strong><font color=red>4、下面代码运行结果是什么（自动拆装箱，参数传递形式，”&#x3D;&#x3D;”和equals比较  ）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var4</span> <span class="operator">=</span> var3;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);</span><br><span class="line">    dosomething(var6);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var7</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;var1==var2：&quot;</span>+(var1==var2));</span><br><span class="line">    System.out.println(<span class="string">&quot;var1.equals(var2)：&quot;</span>+var1.equals(var2));</span><br><span class="line">    System.out.println(<span class="string">&quot;var3 == var4：&quot;</span>+(var3 == var4));</span><br><span class="line">    System.out.println(<span class="string">&quot;var3 == var1：&quot;</span>+(var3 == var1));</span><br><span class="line">    System.out.println(<span class="string">&quot;var3 == var5：&quot;</span>+(var3 == var5));</span><br><span class="line">    System.out.println(<span class="string">&quot;var6==var1：&quot;</span>+(var6==var1));</span><br><span class="line">    System.out.println(<span class="string">&quot;var6.equals(var1)：&quot;</span>+var6.equals(var1));</span><br><span class="line">    System.out.println(<span class="string">&quot;var7==var8：&quot;</span>+(var7==var8));</span><br><span class="line">    System.out.println(<span class="string">&quot;var7.equals(var8)：&quot;</span>+var7.equals(var8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">dosomething</span><span class="params">(Integer tem)</span>&#123;</span><br><span class="line">    tem = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：自动拆装箱，参数传递形式，”&#x3D;&#x3D;”和equals比较  </p>
<blockquote>
<p>对于这一题需要知道一下知识点：</p>
<ul>
<li><p>包装类</p>
<ul>
<li><p>首先要知道，对于包装类，有部分缓存的引用值，对于Integer来说是  -128-127这个范围内，目的是为了减少对象重复创建。</p>
</li>
<li><p>对于在这个范围内的数值，Integer在直接赋值的时候，都是直接将变量指向了对应的引用，而不是通过new创建一个新的对象。</p>
</li>
<li><p>但是如果是通过new Integer得到的对象就一定是新的空间。</p>
</li>
</ul>
</li>
<li><p>“&#x3D;&#x3D;”和equals</p>
<ul>
<li><p>对于基本数据类型来说，<code>==</code> 比较的是值。</p>
</li>
<li><p>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</p>
</li>
<li><p><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</p>
<p><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</p>
</li>
<li><p><code>==</code> 在用于比较包装类和基本数据类型的时候，包装类进行自动拆箱为基本数据类型进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span> ; <span class="comment">//new Integer(200);</span></span><br><span class="line">System.out.println(a==b);    <span class="comment">//都是true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>equals() </code> 包装类调用equals和基本数据类型进行比较时，会先对基本数据类型进行自动装箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span> ; <span class="comment">//new Integer(200);</span></span><br><span class="line">System.out.println(b.equals(a)); <span class="comment">//都是true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Java的参数传递形式，是值传递，引用数据类型传递的则是引用地址值</p>
</li>
</ul>
</blockquote>
<p>回到题目，</p>
<ul>
<li>第一部分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>根据上面说的，new 出来的都是新开辟的空间，那么var1和var2肯定指向的不是同一个地址，但是他们的值是相等的，Integer类重写了equals方法，比较的是两个对象的int 值是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以结果也就很显而易见：&#x3D;&#x3D;false&#x3D;&#x3D;、&#x3D;&#x3D;true&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;var1==var2：&quot;</span>+(var1==var2));</span><br><span class="line">System.out.println(<span class="string">&quot;var1.equals(var2)：&quot;</span>+var1.equals(var2));</span><br></pre></td></tr></table></figure>



<ul>
<li>第二部分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">var4</span> <span class="operator">=</span> var3;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>根据包装类，缓存的特性，可以知道，var3和var5指向的肯定是同一个地址，var4更简单直接指向了var3的地址，所以这三个变量 无论是值还是地址都是相同的，并且这个地址肯定和var1、var2通过new 出来的不一样</p>
<p>所以结果：&#x3D;&#x3D;true&#x3D;&#x3D;、&#x3D;&#x3D;false&#x3D;&#x3D;、&#x3D;&#x3D;true&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;var3 == var4：&quot;</span>+(var3 == var4));</span><br><span class="line">System.out.println(<span class="string">&quot;var3 == var1：&quot;</span>+(var3 == var1));</span><br><span class="line">System.out.println(<span class="string">&quot;var3 == var5：&quot;</span>+(var3 == var5));</span><br></pre></td></tr></table></figure>





<ul>
<li>第三部分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);</span><br><span class="line">dosomething(var6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">dosomething</span><span class="params">(Integer tem)</span>&#123;</span><br><span class="line">    tem = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>new 的对象肯定地址不一样，经过dosomething方法，var6作为参数传给了tem，由于java是传值的，所以tem和var6指向了同一个地址值。方法体中，tem指向了一个新的地址，但是由于值传值，所以var6指向的还是原来那个地址值，所以var6什么都不会发生改变。</p>
<p><img src="/../../images/image-20230614113235956.png" alt="image-20230614113235956"></p>
<p>所以结果：&#x3D;&#x3D;false&#x3D;&#x3D;、&#x3D;&#x3D;false&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;var6==var1：&quot;</span>+(var6==var1));</span><br><span class="line">System.out.println(<span class="string">&quot;var6.equals(var1)：&quot;</span>+var6.equals(var1));</span><br></pre></td></tr></table></figure>

<p>这里要注意的一点是，就算方法体里面写成  tem &#x3D; 1，和 主线程里面的var6 &#x3D; 1 引用的也是不同的地址。</p>
<p>最后两个没什么好说的。就是包装类特性。</p>
<h2 id="5、下面代码运行结果是什么（类加载顺序，多态）"><a href="#5、下面代码运行结果是什么（类加载顺序，多态）" class="headerlink" title="5、下面代码运行结果是什么（类加载顺序，多态）"></a><strong><font color=red>5、下面代码运行结果是什么（类加载顺序，多态）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        callName();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System. out. println(baseName);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> <span class="string">&quot;sub&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callName</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System. out. println (baseName) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：类加载顺序，多态</p>
<blockquote>
<p>1、首先要明白类加载的顺序</p>
<p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法) </p>
<p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法  )</p>
<p>(3) 父类非静态代码块(  包括非静态初始化块，非静态属性  )</p>
<p>(4) 父类构造函数</p>
<p>(5) 子类非静态代码块  (  包括非静态初始化块，非静态属性  )</p>
<p>(6) 子类构造函数</p>
<p>其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的) 还有一个就是类的普通方法加载到方法区是在完成类加载的时候就完成了的，不然构造方法就没办法调用普通方法。</p>
<p>2.其次，需要理解子类覆盖父类方法的问题，也就是<strong>方法重写实现多态</strong>问题。</p>
<p>Base b &#x3D; new Sub();<strong>它为多态的一种表现形式，声明是Base,实现是Sub类，</strong>  <strong>理解为</strong>       </p>
<p><strong>b</strong>    <strong>编译时表现为Base类特性，运行时表现为Sub类特性。</strong> 也就是常说的编译时看左边，运行时看右边</p>
<p>当子类覆盖了父类的方法后，意思是父类的方法已经被重写，<strong>题中</strong>    <strong>父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。</strong></p>
<p>由1.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时  baseName为空。  所以为null。</p>
<p>这里还有一个比较迷惑的地方，就是Sub类是一个静态内部类，可能很容易误以为，静态内部类和静态代码块一样会会先被加载，但实际上，静态内部内和外部类没有直接的联系，外部类在加载的时候不会现在加静态内部类。所以静态内部内其实和Base 类外部定义一个Sub是类似的，唯一的不同就是内部类可以不被其他类调用。</p>
</blockquote>
<h2 id="6、下面代码运行结果是什么（构造函数、继承）"><a href="#6、下面代码运行结果是什么（构造函数、继承）" class="headerlink" title="6、下面代码运行结果是什么（构造函数、继承）"></a><strong><font color=red>6、下面代码运行结果是什么（构造函数、继承）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;No name&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String nm)</span> &#123;</span><br><span class="line">        name = nm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">empID</span> <span class="operator">=</span> <span class="string">&quot;0000&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        empID = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(e.empID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：构造函数、继承</p>
<blockquote>
<p>子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。<br> 而父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数。</p>
<p>因此上面的代码，在编译期间就会报错，需要在子类的构造方法中，显示调用父类的有参构造。</p>
</blockquote>
<h2 id="7、下面代码运行结果是什么（集合、自动拆装箱）"><a href="#7、下面代码运行结果是什么（集合、自动拆装箱）" class="headerlink" title="7、下面代码运行结果是什么（集合、自动拆装箱）"></a><strong><font color=red>7、下面代码运行结果是什么（集合、自动拆装箱）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="type">List</span>  <span class="variable">Listlist1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">      Listlist1.add(<span class="number">0</span>);</span><br><span class="line">      <span class="type">List</span> <span class="variable">Listlist2</span> <span class="operator">=</span> Listlist1;</span><br><span class="line">      System.out.println(Listlist1.get(<span class="number">0</span>) <span class="keyword">instanceof</span> Integer);</span><br><span class="line">      System.out.println(Listlist2.get(<span class="number">0</span>) <span class="keyword">instanceof</span> Integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：集合、自动拆装箱</p>
<blockquote>
<p> List 没有指定泛型，所以默认是Object类型的，但是add的传递的参数是基本类型 int，add会自动将参数转为对象，对于int 来说 就是自动装箱，变成Integer，所以list1里面的0  就是一个Integer类型的元素，所以在用instanceof 判断时候得到的结果是 true。 list2 只是引用了同一个地址，所以结果也是true。</p>
</blockquote>
<h2 id="8、下面代码运行结果是什么（final-继承-修饰限定符）"><a href="#8、下面代码运行结果是什么（final-继承-修饰限定符）" class="headerlink" title="8、下面代码运行结果是什么（final 继承 修饰限定符）"></a><strong><font color=red>8、下面代码运行结果是什么（final 继承 修饰限定符）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>  <span class="title class_">Car</span>(). run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System. out. println (<span class="string">&quot;Car&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System. out. println(<span class="string">&quot;Vehicle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：final 继承 修饰限定符</p>
<blockquote>
<p>很容易认为这题无法通过编译，因为final修饰的方法无法被修改。</p>
<p>但是这里的run方法除了被final修饰以外，还被private修饰了，因此子类根本无法继承这个私有方法run，所以子类根本不是重写了 父类的run方法，而是重新定义了一个run方法。</p>
<p>所以结果就是 Car。</p>
<p>除了private修饰方法不能被继承以外，还有一个就是父类的static方法子类也无法继承，如果子类有同样的方法声明也只算是定义了一个同名方法而不是方法重写。</p>
</blockquote>
<h2 id="9、下面代码运行结果是什么（三元运算符）"><a href="#9、下面代码运行结果是什么（三元运算符）" class="headerlink" title="9、下面代码运行结果是什么（三元运算符）"></a><strong><font color=red>9、下面代码运行结果是什么（三元运算符）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="literal">true</span> ? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">    Object o2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    o2 = <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o2 = <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(o1);</span><br><span class="line">    System.out.print(<span class="string">&quot; &quot;</span>);         </span><br><span class="line">    System.out.print(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：三元运算符</p>
<blockquote>
<p>三元操作符类型的转换规则： </p>
<p>1.若两个操作数不可转换，则不做转换，返回值为Object类型 </p>
<p>2.若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。 </p>
<p>3.若两个操作数中有一个是数字S,另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。 </p>
<p>4.若两个操作数都是直接量数字，则返回值类型为范围较大者 </p>
<p>总结来说就是，三元运算符会自动向上转型，会保证大范围的类型，这题前后是Integer和Double，所以会自动转成Double包装类类型，所以选D</p>
</blockquote>
<h2 id="10、下面代码运行结果是什么（二元运算符的基础类型数据转换）"><a href="#10、下面代码运行结果是什么（二元运算符的基础类型数据转换）" class="headerlink" title="10、下面代码运行结果是什么（二元运算符的基础类型数据转换）"></a><strong><font color=red>10、下面代码运行结果是什么（二元运算符的基础类型数据转换）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompareReference</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">       <span class="type">float</span> f=<span class="number">42.0f</span>;</span><br><span class="line">       <span class="type">float</span> f1[]=<span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="type">float</span> f2[]=<span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="type">float</span>[] f3=f1;</span><br><span class="line">       <span class="type">long</span> x=<span class="number">42</span>;</span><br><span class="line">       f1[<span class="number">0</span>]=<span class="number">42.0f</span>;</span><br><span class="line">       System.out.println(f1==f2);</span><br><span class="line">       System.out.println(x==f1[<span class="number">0</span>]);</span><br><span class="line">       System.out.println(f1==f3);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>考点：二元运算符的基础类型数据转换</p>
<blockquote>
<p>二元运算会有如下转换操作：</p>
<p>如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。</p>
<p>否则，如果其中一个操作数是float类型，另一个将会转换为float类型。</p>
<p>否则，如果其中一个操作数是long类型，另一个会转换为long类型。 </p>
<p>否则，两个操作数都转换为int类型</p>
<p><strong>所有的byte,short,char型的值将被提升为int型； 这个非常容易忽略，比如两个byte相加赋值给另一个byte的时候需要强制向下转换类型，不然会无法通过编译。但是如果这些类型被final修饰则不会自动提升，而是在编译期间就能够得到最终的结果</strong></p>
<p>也就是说，二元运算符无论是加减乘除还是判断相等，结果的类型都是两个数的最大类型。</p>
<p>判断相等时候，会先完成类型转换，再进行比较</p>
</blockquote>
<h2 id="11、下面代码运行结果是什么（运算优先级，字符串运算）"><a href="#11、下面代码运行结果是什么（运算优先级，字符串运算）" class="headerlink" title="11、下面代码运行结果是什么（运算优先级，字符串运算）"></a><strong><font color=red>11、下面代码运行结果是什么（运算优先级，字符串运算）</font></strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">20</span>, y=<span class="number">5</span>;</span><br><span class="line">System.out.println(x+y +<span class="string">&quot;&quot;</span>+(x+y)+y); </span><br></pre></td></tr></table></figure>



<blockquote>
<p> 考点：运算优先级，字符串运算</p>
<p>1）不论有什么运算，小括号的优先级都是最高的，先计算小括号中的运算，得到x+y +””+25+y </p>
<p>  2）任何字符与字符串相加都是字符串，但是是有顺序的，字符串前面的按原来的格式相加，字符串后面的都按字符串相加，得到25+“”+25+5 </p>
<p>  3）上面的结果按字符串相加得到25255</p>
</blockquote>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1、ArrayList线程安全吗？举个例子"><a href="#1、ArrayList线程安全吗？举个例子" class="headerlink" title="1、ArrayList线程安全吗？举个例子"></a><strong><font color=red>1、ArrayList线程安全吗？举个例子</font></strong></h2><blockquote>
<p>线程不安全。</p>
<ul>
<li>并发修改异常</li>
</ul>
<p><img src="/../../images/image-20230422102534886.png" alt="image-20230422102534886"></p>
<ul>
<li>解决1：使用线程安全的，我们知道ArrayList继承了List接口，ArrayList的方法没有加锁，但是还有一个同样是先List结构但是每个方法都用sync修饰从集合：vector。所以可以用vector代替ArrayList，但是一般不这么干。</li>
<li>解决2：用Collections提供的集合线程安全化方法。可以将 不安全的list、set、map都转换为线程安全的。</li>
</ul>
<p><img src="/../../images/image-20230422103504443.png" alt="image-20230422103504443"></p>
<ul>
<li>解决3：写时复制List，CpoyOnWriteArrayList。</li>
</ul>
<p><img src="/../../images/image-20230422104142276.png" alt="image-20230422104142276"></p>
<p>  底层都一样还是Object数组，但是Copy加了volatile关键字修饰</p>
<ul>
<li><ul>
<li>add方法对比</li>
</ul>
<p><img src="/../../images/image-20230422104501291.png" alt="image-20230422104501291"></p>
</li>
</ul>
<p>既然ArrayList可以有以上几种操作，那对于不安全的集合set和map也是类似的做法。</p>
<ul>
<li>HashSet对应的线程安全版本</li>
</ul>
<p> <img src="/../../images/image-20230422105238876.png" alt="image-20230422105238876"></p>
<p>会发现，它的底层居然还是CopyOnWriteArrayList。</p>
</blockquote>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="1、Mysql什么时候应该建立索引，什么时候不应该建立索引"><a href="#1、Mysql什么时候应该建立索引，什么时候不应该建立索引" class="headerlink" title="1、Mysql什么时候应该建立索引，什么时候不应该建立索引"></a><strong><font color=red>1、Mysql什么时候应该建立索引，什么时候不应该建立索引</font></strong></h2><blockquote>
<p>什么是索引？</p>
<p>索引是提供Mysql高效查找的一个数据结构，所以他是需要被存储的，并且它能够提高查询速度，那么相应的如果有增加、删除等操作，如果还要保存索引，那么自然而然就降低了对应的增加和删除的速度。</p>
<p>所以什么时候应该建立、什么时候不应该建立也就明白了：</p>
<p>1、主键Mysql会自动帮我们创建索引</p>
<p>2、对于频繁查找的字段适合建索引</p>
<p>3、多表查询关联的字段适合建索引</p>
<p>4、排序字段适合建立索引</p>
<p>1、对于修改频繁的字段不应该建索引</p>
<p>2、不会作为where条件的字段不适合建立索引</p>
</blockquote>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1、简单描述一下Spring中的事务传播行为，以及事务的隔离界别"><a href="#1、简单描述一下Spring中的事务传播行为，以及事务的隔离界别" class="headerlink" title="1、简单描述一下Spring中的事务传播行为，以及事务的隔离界别"></a><strong><font color=red>1、简单描述一下Spring中的事务传播行为，以及事务的隔离界别</font></strong></h2><blockquote>
<p>事务传播行为：一个开启了事务的方法调用了另一个开启了事务的方法，是使用原来的事务还是重新开启一个新的事务？</p>
<p>事务的传播行为可以通过，@Transactional(propagation &#x3D; )propagation 属性来指定，里面定义了七种传播行为：</p>
<p>用的较多的就是默认的REQUIRED和REQUIRED_NEW</p>
<p><img src="/../../images/image-20230419112626006.png" alt="image-20230419112626006"></p>
<p>例子：假设我有两个方法都开启了事务，A方法会调用B方法两次</p>
<p>如果我是REQUIRED级别的话：A只有两次调用B都成功才算成功否则回滚</p>
<p>相反REQUIRED_NEW的话：B成功几次A就成功几次，因为外层事务会失效</p>
<p>隔离级别见：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">MySQL常见面试题总结 | JavaGuide(Java面试+学习指南)</a></p>
<p>数据库隔离级别是数据库完成的</p>
</blockquote>
<h2 id="2、AOP通知的执行顺序"><a href="#2、AOP通知的执行顺序" class="headerlink" title="2、AOP通知的执行顺序"></a><strong><font color=red>2、AOP通知的执行顺序</font></strong></h2><blockquote>
<p>AOP通知包括：前置、后置、环绕、异常、返回后。说说这些通知执行的顺序。</p>
<p>假设我在一个aop中把这些都配置了：</p>
<p>Before、After、Around、AfterReturning、AfterThrowing</p>
<p>分别的执行顺序是什么。</p>
<ul>
<li>Spring4：<ul>
<li>无异常版本：Before肯定是第一个没问题，然后Around_before是第二个肯定也没有问题，然后Around执行对应的方法，然后Around_after，再然后After，最后是AfterReturning返回后才执行。</li>
<li>异常版本：Before肯定是第一个没问题，然后Around_before是第二个肯定也没有问题，然后Around执行对应的方法出现异常，Around_after肯定就不会被打印了，而是执行After，最后执行AfterThrowing。</li>
<li>总结：Before和After是一定会被执行的，并且After一定是在倒数第二的顺序，最后一个正常就是AfterReturning，异常就是AfterThrowing。Around的执行夹在Before和After中间</li>
</ul>
</li>
<li>Spring5：和Spring4差别比较大<ul>
<li>无异常版本：最先执行的变成了Around_before，最后执行的变成Around_after，Around把别的夹在中间了。第二个执行的是Before、然后After和AfterReturning的顺序也变了，变成先执行AfterReturning再After了。整个的顺序是：Around_before&#x3D; &#x3D;&gt;Before&#x3D; &#x3D;&gt;Around &#x3D; &#x3D;&gt;AfterReturning &#x3D; &#x3D;&gt; After &#x3D; &#x3D;&gt;Around_after</li>
<li>有异常版本：和上面的类似整个的顺序是：Around_before&#x3D; &#x3D;&gt;Before&#x3D; &#x3D;&gt;Around出现异常 &#x3D; &#x3D;&gt;AfterThrowing &#x3D; &#x3D;&gt; After</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3、Spring循环依赖？"><a href="#3、Spring循环依赖？" class="headerlink" title="3、Spring循环依赖？"></a><strong><font color=red>3、Spring循环依赖？</font></strong></h2><blockquote>
<p>场景：Spring容器中，有两个或两个以上的类的属性之间相互依赖的情况。如Class A 有属性B，Class B有属性A；Class A 有属性B，Class B有属性C，Class C有属性A等这种情况。</p>
<p> Spring依赖注入的两种方式对循环依赖的支持度：</p>
<ul>
<li><p>构造器注入：很不友好，最简单的例子，A要通过构造方法注入容器，但是构造方法需要B对象，B需要用构造方法住容器，但是B又需要A，但是A还没有被注入容器，从而导致循环依赖，会抛出一个BeanCurrentlyInCreateionException。所以避免循环依赖的一种方法就是少用甚至不用构造器注入。</p>
</li>
<li><p>Set方法注入：比较友好。只要保证了是set方法注入并且是单例模式就不会出现循环依赖的 问题。但是如果是其他模式，如prototype就会报错。</p>
</li>
<li><ul>
<li>原型模式创建</li>
</ul>
</li>
</ul>
<p><img src="/../../images/image-20230422200909756.png" alt="image-20230422200909756"></p>
<p> <img src="/../../images/image-20230422201025398.png" alt="image-20230422201025398"></p>
</blockquote>
<h2 id="4、单例模式如何解决循环依赖的？"><a href="#4、单例模式如何解决循环依赖的？" class="headerlink" title="4、单例模式如何解决循环依赖的？"></a><strong><font color=red>4、单例模式如何解决循环依赖的？</font></strong></h2><blockquote>
<p>一个重要的类DefaultSingletonBeanRegistry。这个类里面有三级缓存也就是三个map用于解决循环以来问题。</p>
<p> <img src="/../../images/image-20230422201357921.png" alt="image-20230422201357921"></p>
<ul>
<li>singletoneObjects：一级缓存，存放的是已经初始化好了的bean</li>
<li>earlySingletonObjects：二级缓存，存放的是实例化 ，但是没有被初始化的的bean，实例化就是只分配了内存，但是属性还没有赋值的。</li>
<li>singletoneFactories：三级缓存，存放的是FactoryBean。指的如果A实现了FactoryBean，那么依赖注入A时，注入的不是A而是产生A的工厂类的bean。</li>
</ul>
<p>后续的debug spring源码会放在**<font color=red>其他</font>**这个部分的第二点。这里做一些源码知识的补充：</p>
<p>获取一个单例bean的简单的流程：会先经过getSingleton方法从一级缓存中获取，如果有直接返回，没有就会调用doCreateBean方法去懒加载这个Bean，然后调用popularBean为Bean填充属性，最后调用addSingletone加Bean加入一级缓存。这只是一个简单的流程，详细的说明见其他部分的Debug。</p>
<p>这里直接说Single是如何解决循环依赖的结论：</p>
<p>主要就是因为DefaultSingletonRegister这个类中的三级缓存，假设我们现在有类A，A中需要依赖类B，类B中需要依赖类A。</p>
<p>那么在创建A这个Bean的时候会经过以下缓存迁移的步骤：</p>
<p>首先先去实例化A，为A分配内存，准备初始化时发现还需要获得B，因此先把A放到三级缓存中，上面我们也说到了三级缓存放的是能够创建A工厂类是一个函数式接口ObjectFactory，这个接口里面有getObject方法，会帮我们去创建A，为了让这个工厂能够创建A所以我们有要求A必须要有一个<strong>空参构造</strong>。</p>
<p>到了B去实例化之后，同样初始化时发现需要A，然后就会去一级缓存、二级缓存、三级缓存依次查找(A也会经过这个过程上面没有写到)。此时我们会在三级缓存中找到能够创建A的工厂，然后会就通过这个工厂去创建A，并且删除三级缓存中的A工厂，然后将A放入二级缓存，并且初始化B的属性，从而完成B的初始化，将B放入一级缓存。</p>
<p>最后回来创建A，可以从一级缓存中直接拿到B，从而完成A的创建并且将A也放入一级缓存。</p>
</blockquote>
<h2 id="5、依赖注入的方式，-Autowired-和-Resource-区别"><a href="#5、依赖注入的方式，-Autowired-和-Resource-区别" class="headerlink" title="5、依赖注入的方式，@Autowired 和 @Resource 区别"></a><font color=red>5、依赖注入的方式，@Autowired 和 @Resource 区别</font></h2><blockquote>
<p><strong>Spring常见的DI方式</strong></p>
<p>构造器注入 ：利用构造方法的参数注入依赖<br>Setter注入 ：调用Setter的方法注入依赖<br>字段注入 ：在字段上使用@Autowired&#x2F;Resource注解</p>
<p><strong>@Autowired VS @Resource</strong></p>
<p>事实上，他们的基本功能都是通过注解实现依赖注入 ，只不过@Autowired是Spring定义的，而@Resource是JSR-250定义的。大致功能基本相同，但是还有一些细节不同：</p>
<p>依赖识别方式 ：@Autowired默认是byType 可以使用@Qualifier指定Name，@Resource默认ByName 如果找不到则ByType<br>适用对象 ：@Autowired可以对构造器、方法、参数、字段 使用，@Resource只能对方法、字段 使用<br>提供方 ：@Autowired是Spring 提供的，@Resource是JSR-250 提供的</p>
<p> 官方不推荐使用字段注入，如果要使用建议使用@Resource</p>
<p>原因看看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        testService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">TestController</span> <span class="variable">testController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestController</span>();</span><br><span class="line">    testController.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种方式调用test 方法是会报空指针异常的，这就是字段注入的第一个问题：对象外部可见性，无法在容器外实例化字段注入的组件，会导致组件与IoC容器紧耦合 （这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）</p>
<p>另一个字段注入的问题：无法设置注入的对象为final，也无法注入静态变量，原因是变量必须在类实例化进行初始化。</p>
<p>虽然字段注入这么多不好，但是字段注入有一个非常大的优点就是太方便了，并且业务和框架的完全松绑定本来就是一种理想的设计，那如果要用字段注入推荐使用那种方式呢？</p>
<blockquote>
<p>@Autowired 是Spring 提供的，它是特定IoC提供的特定注解 ，这就导致了应用与框架的强绑定 ，一旦换用了其他的IoC框架，是不能够支持注入 的。</p>
<p>而 @Resource 是JSR-250 提供的，它是Java标准 ，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。</p>
</blockquote>
</blockquote>
<h2 id="6、IOC"><a href="#6、IOC" class="headerlink" title="6、IOC"></a><strong><font color=red>6、IOC</font></strong></h2><blockquote>
<p> 控制反转：控制指的是对象创建的过程，反转指的是创建对象的主题由程序员转变为容器。</p>
<p>最直观的优点就是能够很大程度的实现解耦，不需要再代码中创建各个bean对象。我们只需要定义bean的构建过程，真正的创建由spring容器来负责。</p>
<p>其次程序运行时容器就会被初始化，容器中的bean也就会被实例化。从这个角度来看我们将一个bean构建由运行期，提前到了启动时期。这样如果有一些bean存在无法解决的循环依赖，或是其他问题就能够在项目启动时期就报错，满足软件发开的fast fail 原则，提高代码的可靠性和稳定性。</p>
<p>还有就是，spring容器默认会创建单例实例，这也是大多数情况下所创建的，创建单例bean能够减少高并发下的反复的 new 对象，造成系统资源浪费，甚至导致JVM出现 OOM的情况。</p>
</blockquote>
<h2 id="7、AOP"><a href="#7、AOP" class="headerlink" title="7、AOP"></a><strong><font color=red>7、AOP</font></strong></h2><blockquote>
<p>面向切面的编程，是OOP的一种扩展。它的作用就是通过一些特殊的手段将一段代码织入到目标方法中，从而实现对目标方法的增强。</p>
<p>Spring Aop 是一种运行时的增强，相比于字节码编译技术上实现增强，运行时增加相对简单、灵活，但是性能上有所缺失。</p>
<p>运行时增强所采用的技术 就是动态代理技术。如果目标方法存在接口就是用JDK内置的动态代理实现，如果没有接口就是用cjlib来实现动态代理</p>
</blockquote>
<h2 id="8、事务失效场景"><a href="#8、事务失效场景" class="headerlink" title="8、事务失效场景"></a><strong><font color=red>8、事务失效场景</font></strong></h2><blockquote>
<p>第一种情况，就是加了事务注解的方法需要是可重写的的，也就是不能被private、final修饰。</p>
<p>第二种情况，一个没有添加事务的方法调用了别的添加了事务的方法。</p>
<p>第三种，子线程和主线程调用事务相互交织的时候，事务会失效，要么全都交给子线程，要么全都交给主线程。</p>
<p>第四种，自己捕获了异常，因为@Transaction 需要捕获异常才会触发事务回滚，如果我们自己用try  catch捕获且处理了异常，就会认为没有发现异常不会回滚事务。</p>
<p>第五种，在第四种的基础上，我在catch代码块里面，抛出了一个Exception。这种情况下虽然抛出了异常，但是事务还是不会生效的，因为@Transaction 需要接收的是一个 RuntimeException 或者 error 的子类。</p>
<p>从第五点我们也能够知道，如果我们自定义了一个异常类，交给@Transaction 捕获时，一定要是RuntimeException 或者 error 的子类，否则事务也不会生效。</p>
</blockquote>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="1、请求中文乱码问题如何解决？"><a href="#1、请求中文乱码问题如何解决？" class="headerlink" title="1、请求中文乱码问题如何解决？"></a><strong><font color=red>1、请求中文乱码问题如何解决？</font></strong></h2><blockquote>
<p>Post请求：可以通过配置CharacterEncodingFilter过滤器来实现：</p>
<p>在web.xml中配置相应的 过滤器名和全类名，并且还需要指定编码方式</p>
<ul>
<li>CharacterEncodingFilter</li>
</ul>
<p><img src="/../../images/image-20230419115232296.png" alt="image-20230419115232296"></p>
<ul>
<li>web.xml</li>
</ul>
<p><img src="/../../images/image-20230419115420521.png" alt="image-20230419115420521"></p>
</blockquote>
<blockquote>
<p>get请求，上述方式只有在post方式请求才起作用，而对于get请求，最简单的方法是修改tomcat服务器的Connector的属性，加上编码类型：</p>
<p><img src="/../../images/image-20230419115620669.png" alt="image-20230419115620669"></p>
</blockquote>
<h2 id="2、简单说说SpringMVC的工作流程"><a href="#2、简单说说SpringMVC的工作流程" class="headerlink" title="2、简单说说SpringMVC的工作流程"></a><strong><font color=red>2、简单说说SpringMVC的工作流程</font></strong></h2><p>我们知道在Controller层中只要没用@ResponseBody注解，无论我们是返回一个String还是ModelAndView，SpringMVC都会帮我们解析成ModeAndView对象，然后里面添加的数据都会放到Request域中，被jsp获取。里面的流程是怎么样的。</p>
<p>1、首先我们会在web.xml配置一个DisPatchServlet，作为中央控制器，一般会配置所有请求都需要过DisPatchServlet，DisPatchServlet需要绑定一个mvc的配置文件，mvc配置文件包括注入的controller、视图解析器等内容。</p>
<p><img src="/../../images/image-20230419142837588.png" alt="image-20230419142837588"></p>
<p>所以在请求到来的时候都会先经过DisPatchServlet，然后DisPatchServlet会根据配置文件中配置的HandlerMapping的匹配方式去寻找符合条件的 注册为bean的controller。找到后向DisPatchServlet返回对应的全类名。</p>
<p><img src="/../../images/image-20230419143449394.png" alt="image-20230419143449394"></p>
<p>DisPatchServlet收到全类名之后，会交给适配器处理，适配器进入到全类名对应的类中执行里面的方法，结束后会返回给适配器，适配器收到的要么是一个ModelAndView对象，要么时携带数据的map以及请求跳转页面的路径。</p>
<p>适配器再返回给DisPatchServlet，DishPatchServlet将携带的ModeAndView对象，解析其中的内容，如封装的试图名字，并完成配置好的试图解析器的前后缀完成拼接。并且找到相应的视图完成渲染返回给用户。</p>
<p><img src="/../../images/image-20230419143858619.png" alt="image-20230419143858619"></p>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1、谈谈对volatile的理解"><a href="#1、谈谈对volatile的理解" class="headerlink" title="1、谈谈对volatile的理解"></a><strong><font color=red>1、谈谈对volatile的理解</font></strong></h2><blockquote>
<p>volatile 是JVM提供的轻量级的同步机制，是一个Java的关键字，它可以保证可见性和防止指令重排，但是不能够保证原子性。</p>
<p>一般聊到volatile还会扯到 JMM java内存模型，它是一个抽象的概念并不真实存在，类似于一种规范，它决定了Java程序在多线程环境下，如何访问内存并保证程序的正确性。</p>
<p>JMM 定义了一套规则，用于控制多线程程序访问共享内存时的可见性、有序性和原子性，这些规则主要包括以下几个方面：</p>
<ol>
<li>可见性：一个线程对共享变量的修改对其他线程必须立即可见。</li>
<li>有序性：程序执行的顺序必须与代码的顺序一致，即一个线程内按照代码的顺序执行，而且不会被重排序。</li>
<li>原子性：对于某些操作，例如读取、写入引用型变量或者读取、写入64位的long和double型变量，必须保证是原子操作。</li>
</ol>
<ul>
<li>我们知道Java的工作单位是线程，每个线程都有自己的工作内存，线程对内存数据的修改并不是直接修改主内存的，而是拷贝到自己的空间后修改完成之后写回主内存。既然这样对于同一个资源如果多个线程同时需要操作，线程的修改后写回主内存，对别的线程是不可见的。那么这样的话就可能会导致前面所有线程的修改都丢失，只有最后一个线程修改的值，所以我们需要一种机制保证，各线程对于资源的可见性。</li>
</ul>
<p>加锁和volatile都能够保证JMM的可见性，volatile可以通知其他线程数据发生的改变。</p>
<ul>
<li>原子性最经典的案例就是++操作，永远无法到达准备的值，即时加了volatile也不行。但是为什么volatile不能够保证原子性？</li>
</ul>
<p>可以做不是特别准确的理解： </p>
<p>首先我们知道 ++ 操作被分为了三个指令在底层，取值、+1、回写，因为没有加 sync，所以同一个资源可以被多个线程获得，那么可能出现多个 线程都只差最后一步回写就完成 ++操作了，当有一个线程在写入时，其他线程没有获得cpu被挂起了，只要一写完释放cpu，其他线程就会抢占cpu，并且只差一步就能够完成，一抢占马上就会写如数据，导致前一个线程的数据丢失。</p>
<p>解决：最简单的就是加sync，但是这样有点慢，还有就是我们之前也有了解过的Atomic类，里面有AtomicInteger，保证原子性的整型。</p>
<ul>
<li>指令重排：底层汇编代码可能不会按照顺序取执行相应的代码，而是会根据执行效率的最优来执行代码，因此可能会出现将互不依赖的几条指令的顺序交换，但是顺序交换后可能会导致执行的最终结果的不一致。这也是需要防止的。</li>
</ul>
</blockquote>
<h2 id="2、CAS？原理？"><a href="#2、CAS？原理？" class="headerlink" title="2、CAS？原理？"></a><strong><font color=red>2、CAS？原理？</font></strong></h2><blockquote>
<p>CAS：Compare And Swap，比较并交换。 通过比较线程自己手上的值和内存中的值是否相等，相等才会执行set修改值，否则修改失败。在Atomic 原子类中大量使用。</p>
<p>Atomic中为什么不用sync要用CAS？CAS原理是什么？</p>
<p>拿AtomicInteger举例，我们知道高并发下 ++ 操作要用AtomicInteger中的getAndIncrement()或者incrementAndGet()方法代替，并且可以不需要加 sync，为什么？</p>
<ul>
<li>AtomicInteger</li>
</ul>
<p><img src="/../../images/image-20230420162751420.png" alt="image-20230420162751420"></p>
<ul>
<li>getAndIncrement方法，这里调用CAS方法 Unsafe类中会帮我们保证原子性</li>
</ul>
<p><img src="/../../images/image-20230420163129856.png" alt="image-20230420163129856"></p>
<p> 可以看到CAS的原理就是通过自旋的方式一直拿当前值和内存值进行比较，相同就改变值。</p>
<p>用自旋代替sync通常情况下效率会较高，sync会保证只有一个线程进入并发性比CAS低</p>
<ul>
<li>CAS缺点<ul>
<li>高并发下可以出现一直循环的情况，导致CPU开销大</li>
<li>只能保证一个变量的原子操作</li>
<li>出现ABA问题。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3、ABA问题？原子引用？"><a href="#3、ABA问题？原子引用？" class="headerlink" title="3、ABA问题？原子引用？"></a><strong><font color=red>3、ABA问题？原子引用？</font></strong></h2><blockquote>
<p>ABA问题是 使用CAS而导致的一个问题，导致ABA的主要原因是CAS操作只看开头和结尾的值是否相等，也就是只要一个线程能在别的线程执行CAS操作前，将数据改回原数据，其他线程的CAS操作都能够成功，但是在其他操作执行CAS之前，那个线程可以将原数据修改成任何的值。</p>
<p>例子：</p>
<p>线程A、B，同时获取内存中的值为5，A线程修改内存中的值5—&gt;10—–&gt;20……—&gt;5，B线程准备来执行CAS时发现和自己本地内存中的值是一样的所以就执行了修改，期间的A线程在主内存的所有修改B都是不知道的。</p>
<p>ABA可能会导致，程序数据不一致，因为可能之前被修改的值，被其他数据引用而执行后续的操作。 </p>
<ul>
<li>解决方式：</li>
</ul>
<p>可以通过设定版本号，每次修改都对版本号加1，CAS时还需要比较版本号。JUC为我们提供了一种带时间戳的原子引用，原子引用也是一个原子类操作和上面的原子整形差不多，只是可以指定泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是普通的原子引用，和AtomicInteger一样的</span></span><br><span class="line">AtomicReference&lt;Integer&gt; integerAtomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(integerAtomicReference.compareAndSet(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">    System.out.println(integerAtomicReference.compareAndSet(<span class="number">200</span>, <span class="number">100</span>)+<span class="string">&quot;结果：&quot;</span>+integerAtomicReference.get());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//保证ABA问题出现</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(integerAtomicReference.compareAndSet(<span class="number">100</span>, <span class="number">3000</span>)+<span class="string">&quot;结果：&quot;</span>+integerAtomicReference.get());</span><br><span class="line"></span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//带版本号的原子引用</span></span><br><span class="line">AtomicStampedReference&lt;String&gt; stringAtomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;100&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//获取内存中的版本号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stringAtomicStampedReference.getStamp();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取版本号：&quot;</span>+stamp);</span><br><span class="line">    <span class="comment">//保证两个线程一开始拿到的版本号是相同的</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//先完成ABA</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除了对比值还要对比版本号，修改也要修改版本号</span></span><br><span class="line">    stringAtomicStampedReference.compareAndSet(<span class="string">&quot;100&quot;</span>,<span class="string">&quot;200&quot;</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">    stringAtomicStampedReference.compareAndSet(<span class="string">&quot;200&quot;</span>,<span class="string">&quot;100&quot;</span>,stamp+<span class="number">1</span>,stamp+<span class="number">2</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//获取内存中的版本号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stringAtomicStampedReference.getStamp();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取版本号：&quot;</span>+stamp);</span><br><span class="line">    <span class="comment">//保证两个线程一开始拿到的版本号是相同的</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除了对比值还要对比版本号，修改也要修改版本号</span></span><br><span class="line">    System.out.println(stringAtomicStampedReference.compareAndSet(<span class="string">&quot;100&quot;</span>,</span><br><span class="line">                                                                    <span class="string">&quot;300&quot;</span>,</span><br><span class="line">                                                                    stamp,</span><br><span class="line">                                                                    stamp + <span class="number">1</span>)+<span class="string">&quot;结果：&quot;</span>+</span><br><span class="line">                                                                    stringAtomicStampedReference.getReference()+</span><br><span class="line">                                                                 <span class="string">&quot;版本号：&quot;</span>+stringAtomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p> <img src="/../../images/image-20230420174113975.png" alt="image-20230420174113975"></p>
</blockquote>
<h2 id="4、公平锁和非公平锁"><a href="#4、公平锁和非公平锁" class="headerlink" title="4、公平锁和非公平锁"></a><strong><font color=red>4、公平锁和非公平锁</font></strong></h2><blockquote>
<p>公平锁：多个线程按照先来后到的原则占用锁</p>
<p>非公平锁：和上面相反，运行有线程插队。</p>
<p> 什么时候使用过？</p>
<p>在创建ReentryLock的时候用过，默认是非公平的，可以通过传递fair属性设置为公平锁。</p>
<p>Sync也是一个非公平锁</p>
</blockquote>
<h2 id="5、手写一个自旋锁"><a href="#5、手写一个自旋锁" class="headerlink" title="5、手写一个自旋锁"></a><strong><font color=red>5、手写一个自旋锁</font></strong></h2><blockquote>
<p>自旋锁特点：不阻塞，循环尝试获得锁。也就是 while(trylock())，或者通过while(CAS操作)</p>
<ul>
<li>trylock</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        method();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        method();</span><br><span class="line">        System.out.println(<span class="string">&quot;lllllll&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!lock.tryLock())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;尝试获取锁失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;获取锁成功，当前线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CAS</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>();</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        mylock();</span><br><span class="line">        System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        myunlock();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        mylock();</span><br><span class="line">        System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">        myunlock();</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mylock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>,thread))&#123;</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;修改失败，自旋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(thread.getName()+<span class="string">&quot;修改成功，执行方法.....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myunlock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">while</span> (!atomicReference.compareAndSet(thread,<span class="literal">null</span>))&#123;</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;修改失败，自旋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(thread.getName()+<span class="string">&quot;修改成功，结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="6、读写锁？有什么要求？"><a href="#6、读写锁？有什么要求？" class="headerlink" title="6、读写锁？有什么要求？"></a><strong><font color=red>6、读写锁？有什么要求？</font></strong></h2><blockquote>
<p>普通的锁都是只允许有一个线程进入同步代码块的，这种方式能够完全保证数据一致性，但是并发性太低。并且实际业务中，我们肯定不希望读数据的时候也只有一个线程进入，所以 我们希望能够实现同步代码块对读不互斥，只对写互斥。</p>
<p> 写锁：只允许一个线程进行写， 并且要保证写的原子性</p>
<p>读锁：允许多个线程参与读</p>
<p> 实现：ReentrantReadWriteLock</p>
</blockquote>
<h2 id="7、下列哪些操作会使线程释放锁资源？"><a href="#7、下列哪些操作会使线程释放锁资源？" class="headerlink" title="7、下列哪些操作会使线程释放锁资源？"></a><strong><font color=red>7、下列哪些操作会使线程释放锁资源？</font></strong></h2><ul>
<li><p>A   sleep()</p>
</li>
<li><p>B   wait()</p>
</li>
<li><p>C   join()</p>
</li>
<li><p>D   yield()</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>sleep()：让调用的线程暂停执行，不会释放锁，但是会释放cpu，sleep时间到了之后重新等到cpu调度，因为不释放锁，所以不推荐使用。</p>
</li>
<li><p>wait()：在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。</p>
</li>
</ul>
</blockquote>
<h2 id="8、Java中实现线程的方式"><a href="#8、Java中实现线程的方式" class="headerlink" title="8、Java中实现线程的方式"></a><strong><font color=red>8、Java中实现线程的方式</font></strong></h2><blockquote>
<ul>
<li>Class A继承Thread类、重写run方法、new A().start()</li>
<li>Class A 实现Runnable接口、重写run方法、new Tread(new A()).start()</li>
</ul>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1、手写一个LRU算法"><a href="#1、手写一个LRU算法" class="headerlink" title="1、手写一个LRU算法"></a><strong><font color=red>1、手写一个LRU算法</font></strong></h2><blockquote>
<ul>
<li>LinkedHashMap投机实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Demo3</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">       <span class="comment">//true按照访问顺序排序，false表示按照插入顺序，只要访问过元素就会被当作最近被使用过</span></span><br><span class="line">       <span class="built_in">super</span>(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">       <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.size()&gt;capacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       Demo3&lt;Integer, Integer&gt; lrucache = <span class="keyword">new</span> <span class="title class_">Demo3</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">       lrucache.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">       lrucache.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">       lrucache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">       System.out.println(lrucache.toString());    <span class="comment">//&#123;1=1, 2=2, 3=3&#125;</span></span><br><span class="line"></span><br><span class="line">       lrucache.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">       System.out.println(lrucache.toString());    <span class="comment">//&#123;2=2, 3=3, 4=4 &#125;</span></span><br><span class="line"></span><br><span class="line">       lrucache.get(<span class="number">2</span>);       <span class="comment">//&#123;3=3, 4=4，2=2&#125;</span></span><br><span class="line">       lrucache.put(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">       System.out.println(lrucache.toString());    <span class="comment">//&#123;4=4, 2=2, 5=5&#125;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="2、Spring解决循环依赖源码"><a href="#2、Spring解决循环依赖源码" class="headerlink" title="2、Spring解决循环依赖源码"></a><strong><font color=red>2、Spring解决循环依赖源码</font></strong></h2><ul>
<li>配置好bean</li>
</ul>
<p><img src="/../../images/image-20230422212122554.png" alt="image-20230422212122554"></p>
<ul>
<li>单例创建，正常</li>
</ul>
<p><img src="/../../images/image-20230422212605600.png" alt="image-20230422212605600"></p>
<p>根据控制台打印出  创建成功的语句的时机一点点进到方法里面。</p>
<p>首先是一个refresh()方法，这个方法在整个Spring中就是初始化配置文件中的各种配置的方法。</p>
<p>再往后preInstantiateSingletons()方法中会有一个对所有Bean的遍历创建，包括Spring自己的还有我们配置的</p>
<p><img src="/../../images/image-20230423142031503.png" alt="image-20230423142031503"></p>
<p>直接定位到自定义的 bean  a，调用getbean方法：</p>
<p><img src="/../../images/image-20230423142207116.png" alt="image-20230423142207116"></p>
<p>进到doGetBean之后，就会看到之前我们说的几个重要的方法：</p>
<p>getSingleton&#x3D;&#x3D;&gt;doCreateBean&#x3D; &#x3D;&gt;popularBean &#x3D; &#x3D;&gt;addSingletone</p>
<ul>
<li>getSingleton</li>
</ul>
<p><img src="/../../images/image-20230423142743869.png" alt="image-20230423142743869"></p>
<p>这里a都还没被初始化，在if判断时就会被第二个条件判断为false，不会去查二、三级缓存。什么都还没创建，所以会先去对a进行动手</p>
<ul>
<li>准备开始创建a，先把a标记位已创建</li>
</ul>
<p><img src="/../../images/image-20230423143431577.png" alt="image-20230423143431577"></p>
<p>会把a先放到一个用于标记已创建的bean的map中</p>
<p><img src="/../../images/image-20230423143538095.png" alt="image-20230423143538095"></p>
<ul>
<li>再次调用getSingleton方法</li>
</ul>
<p><img src="/../../images/image-20230423143905196.png" alt="image-20230423143905196"></p>
<p>回调，接口的匿名实现类的实现方法调用createBean</p>
<p><img src="/../../images/image-20230423144116506.png" alt="image-20230423144116506"></p>
<p>create会调用doCreateBean去创建：</p>
<p><img src="/../../images/image-20230423144324414.png" alt="image-20230423144324414"></p>
<p>doCreateBean实际还会再调用createBeanInstance，这里面就是大量的反射操作：</p>
<ul>
<li>获取字节码对象</li>
</ul>
<p><img src="/../../images/image-20230423144645962.png" alt="image-20230423144645962"></p>
<ul>
<li>根据字节码和beanName获取构造器</li>
</ul>
<p><img src="/../../images/image-20230423144704684.png" alt="image-20230423144704684"></p>
<ul>
<li>源码中也明确说了使用无参构造</li>
</ul>
<p><img src="/../../images/image-20230423144820091.png" alt="image-20230423144820091"></p>
<p>instantiateBean中还会去调用 instantiate，这里面也是用反射去拿构造方法：</p>
<p><img src="/../../images/image-20230423145228437.png" alt="image-20230423145228437"></p>
<ul>
<li>最后用构造器的 newInstance方法创建出对象</li>
</ul>
<p><img src="/../../images/image-20230423145435421.png" alt="image-20230423145435421"></p>
<p>&#x3D;&#x3D;——————————————–上面只是完成了a的实例化，还没有完成属性初始化———————————&#x3D;&#x3D;</p>
<p>下面开始回到doCreateBean方法中，继续往下执行：</p>
<p><img src="/../../images/image-20230423151557015.png" alt="image-20230423151557015"></p>
<ul>
<li>初始化A的属性：</li>
</ul>
<p><img src="/../../images/image-20230423151619110.png" alt="image-20230423151619110"></p>
<p>要一个b这个Bean，但是没有，所以又会去创建，一直往下debug，又会经历过一个getBean的流程：</p>
<p><img src="/../../images/image-20230423152243634.png" alt="image-20230423152243634"></p>
<p>&#x3D;&#x3D;—————————————-上面是同样的实例化b的流程，这里省略，总体和a相同———————————&#x3D;&#x3D;</p>
<p>回到doCreateBean方法，准备初始化完成B的创建：</p>
<p>一直到准备给B的属性赋值，还是一样的进入populateBean这个方法：</p>
<p>里面有一个PropertyValues对象，这里面存的就是判断当前生成的bean的所有的属性，后面调用applyPropertyValues，去将需要的bean注入属性</p>
<p><img src="/../../images/image-20230423201618377.png" alt="image-20230423201618377"></p>
<p>applyPropertyValues方法里面，前面都是各种判断和属性解析，到resolveValueIfNecessary这个方法才是真正的获取这个 beanName对应的 Bean。</p>
<p><img src="/../../images/image-20230423205827018.png" alt="image-20230423205827018"></p>
<p>resolveValueIfNecessary方法中实际调用的是resolveReference方法，这个方法在第一次创建a的时候就应该看到过了，上面没有给出，但是实际上调用的就是getBean方法，然后又是doGetBean，但是和上面的流程有些不同，因为此时a已经被我们放到三级缓存中了：</p>
<ul>
<li>第一次调用getBean&#x3D;&#x3D; &#x3D;&gt;doGetBean&#x3D;&#x3D; &#x3D;&gt;getSingleton</li>
</ul>
<p><img src="/../../images/image-20230423210823450.png" alt="image-20230423210823450"></p>
<ul>
<li>第二次调用getBean&#x3D;&#x3D; &#x3D;&gt;doGetBean&#x3D;&#x3D; &#x3D;&gt;getSingleton，这里if的第二个条件不会被判断为false，因为在前面我们已经完成了a、b的初始化，所以会进入到if里面，通过二级缓存拿a，发现a不在二级缓存，所以会去三级缓存拿，三级缓存我们之前知道已经将a的工厂对象放入三级缓存中了，会调用它的getObject获取a。</li>
</ul>
<p><img src="/../../images/image-20230423211453216.png" alt="image-20230423211453216"></p>
<p>回到resolveValueIfNecessary方法继续往下执行，准备去将a设置到b的属性中，会先把当前的bean所需要的所有bean都会被创建为一个list集合，被依次设置到当前bean中：</p>
<p><img src="/../../images/image-20230423212537707.png" alt="image-20230423212537707"></p>
<ul>
<li>setPropertyValue</li>
</ul>
<p><img src="/../../images/image-20230423212736056.png" alt="image-20230423212736056"></p>
<p>一直到setValue方法：</p>
<p><img src="/../../images/image-20230423213445668.png" alt="image-20230423213445668"></p>
<p>&#x3D;&#x3D;—————–上面完成了b的属性a的初始化过程，但是这里的a实际上是还没有完成初始化的—————-&#x3D;&#x3D;</p>
<p>b结束了初始化，回到创建b时的getSingleton方法，最后将b设置到一级缓存中</p>
<p><img src="/../../images/image-20230423215143999.png" alt="image-20230423215143999"></p>
<p>放入缓存后，b就算完成了，回到创建a时，我们上面提到的applyPropertyValues，当时调用这个方法我们去注入b的时候，因为b没有被创建，所以经过了上面一大串的实例化加初始化b的过程，现在回到这个解析所需要的bean的方法，现在完成了对b的创建，然后要将b注入到a，并且将a放到一级缓存中。</p>
<ul>
<li>b设置a的时候提到的applyPropertyValues方法</li>
</ul>
<p><img src="/../../images/image-20230423215614604.png" alt="image-20230423215614604"></p>
<p>同样回到a一样是通过setPropertyValues方法</p>
<p><img src="/../../images/image-20230423215932396.png" alt="image-20230423215932396"></p>
<p>后续流程也和b几乎一样，通过反射调用set方法，然后将结果放到一级缓存，删除二级缓存</p>
<h2 id="3、forward和redirect的区别"><a href="#3、forward和redirect的区别" class="headerlink" title="3、forward和redirect的区别"></a><strong><font color=red>3、forward和redirect的区别</font></strong></h2><p>两个都是实现页面跳转的。</p>
<blockquote>
<ol>
<li>跳转的方式不同：<code>forward</code> 是服务器内部的重定向，而 <code>redirect</code> 是客户端的是外部重定向。<ul>
<li><code>forward</code>：当服务器收到请求时，它会将请求转发到另一个资源（页面、servlet、JSP 等），但浏览器的地址栏 URL 不会改变。使用 <code>forward</code> 时，浏览器不知道请求发生了重定向，所有的请求和响应都发生在服务器端。</li>
<li><code>redirect</code>：当服务器收到请求时，它会向浏览器发送一个特殊的响应，包含了一个新的 URL，浏览器会按照这个新的 URL 发起一个新的请求。这会导致浏览器地址栏中的 URL 发生变化，通常会显示新的 URL。使用 <code>redirect</code> 时，浏览器知道请求已经重定向到另一个位置。</li>
</ul>
</li>
<li>redirect默认将产生302 Permanently moved的HTTP响应。forward没有</li>
</ol>
</blockquote>
<h2 id="4、服务器端和客户端创建socket对象"><a href="#4、服务器端和客户端创建socket对象" class="headerlink" title="4、服务器端和客户端创建socket对象"></a><strong><font color=red>4、服务器端和客户端创建socket对象</font></strong></h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端通过new Socket()方法创建通信的Socket对象</span><br><span class="line">服务器端通过new ServerSocket()创建TCP连接对象  accept接纳客户端请求,accept接收到了客户端的请求后才成为socket对象</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url"><a href="#5、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url" class="headerlink" title="5、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?"></a><strong><font color=red>5、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?</font></strong></h2><blockquote>
<p>直接读取文件a，50X64B &#x3D; 320亿B≈320G远大于4G。</p>
<p>所以需要采用分治的做法，我们将50亿url分配到多个小文件里，这里的分块可以用hash 取余来让hash值相同的文件尽可能在同一个小文件块里面。 </p>
<p>假设分1000块，对于文件a，一点点读取文件a的url并且，取hash值再取余得到的就是对应的小文件快，这样就可以将a文件映射到 a0—–a999 这样1000个文件中。</p>
<p>对于b也是一样的，这样做的好处就在于，相同的url大概率都会出现在同一个对应的文件块中。</p>
<p>最后就将对应的小文件块的url，取hash，对比相同的hash的url。</p>
</blockquote>
<h2 id="6、RPC，有了Http-为什么要RPC"><a href="#6、RPC，有了Http-为什么要RPC" class="headerlink" title="6、RPC，有了Http 为什么要RPC"></a><strong><font color=red>6、RPC，有了Http 为什么要RPC</font></strong></h2><blockquote>
<p>1、RPC: 远程过程调用，可以让部署再不同服务器上的应用相互之间的调用可以像调用本地方法一样。因为不在同一个内存空间所以不能直接调用，需要借助网络调用。</p>
<p>2、RPC是一个完整的调用方案，它包括通信协议和序列化协议。</p>
<p>http只是通信协议的一种，RPC可以使用http来作为它的通信协议，也可以选择别的协议，还可以使用自定义的通信协议。</p>
<p>序列化协议，常用的序列化为JSON格式、XML格式等。</p>
<p>所以http只是一个通信协议，而RPC可以选择使用这种通信协议加上一个序列化协议来构成一个完整的远程过程调用方案，也可以不选择http，比如在性能要求比较高的系统之间就会选择使用自定义的tcp协议来做RPC的通信协议。因为传统的http协议请求头包含了较多冗余字段，使用自定义的tcp协议可以更加专精的做数据传输，并且再高并发的情况下，减少一些冗余的请求头可以减少传输成本。</p>
</blockquote>
<h2 id="7、解决hash冲突"><a href="#7、解决hash冲突" class="headerlink" title="7、解决hash冲突"></a><strong><font color=red>7、解决hash冲突</font></strong></h2><p>解决hash冲突的方式主要包括两种：</p>
<p>开放地址法：核心思想就是，发生冲突后，根据某些方法将这个冲突的元素转移至不发生冲突的位置。</p>
<ul>
<li>线性探测：依次寻找下一个槽位</li>
<li>二次探测：根据特定的二次探测规则，如：1、4、9、16…依次向下寻找槽位</li>
<li>随机探测：随机选择一个探测槽位</li>
<li>再哈希：对hash值再使用一个hash算法得到新的hash值</li>
</ul>
<p>链地址法： 就是对于hash值相同的元素，通过链表来解决、或者树形结构。如  HashMap，HashSet是调用HashMap的自然HashSet也是链地址法。</p>
<h2 id="8、会话跟踪"><a href="#8、会话跟踪" class="headerlink" title="8、会话跟踪"></a><strong><font color=red>8、会话跟踪</font></strong></h2><p>在Web开发中，HTTP是一种无状态协议，这意味着每个请求都是独立的，服务器无法自动识别来自同一用户的连续请求。</p>
<p>会话跟踪（Session Tracking）就是是指在一个Web应用程序中追踪和管理一个用户在不同请求之间的交互状态。</p>
<p>常见有以下几种实现方式：</p>
<ol>
<li>Cookie：使用Cookie是最常见的会话跟踪机制。服务器在客户端的浏览器上设置一个唯一的标识符（cookie）作为会话ID，并将会话数据与该ID关联。浏览器在每个请求中向服务器发送会话ID，服务器使用该ID来检索或更新会话数据。所以Cookie是放在客户端的，可以分为内存cookie和磁盘cookie。内存cookie在浏览器关闭后消失，磁盘cookie超时后消失。</li>
<li>URL重写：在URL中嵌入会话ID，将其作为请求参数传递给服务器。服务器使用会话ID来识别会话并管理会话数据。这种方法适用于禁用Cookie的情况下。比如说用户登录完成后返回一个唯一的id，每次请求都会携带这个id，标识用户身份。</li>
<li>隐藏表单字段：在HTML表单中嵌入会话ID，将其作为隐藏字段发送到服务器。服务器使用该ID来识别会话并处理表单数据。</li>
<li>HTTPSession：在服务器端使用语言或框架提供的会话管理机制。服务器为每个用户创建一个唯一的会话对象，并为其分配一个会话ID。会话对象用于存储和管理会话数据。Session是服务器端来维护的</li>
</ol>
<h2 id="9、Socket"><a href="#9、Socket" class="headerlink" title="9、Socket"></a><strong><font color=red>9、Socket</font></strong></h2><p>服务端创建socket对象的方式： new SocketServer(port) ，因为是等待别人连接的，所以肯定是在本地开启，不需要，传ip地址。</p>
<p>客户端创建socket对象：new Socket(ip,port)，因为要指明向哪个ip发送数据，所以要传递，ip。</p>
<p>交互过程：<br><img src="/../../images/image-20230803145425529.png" alt="image-20230803145425529"></p>
<h2 id="10、大量数据传输的一致性如何保证"><a href="#10、大量数据传输的一致性如何保证" class="headerlink" title="10、大量数据传输的一致性如何保证"></a>10、大量数据传输的一致性如何保证</h2><p>如果只要传输一个数据，那么其实只要保证接收方接收到了数据就可以。也就是接收方向发送方，发送一个确认就好了。</p>
<p>那大量的数据传输，和一次的区别也就在于，传输的次数变多的，时间边长了，只要时间变长就要考虑到这个时间内的不稳定因素：</p>
<ul>
<li>发送方不稳定、接收方不稳定</li>
<li>网络不稳定</li>
<li>硬件不稳定</li>
</ul>
<p>第一个，其实就是要有一个东西能够存储，且有确认机制，那很显然，直接用异步MQ，发送方将消息发给MQ，接收方从MQ中取数据，并且开启消息持久化机制，保证消息不会丢失。</p>
<p>第二个，其实就是分批量的传输，确保小批次的一致，再使得整体的一致。</p>
<p>第三个，也就是中断后怎么恢复，都分批了实现断点续传也不是很难，只不过要保证幂等性和数据不重复，实现数据不重复只要做好数据库的唯一索引就好了。</p>
<p>可能还要考虑的有：</p>
<p>记录每个批次的状态位，以便重试。</p>
<p>还要考虑监控告警系统，方便查看传输过程中数据、服务器的状态。</p>
<p>如果同步过程中，旧数据还会发生修改，那还需要在本地记录旧数据的增量变化，后续再将增量变化再同步一次。</p>
<p>最终一致性的检查。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io">异梦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io/2022/08/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/">https://yimeng436.github.io/2022/08/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yimeng436.github.io" target="_blank">异梦的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/top.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络面试题</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/20/MybatisPlus/MybatisPlus/"><img class="next-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MybatisPlus</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/04/%E5%A4%9A%E6%80%81%E4%BE%8B%E9%A2%98/%E5%A4%9A%E6%80%81%E4%BE%8B%E9%A2%98/" title="多态例题"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-04</div><div class="title">多态例题</div></div></a></div><div><a href="/2022/06/06/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/" title="自动拆装箱"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-06</div><div class="title">自动拆装箱</div></div></a></div><div><a href="/2022/06/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-15</div><div class="title">多线程</div></div></a></div><div><a href="/2022/06/30/JavaWeb/JavaWeb/" title="JavaWeb"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-30</div><div class="title">JavaWeb</div></div></a></div><div><a href="/2022/07/25/Mybatis/Mybatis/" title="Mybatis"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-25</div><div class="title">Mybatis</div></div></a></div><div><a href="/2022/07/26/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/" title="注解和反射"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-26</div><div class="title">注解和反射</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">异梦</div><div class="author-info__description">欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yimeng436" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2441844062@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Java基础题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81abstract-%E3%80%81final%E8%83%BD%E5%90%A6%E5%90%8C%E6%97%B6%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E7%B1%BB-x2F-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1、abstract 、final能否同时修饰一个类 &#x2F;方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.</span> <span class="toc-text">2、接口和抽象类对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">3、作用域对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%9B%B8%E7%AD%89%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.</span> <span class="toc-text">4、相等的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81try-catch-finally%EF%BC%8Creturn%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">5、try-catch-finally，return覆盖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">6、序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81String-%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.</span> <span class="toc-text">7、String 创建几个对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">1.8.</span> <span class="toc-text">8、基本数据类型占用的内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Switch%E6%94%AF%E6%8C%81%E9%82%A3%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">9、Switch支持那些数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">10、枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.11.</span> <span class="toc-text">11、成员变量和局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81this-%E3%80%81super"><span class="toc-number">1.12.</span> <span class="toc-text">12、this()、super()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.13.</span> <span class="toc-text">13、类和接口继承和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.14.</span> <span class="toc-text">14、泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.15.</span> <span class="toc-text">15、内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Java程序题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%8B%E9%9D%A2%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%88%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1、下面程序运行结果（类初始化的过程，实例初始化的过程，方法重写）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E3%80%81%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2、下面代码运行结果是什么（参数传递、特殊类型不可变性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.3.</span> <span class="toc-text">3、下面代码运行结果是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%BD%A2%E5%BC%8F%EF%BC%8C%E2%80%9D-x3D-x3D-%E2%80%9D%E5%92%8Cequals%E6%AF%94%E8%BE%83-%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4、下面代码运行结果是什么（自动拆装箱，参数传递形式，”&#x3D;&#x3D;”和equals比较  ）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%8C%E5%A4%9A%E6%80%81%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">5、下面代码运行结果是什么（类加载顺序，多态）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E7%BB%A7%E6%89%BF%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">6、下面代码运行结果是什么（构造函数、继承）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E9%9B%86%E5%90%88%E3%80%81%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">7、下面代码运行结果是什么（集合、自动拆装箱）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88final-%E7%BB%A7%E6%89%BF-%E4%BF%AE%E9%A5%B0%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">8、下面代码运行结果是什么（final 继承 修饰限定符）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">9、下面代码运行结果是什么（三元运算符）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">10、下面代码运行结果是什么（二元运算符的基础类型数据转换）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">11、下面代码运行结果是什么（运算优先级，字符串运算）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81ArrayList%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">3.1.</span> <span class="toc-text">1、ArrayList线程安全吗？举个例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">4.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Mysql%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.</span> <span class="toc-text">1、Mysql什么时候应该建立索引，什么时候不应该建立索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mybatis"><span class="toc-number">5.</span> <span class="toc-text">Mybatis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">6.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BSpring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%95%8C%E5%88%AB"><span class="toc-number">6.1.</span> <span class="toc-text">1、简单描述一下Spring中的事务传播行为，以及事务的隔离界别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81AOP%E9%80%9A%E7%9F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">2、AOP通知的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3、Spring循环依赖？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4、单例模式如何解决循环依赖的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C-Autowired-%E5%92%8C-Resource-%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.</span> <span class="toc-text">5、依赖注入的方式，@Autowired 和 @Resource 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81IOC"><span class="toc-number">6.6.</span> <span class="toc-text">6、IOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81AOP"><span class="toc-number">6.7.</span> <span class="toc-text">7、AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">6.8.</span> <span class="toc-text">8、事务失效场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC"><span class="toc-number">7.</span> <span class="toc-text">SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">1、请求中文乱码问题如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4SpringMVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">2、简单说说SpringMVC的工作流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot"><span class="toc-number">8.</span> <span class="toc-text">SpringBoot</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">9.</span> <span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">10.</span> <span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC"><span class="toc-number">11.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88%E5%AF%B9volatile%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">11.1.</span> <span class="toc-text">1、谈谈对volatile的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CAS%EF%BC%9F%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">2、CAS？原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ABA%E9%97%AE%E9%A2%98%EF%BC%9F%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">3、ABA问题？原子引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">11.4.</span> <span class="toc-text">4、公平锁和非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">11.5.</span> <span class="toc-text">5、手写一个自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="toc-number">11.6.</span> <span class="toc-text">6、读写锁？有什么要求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%B8%8B%E5%88%97%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BD%BF%E7%BA%BF%E7%A8%8B%E9%87%8A%E6%94%BE%E9%94%81%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">11.7.</span> <span class="toc-text">7、下列哪些操作会使线程释放锁资源？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">11.8.</span> <span class="toc-text">8、Java中实现线程的方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">12.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AALRU%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">1、手写一个LRU算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%BA%90%E7%A0%81"><span class="toc-number">12.2.</span> <span class="toc-text">2、Spring解决循环依赖源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81forward%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.3.</span> <span class="toc-text">3、forward和redirect的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9B%E5%BB%BAsocket%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.4.</span> <span class="toc-text">4、服务器端和客户端创建socket对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%BB%99%E5%AE%9Aa%E3%80%81b%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%84%E5%AD%98%E6%94%BE50%E4%BA%BF%E4%B8%AAurl%EF%BC%8C%E6%AF%8F%E4%B8%AAurl%E5%90%84%E5%8D%A064%E5%AD%97%E8%8A%82%EF%BC%8C%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%E6%98%AF4G%EF%BC%8C%E8%AE%A9%E4%BD%A0%E6%89%BE%E5%87%BAa%E3%80%81b%E6%96%87%E4%BB%B6%E5%85%B1%E5%90%8C%E7%9A%84url"><span class="toc-number">12.5.</span> <span class="toc-text">5、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81RPC%EF%BC%8C%E6%9C%89%E4%BA%86Http-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81RPC"><span class="toc-number">12.6.</span> <span class="toc-text">6、RPC，有了Http 为什么要RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81"><span class="toc-number">12.7.</span> <span class="toc-text">7、解决hash冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA"><span class="toc-number">12.8.</span> <span class="toc-text">8、会话跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Socket"><span class="toc-number">12.9.</span> <span class="toc-text">9、Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-number">12.10.</span> <span class="toc-text">10、大量数据传输的一致性如何保证</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="MySQL原理"/></a><div class="content"><a class="title" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理">MySQL原理</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="算法笔记"/></a><div class="content"><a class="title" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记">算法笔记</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="前端知识"/></a><div class="content"><a class="title" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识">前端知识</a><time datetime="2023-06-05T16:00:00.000Z" title="发表于 2023-06-06 00:00:00">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="FSAF论文"/></a><div class="content"><a class="title" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文">FSAF论文</a><time datetime="2022-10-13T16:00:00.000Z" title="发表于 2022-10-14 00:00:00">2022-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="Faster-RCNN论文"/></a><div class="content"><a class="title" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文">Faster-RCNN论文</a><time datetime="2022-08-24T16:00:00.000Z" title="发表于 2022-08-25 00:00:00">2022-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 异梦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>