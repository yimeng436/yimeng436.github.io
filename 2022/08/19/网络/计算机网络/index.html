<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机网络 | 异梦的博客</title><meta name="keywords" content="计算机基础"><meta name="author" content="异梦"><meta name="copyright" content="异梦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://yimeng436.github.io/2022/08/19/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="异梦的博客">
<meta property="og:description" content="计算机网络">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yimeng436.github.io/img/top.png">
<meta property="article:published_time" content="2022-08-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-08T07:23:40.740Z">
<meta property="article:author" content="异梦">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yimeng436.github.io/img/top.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yimeng436.github.io/2022/08/19/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-08 15:23:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">异梦的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-18T16:00:00.000Z" title="发表于 2022-08-19 00:00:00">2022-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-08T07:23:40.740Z" title="更新于 2024-02-08 15:23:40">2024-02-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p>最原始的<strong>OSI</strong>七层结构：物（物理层）、链（链路层）、网（网络层）、 输（传输层）、 会（会话层） 示（展示层） 用（应用） 层。</p>
<p>但是上面这个分层结构，是学术上的分层模式，没有考虑到实际应用，所以并没有流行起来。</p>
<p>所以现在普遍使用的是 <strong>TCP&#x2F;IP</strong>体系结构。</p>
<p>TCP&#x2F;IP只包括：网络层接口、网际层（核心IP协议）、运输层（核心TPC、UDP协议）、应用层。</p>
<p>但是从学习原理的角度触发，只学习TPC&#x2F;IP的体系结构会缺少一部分知识，所以原理的体系结构又包括：物理层  数据链路层、网络层、传输层、应用层。</p>
<h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><p>计算机网络是一个非常复杂的体系，如果要一起考虑的话需要考虑的问题太多，比如信号要如何传输（网络层）、一个网络上传输的问题（数据链路层）、多个网络上传输的问题（网络层）、进程之间基于网络的通信的问题（传输层）、应用进程之间交互来实现网络应用的问题（应用层）。</p>
<p>而分层的劣势，可能就在于过分模块化、使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑等问题。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP协议相关内容"><a href="#HTTP协议相关内容" class="headerlink" title="HTTP协议相关内容"></a>HTTP协议相关内容</h2><p>HTTP协议本身是无状态的，他不会对请求或者响应进行持久化，有一个请求就会处理一个请求，这是为了更快的处理大量的请求。所以在实现登录的时候需要配合Cookie技术进行状态管理。</p>
<p>HTTP在一开始的时候是不支持持久连接的，也就是说一次请求多个资源的时候，会出现多次TPC建立和断开，这就增加了很大的通信开销。在HTTP 1.1之后 持久的连接就是默认支持的了，只要任意一端没有明确提出断开连接，就会保持TCP的连接状态。</p>
<p><strong>HTTP 1.0默认（短链接）</strong>：<br><img src="/../../images/image-20240128150342449.png" alt="image-20240128150342449"></p>
<p><strong>HTTP1.1默认（长连接或持久连接）</strong>：<br><img src="/../../images/image-20240128150433273.png" alt="image-20240128150433273"></p>
<p>长连接的实现也非常容易，就是通过一个字段keep alive实现。不管客户端是否显式要求长连接，如果服务器支持长连接，它总会在响应报文里放一个“<strong>Connection: keep-alive</strong>”字段</p>
<p><img src="/../../images/image-20240128170041419.png" alt="image-20240128170041419"></p>
<p>如果TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</p>
<p>所以，长连接也需要在恰当的时间关闭，不能永远保持与服务器的连接，这在客户端或者服务器都可以做到。</p>
<p>在客户端，可以在请求头里加上“<strong>Connection: close</strong>”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。</p>
<p>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<ol>
<li>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</li>
<li>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</li>
</ol>
<h2 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a>队头阻塞</h2><p>“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。</p>
<p>因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。</p>
<p>举个例子：上班的时间点上，大家都在排队打卡，可这个时候偏偏最前面的那个人遇到了打卡机故障，怎么也不能打卡成功，急得满头大汗。等找人把打卡机修好，后面排队的所有人全迟到了。</p>
<p>如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。</p>
<p>因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP&#x2F;1.1 里无法解决，只能缓解，有什么办法呢？</p>
<blockquote>
<p>还是打卡的例子：公司里可以再多买几台打卡机放在前台，这样大家可以不用挤在一个队伍里，分散打卡，一个队伍偶尔阻塞也不要紧，可以改换到其他不阻塞的队伍。</p>
<p>这在 HTTP 里就是“<strong>并发连接</strong>”（concurrent connections），也就是同时对一个域名发起多个长连接，用数量来解决质量的问题。</p>
<p>但这种方式也存在缺陷。如果每个客户端都想自己快，建立很多个连接，用户数×并发数就会是个天文数字。服务器的资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”。</p>
<p>公司发展的太快了，员工越来越多，上下班打卡成了迫在眉睫的大问题。前台空间有限，放不下更多的打卡机了，怎么办？那就多开几个打卡的地方，每个楼层、办公区的入口也放上三四台打卡机，把人进一步分流，不要都往前台挤。</p>
<p>这个就是“<strong>域名分片</strong>”（domain sharding）技术，还是用数量来解决质量的思路。</p>
<p>HTTP 协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如 shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器 <a target="_blank" rel="noopener" href="http://www.chrono.com,这样实际长连接的数量就又上去了,真是“美滋滋”.不过实在是有点“上有政策,下有对策”的味道./">www.chrono.com，这样实际长连接的数量就又上去了，真是“美滋滋”。不过实在是有点“上有政策，下有对策”的味道。</a></p>
</blockquote>
<h2 id="连接状态管理"><a href="#连接状态管理" class="headerlink" title="连接状态管理"></a>连接状态管理</h2><p>保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</p>
<p>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知<strong>客户端保存Cookie</strong>。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<p><img src="/../../images/image-20240128150850666.png" alt="image-20240128150850666"></p>
<p><img src="/../../images/image-20240128150856238.png" alt="image-20240128150856238"></p>
<p>但是浏览器中是可以看到设置的Cookie的key-value的，所以直接用隐私数据保存在Cookie是很不安全的，这个时候就出现了Session。</p>
<p>拿登录来说，第一次登录的时候，服务器会返回Session ID，这个ID是一个没有规律的字符串，这个时候客户端可以通过Cookie技术来存储这个Session ID，服务器此时会保存这个Session ID，当有请求到来的时候，就会根据保存的Session ID进行判断请求是否合法。session的实现除了Cookie以外，还有一种形式就是URL重写，这种做法就是在请求URL后面把Session ID当作一个请求参数，因为有些浏览器可能设置了禁用Cookie。</p>
<p>但是Session ID的缺陷就是需要服务器存储这个值，如果某一时刻有用多用户，服务器就需要存储很多的Session ID值，如果服务器有多台的话这个Session ID就可能需要通过某种方式进行共享，这些问题都会让Session ID出现一系列问题，所以后面就出现了JWT技术。</p>
<p>JWT是通过加密的形式得到一个加密后的字符串Token，返回给客户端客户端通过Cookie进行保存，后面的请求都携带这个字符串，然后服务器端对这个Token进行解密，得到解密后的内容，包括过期时间，加密前的数据等，这样服务器就不需要额外对这个Token进行保存。</p>
<h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p> HTTP报文分为请求报文和响应报文两种，但是他们的结构都是一样的，都包括：起始行、头部字段、消息正文。</p>
<p>这其中前两部分起始行和头部字段经常又合称为“<strong>请求头</strong>”或“<strong>响应头</strong>”，消息正文又称为“<strong>实体</strong>”，但与“<strong>header</strong>”对应，很多时候就直接称为“<strong>body</strong>”。</p>
<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>
<p>所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个“空行”。</p>
<p><img src="/../../images/image-20240128154523272.png" alt="image-20240128154523272"></p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>了解了 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是<strong>请求行</strong>（request line），它简要地描述了<strong>客户端想要如何操作服务器端的资源</strong>。</p>
<p>请求行由三部分构成：</p>
<ol>
<li>请求方法：是一个动词，如 GET&#x2F;POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>
<p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>
<p><img src="/../../images/36108959084392065f36dff3e12967b9.png" alt="img"></p>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span> HTTP<span class="operator">/</span><span class="number">1.1</span></span><br></pre></td></tr></table></figure>

<p>在这个请求行里，“GET”是请求方法，“&#x2F;”是请求目标，“HTTP&#x2F;1.1”是版本号，把这三部分连起来，意思就是“服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。”</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>看完了请求行，我们再看响应报文里的起始行，在这里它不叫“响应行”，而是叫“<strong>状态行</strong>”（status line），意思是<strong>服务器响应的状态</strong>。</p>
<p>比起请求行来说，状态行要简单一些，同样也是由三部分构成：</p>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
</ol>
<p><img src="/../../images/a1477b903cd4d5a69686683c0dbc3300.png" alt="img"></p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>

<p>意思就是：“浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”</p>
<p>而另一个“GET &#x2F;favicon.ico HTTP&#x2F;1.1”的响应报文状态行是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br></pre></td></tr></table></figure>

<p>翻译成人话就是：“抱歉啊浏览器，刚才你的请求收到了，但我没找到你要的资源，错误代码是 404，接下来的事情你就看着办吧。”</p>
<h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头，我画了两个示意图，你可以看一下。</p>
<p><img src="/../../images/1fe4c1121c50abcf571cebd677a8bdea.png" alt="img"></p>
<p><img src="/../../images/cb0d1d2c56400fe9c9988ee32842b175.png" alt="img"></p>
<p>请求头和响应头的结构是基本一样的，唯一的区别是起始行，所以我把请求头和响应头里的字段放在一起介绍。</p>
<p>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。</p>
<p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。</p>
<p>不过使用头字段需要注意下面几点：</p>
<ol>
<li>字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；</li>
<li>字段名里不允许出现空格，可以使用连字符“-”，但<strong>不能使用下划线</strong>“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>
<li>HTTP&#x2F;1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。</li>
</ol>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h3 id="1××"><a href="#1××" class="headerlink" title="1××"></a>1××</h3><p>1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</p>
<p>我们偶尔能够见到的是“<strong>101 Switching Protocols</strong>”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>
<h3 id="2××"><a href="#2××" class="headerlink" title="2××"></a>2××</h3><p>2××类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。</p>
<p>“<strong>200 OK</strong>”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>
<p>“<strong>204 No Content</strong>”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>
<p>“<strong>206 Partial Content</strong>”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p>
<p>状态码 206 通常还会伴随着头字段“<strong>Content-Range</strong>”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99&#x2F;2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p>
<h3 id="3××"><a href="#3××" class="headerlink" title="3××"></a>3××</h3><p>3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。</p>
<p>“<strong>301 Moved Permanently</strong>”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。</p>
<p>与它类似的是“<strong>302 Found</strong>”，曾经的描述短语是“<strong>Moved Temporarily</strong>”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p>
<p>301 和 302 都会在响应头里使用字段<strong>Location</strong>指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。</p>
<p>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</p>
<p>再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</p>
<p>“<strong>304 Not Modified</strong>” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。</p>
<p>301、302 和 304 分别涉及了 HTTP 协议里重要的“重定向跳转”和“缓存控制”，在之后的课程中我还会细讲。</p>
<h3 id="4××"><a href="#4××" class="headerlink" title="4××"></a>4××</h3><p>4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。</p>
<p>“<strong>400 Bad Request</strong>”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>
<p>“<strong>403 Forbidden</strong>”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。</p>
<p>“<strong>404 Not Found</strong>”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>
<p>4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p>
<ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
<h3 id="5××"><a href="#5××" class="headerlink" title="5××"></a>5××</h3><p>5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。</p>
<p>“<strong>500 Internal Server Error</strong>”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</p>
<p>“<strong>501 Not Implemented</strong>”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</p>
<p>“<strong>502 Bad Gateway</strong>”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p>
<p>“<strong>503 Service Unavailable</strong>”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。</p>
<p>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“<strong>Retry-After</strong>”字段，指示客户端可以在多久以后再次尝试发送请求。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>由于HTTP报文的格式是明文存储的，这就导致了很多内容都可以被知道，安全性不算特别好。所以HTTPS就在HTTP协议的基础上增加了一个<strong>SSL&#x2F;TLS加密协议</strong>。</p>
<p>SSL是TLS的前世，现在大多数用的都是TLS协议。加密被分为对称加密和非堆成加密。</p>
<ul>
<li>对称加密</li>
</ul>
<p>指的就是加密和解密使用的都是同一个 密钥 ，服务器端让客户端知道密钥之后，客户端把数据用这个密钥进行加密后发给服务器端，服务器端用密钥进行解密，得到原始数据。这个加密方式如果密钥被知道了之后安全性及不复存在了。</p>
<ul>
<li>非对称加密</li>
</ul>
<p>非对称加密有两个密钥，一个是公钥，另一个是私钥。服务器端把公钥告诉客户端，客户端用公钥加密后，发给服务器端，此时加密后的数据无法通过公钥进行解密，所以公钥被知道了也不会影响到安全性，服务器端必须使用私钥进行解密才能拿到原始数据。</p>
<p>了解完加密之后，HTTPS需要申请一个证书，这个整数是安装在服务器里面的，安装了这个证书之后，客户端就可以通过HTTPS来访问服务器，并且端口号从80变成了443。这个证书的作用就是标识这个网站的身份。</p>
<p>HTTPS对消息进行加密的方式其实及采用了对称加密，也采用了非对称加密，当客户端发起HTTPS请求的时候，会经过四次握手的过程。</p>
<p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p>
<p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>
<p><strong>RSA加密算法的流程：</strong></p>
<p><img src="/../../images/image-20240128190951386.png" alt="image-20240128190951386"></p>
<p>客户端发起第一次握手， 会发送TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（Client Random）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一</p>
<p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（Server Random）</strong>。除此之外，服务端还会把自己的证书发给客户端</p>
<p>此时客户端和服务器端都有了两个随机数，客户端还有服务器端发来的证书以及公钥。客户端对证书进行验证之后，就会客户端会再次生成一个随机数，并且用服务器端的公钥进行加密，发送给服务器端，这个新的加密后的随机数被称为<strong>pre-master</strong>，这里的加密就是非对称加密，此时只有服务器端的私钥可以解密得到pre-master的内容。</p>
<p>至此客户端和服务器端都有三个随机数，于是，双方根据已经得到的三个随机数，生成<strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p>
<p>生成完「会话密钥」后，然后客户端告诉服务端开始使用加密方式发送消息。然后，客户端再发一个，把之前所有发送的数据做个<strong>摘要</strong>，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</p>
<p>服务器也是同样的操作，如果双方都验证加密和解密没问题，那么握手正式完成。</p>
<h2 id="HTTP1-1、HTTP2-0、HTTP3-0"><a href="#HTTP1-1、HTTP2-0、HTTP3-0" class="headerlink" title="HTTP1.1、HTTP2.0、HTTP3.0"></a>HTTP1.1、HTTP2.0、HTTP3.0</h2><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>HTTP1.1的核心是 一次一份，发送一个请求之后，需要等待得到响应之后，才可以发送下一个请求。我们请求一个网页的时候，服务器实际上实现把html页面发送给我们，然后再请求CSS、JS等内容，这些都是浏览器帮我们完成的，这就看着像我们一次点击事件，发送了很多请求。</p>
<p>如果再请求队伍里面出现了一个文件没办法收到或者请求了很长时间就会出现上面说的队头阻塞的问题。对于队头阻塞上面说了一些解决办法，但是这些办法都很大的增大了开发的复杂度，除此之外为了减少请求还有很多开发人员想出来的方法，合并 CSS、JS、HTML，把图片尽可能弄成一张，或者把图片用应编码的方式，处理成二进制字符串，等等。再随着HTTPS的出现，本来就请求太多，还加上TLS的握手过程，又增加了请求的次数。除了TCP的固定开销以外，TCP为了实现拥塞控制还有一个慢启动，这就导致了新访问的网页会出现加载缓慢的问题。</p>
<p>另外不可忽略的是，每次HTTP请求的请求头都需要携带大量的信息，很多都是重复发送的，比如TOKEN这样的内容，并且这些内容都是明文存储，没有进行压缩，导致了首部又累赘又臃肿。</p>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>为了解决HTTP1.1，存在的问题就出现了HTTP2.0，HTTP2.0为了解决对头阻塞的问题，引入了多路复用，并且将原本的数据报，划分成了首部帧和数数据帧，最重要的是有一个流标识符（Stream ID），不同的流标标识符之间可以并发，通过这个流标识符就允许数据的顺序不需要按照发送方发送的顺序达到接收方，从而解决了HTTP1.1的应用层队头阻塞的问题。</p>
<p>并且HTTP2.0还优化了HTTP1.1首部不压缩的问题，还有HTTP1.1的数据实体部分采用的是ASCII编码，而HTTP2.0直接使用二进制编码使得解析起来效率更高。</p>
<p>HTTP2.0还有一个服务器推送的功能，当请求一个HTML的时候，会顺便把这个HTML相关的CSS和JS一起推送过去，看起来非常美好，但是用户可能只是点错了一个页面也会把大量的内容进行缓存。</p>
<p>上面是HTTP2.0的一些优点，但是HTTP2.0存在的问题还是比较多的，除了上面的服务器推送功能以外。HTTP是应用层协议，<strong>它的stream机制是在应用层实现的</strong>，它下面还有一个传输层，而HTTP2.0是基于TCP实现的，由于TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。也就是说TCP不管你的数据是什么，<strong>都会封装为TCP的数据段</strong>，发送的时候按照TCP的发送规则进行发送，包括TCP的拥塞控制和流量控制。所以即使HTTP2.0解决了队头阻塞，在TCP传输的时候一样不管你的数据内容是什么，只要失败就要重传或者等待重传，<strong>而多个steam是复用同一个TCP的</strong>，所以当其中一个stream出现了丢包，TCP要等待这个stream的重传，这也导致了别的stream接收到的数据段不会交给应用层，这也就会出现TCP的队头阻塞的问题，所以很快HTTP3.0也就诞生了。</p>
<h3 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h3><p>由于TCP的拥塞控制和慢启动的特性，导致了对TCP有减速的效果，所以在HTTP3.0中采用UDP代替TCP。我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。</p>
<p>而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。</p>
<p>当然，HTTP&#x2F;3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应用层」实现了 <strong>QUIC 协议</strong>，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。</p>
<p>QUIC协议把原本的HTTP和TLS握手的过程整合到了一起变成了QUIC的握手，直接减少了来回的开销</p>
<p><img src="/../../images/image-20240129105338939.png" alt="image-20240129105338939"></p>
<p>并且QUIC握手过程目的是为了确定双方的连接 ID，后面就用这个连接ID来确定一个QUIC连接，而不是像之前的TCP一样通过源IP、源端口、目的IP、目的端口这样来确定一个TCP连接。这样做的好处是当网络发生切换时候不需要重新进行TCP连接和TLS连接减少了重新建立连接的开销。</p>
<p>HTTP3.0核心是解决了HTTP2.0在TCP传输层上的队头阻塞问题，将传输层协议从TCP替换为UDP之后，不需要建立连接，并且没有拥塞控制、不保证可靠性解决了传输层上的队头阻塞的问题，可靠性传输通过QUIC协议来保证，QUIC和HTTP2.0一样通过 连接ID来标识一个连接，不同连接ID之间可以并发，通过连接ID来重组数据，这样即使有一个连接ID的数据丢失了，也不会影响UDP将其他连接ID的数据交给QUIC层，QUIC只要接收到一个完整的连接ID的数据就会把数据交给应用层，不需要等到丢失的数据重传，从而完全解决了队头阻塞的问题。</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>域名解析服务：根据每一级的域名去解析出服务器IP地址的。所有域名都包含根域名 都是 “.” ，所以省略，然后就是顶级域名，com、org、edu…；再是二级域名、三级域名….。</p>
<p>查询域名的时候就是从根域名服务器开始查询的，包括两种方式查询：</p>
<ul>
<li><p>迭代查询，客户先查询本地域名服务器；没有找到则客户区查询根域名服务器，根域名服务器返回客户需要查询的根域名服务器的顶级域名服务器的地址；同样客户去找顶级域名服务器，顶级域名服务器返回客户二级域名服务器的地址…</p>
</li>
<li><p>递归查询，客户访问本地域名服务器，本地域名服务器没有找到就由本地域名服务器访问根域名服务器；根域名服务器去访问顶级域名服务器；顶级域名服务器访问二级渔民服务器….</p>
</li>
</ul>
<p>上面有特别提到，实际的 <code>DNS查询</code> 并不是单纯的迭代或者递归查询，而是相互结合使用，那么什么时候使用递归什么时候使用迭代呢？</p>
<p>主机向本地域名服务器发起的是递归查询，本地域名服务器到其他域名服务器发起的是迭代查询。</p>
<p><strong>完整的DNS查询过程是怎么样的？</strong></p>
<blockquote>
<p>1、浏览器将会检查缓存中有没有这个域名对应的解析过的 IP 地址，如果有该解析过程将会结束。浏览器缓存域名也是有限制的，包括缓存的时间、大小，可以通过 TTL 属性来设置。</p>
<p>2、如果用户的浏览器中缓存中没有，操作系统会先检查自己本地的 DNS 解析器缓存和 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。</p>
<p>3、如果都没有，会找 TCP&#x2F;IP 参数中设置的首选 DNS 服务器，我们叫它本地 DNS 服务器。通过递归查询的方式向本地 DNS 服务器发起查询，如果本地 DNS 服务器中有 A记录 或者该域名的映射缓存，则返回</p>
<p>4、如果都没有，本地域名服务器会开始迭代查询的过程，会先向 13 台根域名服务器查询该域名，根域名服务器会返回该域名的顶级域名服务器的 IP 地址，也就是 NS 记录。然后本地域名服务器再向顶级域名服务器发起查询，顶级域名服务器返回二级域名服务器的 NS 记录，重复这个过程直到返回 A 记录为止，最后把 A 记录中的 IP 地址返回给主机</p>
</blockquote>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-三次握手过程是怎样的？"><a href="#TCP-三次握手过程是怎样的？" class="headerlink" title="TCP 三次握手过程是怎样的？"></a>TCP 三次握手过程是怎样的？</h2><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p>
<p><img src="/../../images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p>
<p>client_isn和server_isn分别就是客户端和服务器端初始化的序号值。</p>
<ul>
<li>第一次握手，客户端发送标志位SYN&#x3D;1，和client_isn客户端初始序号，进入SYN_SENT状态。</li>
<li>第二次握手，服务器端发送标志位SYN&#x3D;1以及应答标志位ACK&#x3D;1，和server_isn服务端初始序号，以及对客户端初始序号的ack，服务器端进入SYN_RCVD状态</li>
<li>第三次握手，客户端发送应答标志位ACK&#x3D;1，以及对服务器端的初始化序号的ack，客户端进入ESTABLISHED状态。</li>
</ul>
<h2 id="三次握手期间每次出现丢失分别会发生什么？"><a href="#三次握手期间每次出现丢失分别会发生什么？" class="headerlink" title="三次握手期间每次出现丢失分别会发生什么？"></a>三次握手期间每次出现丢失分别会发生什么？</h2><h3 id="第一次握手出现丢失"><a href="#第一次握手出现丢失" class="headerlink" title="第一次握手出现丢失"></a>第一次握手出现丢失</h3><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p>
<p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
<p>超时重传也是有次数限制的，在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
<h3 id="第二次握手丢失"><a href="#第二次握手丢失" class="headerlink" title="第二次握手丢失"></a>第二次握手丢失</h3><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p>
<p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<p>同样如果超过了重试次数，那么就会断开TCP连接。</p>
<h3 id="第三次握手丢失"><a href="#第三次握手丢失" class="headerlink" title="第三次握手丢失"></a>第三次握手丢失</h3><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<h2 id="为什么需要第三次握手，而不直接在第三次握手的时候就开始发送数据？"><a href="#为什么需要第三次握手，而不直接在第三次握手的时候就开始发送数据？" class="headerlink" title="为什么需要第三次握手，而不直接在第三次握手的时候就开始发送数据？"></a>为什么需要第三次握手，而不直接在第三次握手的时候就开始发送数据？</h2><p>主要原因是为了防止，由于网络导致消息滞后而产生的问题。设想一下这种情况：</p>
<blockquote>
<p>客户端发送第一次握手信号，但是由于网络不可靠导致服务器端一直没有收到，客户端超时重传后，服务器端收到了，并且响应给客户端，客户端也收到服务器端的应答信号。此时已经完成两次握手，如果不需要第三次握手，此时已经进入连接建立的状态的话，后面就可以开始发送数据，直到数据发送完成，双方关闭TCP连接。</p>
<p>然后第一次发送的握手信号到达服务器端，此时服务器认为是一个新的TCP连接，于是会进入SYN_RECD状态，并且响应客户端，但是客户端此时已经关闭了，服务器端就会一直发送应答，并且不会断开TCP连接，直到超过重试次数，这就造成了不必要的服务器资源的浪费。</p>
<p>所以，两次握手主要是无法解决历史连接的问题，所以需要经过三次握手才能建立TCP连接。</p>
</blockquote>
<h2 id="为什么TCP建立连接的时候，初始化的序列号都是不一样的？"><a href="#为什么TCP建立连接的时候，初始化的序列号都是不一样的？" class="headerlink" title="为什么TCP建立连接的时候，初始化的序列号都是不一样的？"></a>为什么TCP建立连接的时候，初始化的序列号都是不一样的？</h2><p>主要是为了防止历史数据。如果每个TCP连接的初始序号都是一样的比如说是0，这就很容易出现，之前的TCP连接的历史数据因为网络不可靠滞后，导致下一个TCP连接接收到这个历史数据的时候，这条历史数据正好落在滑动窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</p>
<p><img src="/../../images/image-20240129172518450.png" alt="image-20240129172518450"></p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>TCP 断开连接是通过<strong>四次挥手</strong>方式。</p>
<p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p>
<p><img src="/../../images/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<h3 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h3><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
<ul>
<li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p>
<h3 id="什么情况会出现三次挥手？"><a href="#什么情况会出现三次挥手？" class="headerlink" title="什么情况会出现三次挥手？"></a>什么情况会出现三次挥手？</h3><p>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p>
<p><img src="/../../images/d7b349efa4f94453943b433b704a4ca8.png" alt="在这里插入图片描述"></p>
<p>然后因为 TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多。</p>
<p><strong><font size=5>什么是延迟确认机制？</font></strong></p>
<p>当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 <strong>TCP 延迟确认</strong>。 TCP 延迟确认的策略：</p>
<ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<p><img src="/../../images/33f3d2d54a924b0a80f565038327e0e4.png" alt="img"></p>
<h2 id="四次挥手每次出现丢失分别会发生什么？"><a href="#四次挥手每次出现丢失分别会发生什么？" class="headerlink" title="四次挥手每次出现丢失分别会发生什么？"></a>四次挥手每次出现丢失分别会发生什么？</h2><h3 id="第一次挥手出现丢失"><a href="#第一次挥手出现丢失" class="headerlink" title="第一次挥手出现丢失"></a>第一次挥手出现丢失</h3><p>和第一次握手一样，如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>当客户端超时重传 3 次 FIN 报文后，假设 tcp_orphan_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。</p>
<h3 id="第二次挥手出现丢失"><a href="#第二次挥手出现丢失" class="headerlink" title="第二次挥手出现丢失"></a>第二次挥手出现丢失</h3><p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<p>当客户端超时重传 2 次 FIN 报文后，假设 tcp_orphan_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</p>
<h3 id="第三次、第四次挥手出现丢失"><a href="#第三次、第四次挥手出现丢失" class="headerlink" title="第三次、第四次挥手出现丢失"></a>第三次、第四次挥手出现丢失</h3><p>总体和上面两次都是一样的，第三次丢失会一直重发FIN直到达到最大重试次数。</p>
<p>对于第四次挥手，由于客户端进行第四次挥手的时候就已经进入TIME_WAIT状态了，会一直持续这个状态直到2个MSL的事件，客户端自动就会关闭，如果第四次的ACK一直丢失，同样是服务器端的FIN会被一直重发直到最大重试次数，如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</p>
<h2 id="为什么TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么TIME_WAIT 等待的时间是 2MSL？"></a>为什么TIME_WAIT 等待的时间是 2MSL？</h2><p>MSL：最大报文存活时间，由于TIME_WAIT状态是主动发起断开TCP连接的一方才有的。这个状态是接收到被断开方的FIN报文后，<strong>发送对FIN报文的应答ACK报文后</strong>进入的状态。</p>
<p> 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code>FIN</code> 报文。若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p>
<p>设置成2而不设置成4、8更大的原因是：一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率都只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<h2 id="为什么需要TIME-WAIT-状态？"><a href="#为什么需要TIME-WAIT-状态？" class="headerlink" title="为什么需要TIME_WAIT 状态？"></a>为什么需要TIME_WAIT 状态？</h2><p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
<p>第一点其实和为什么需要三次握手是一样的，因为如果没有TIME_WAIT状态，或者是TIME_WAIT状态太短的话，对于同样的四元组创建的TCP连接，服务器端发送的数据的延迟，直到第二次TCP连接才到达，此时就出现的数据的混乱。</p>
<p><img src="/../../images/image-20240129202146090.png" alt="image-20240129202146090"></p>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p>另外一点和上面的 <code>为什么TIME_WAIT 等待的时间是 2MSL？</code> 是一样的。</p>
<h2 id="TIME-WAIT过多会有什么问题？"><a href="#TIME-WAIT过多会有什么问题？" class="headerlink" title="TIME_WAIT过多会有什么问题？"></a>TIME_WAIT过多会有什么问题？</h2><ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li>
</ul>
<p><strong>客户端</strong>太多了TIME_WAIT会导致，大量的端口被占用，极端一点的话占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。</p>
<p><strong>服务端</strong> TIME_WAIT 状态过多，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<h2 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h2><p>首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p>
<p>问题来了，<strong>什么场景下服务端会主动断开连接呢？</strong></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
</ul>
<blockquote>
<p>没有使用长连接的话，HTTP会频繁的建立TCP和断开TCP连接，所以没有使用长连接很容易出现很多的TIME_WAIT状态，但是HTTP1.1之后长连接就是默认开启的状态了，所以这这种情况就不做多考虑。</p>
</blockquote>
<ul>
<li>第二个场景：HTTP 长连接超时</li>
</ul>
<blockquote>
<p>HTTP长连接为了防止客户端建立连接后长时间不发数据，所以规定每个长连接在规定时间内没有发送数据就会断开长连接，所以可能出现了长连接在某一时间段内容都断开，导致出现了大量的TIME_WAIT状态。</p>
</blockquote>
<ul>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>
<blockquote>
<p>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。</p>
<p>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。<strong>如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接</strong>，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
</blockquote>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 <code>ESTABLISH</code> 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP 搞了个<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75  </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure>

<ul>
<li>tcp_keepalive_time&#x3D;7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl&#x3D;75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes&#x3D;9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>TCP 保活的这个机制检测的时间是有点长，我们可以自己在应用层实现一个心跳机制。</p>
<p>比如，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<h2 id="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"><a href="#如果已经建立了连接，但是服务端的进程崩溃会发生什么？" class="headerlink" title="如果已经建立了连接，但是服务端的进程崩溃会发生什么？"></a>如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h2><p>这个问题看似和上面的很像，但是其实有很大的区别的，最主要的就是进程崩溃和客户端出现故障（宕机、断电）这两个区别。</p>
<p>进程崩溃，操作系统内核会回收TCP资源，并且会发送FIN报文，而客户端出现故障则不会发送FIN报文。</p>
<p>所以进程崩溃的情况，内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p>
<p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
<h2 id="拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗？"></a>拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>这个问题很容易误认为，物理层都出问题了，上层更会出问题。这就是忘记了网络分层的目的了，分层的目的就是为了让没层都能够专注于完成自己的工作。并且传输层是端到端的连接关系，所以网线断了只会让接收方无法收到数据，这个TCP连接不会被断。</p>
<p>后续如果有数据还在传输，那如果接收方一直没有连回网线则发送方会在最大重试次数后自动断开连接。如果中途连接回来了，就能够继续接收数据。</p>
<p>如果没有数据传输，这个时候TCP的保活机制就会起作用，每隔一段时间会发送探测报文给接收方，如果长时间没有回应就会断开TCP连接。</p>
<h2 id="向一个不存在的IP或者端口发起一个TCP连接会发生什么？"><a href="#向一个不存在的IP或者端口发起一个TCP连接会发生什么？" class="headerlink" title="向一个不存在的IP或者端口发起一个TCP连接会发生什么？"></a>向一个不存在的IP或者端口发起一个TCP连接会发生什么？</h2><p><strong>问题一：不存在的IP发起TCP连接</strong></p>
<blockquote>
<p>情况一：客户端和服务端在同一个局域网内<br>这种情况，不需要经过路由器转发，所以直接通过ARP协议询问目的IP的MAC地址，但是局域网内没有对应的IP导致，无法得到响应没有 MAC地址就无法封装MAC头，导致SYN消息没办法发出去。</p>
<p>情况二：客户端和服务端不在同一个局域网内<br>这种情况，需要通过路由器转发，会把SYN报文发给对饮的路由器，路由器会帮忙转发，但是由于无法找到目的IP，所以没办法得到SYN应答，客户端会重发SYN报文直到超过重试次数</p>
</blockquote>
<p><strong>问题二：不存在的端口发起TCP连接</strong></p>
<blockquote>
<p>相当于是服务端，没有进程监听这个端口所以没有目标会接收到这个SYN报文，内核会响应客户端一个RST报文，客户端收到RST报文之后就会释放连接</p>
</blockquote>
<h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>这个超时的时间设置很麻烦，要怎么确定这个超时时间（RTO）才合理。如果RTO过大，会导致重传的很慢，使得网络利用率很低；如果RTO过小，会出现大量的重传，导致网络负载很高。最理想的就是RTO的时间稍微比RTT时间大一点点，但是这个也很难把控。</p>
<p><img src="/../../images/image-20240131122722892.png" alt="image-20240131122722892"></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p><strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p>发送方可以连续的发送数据，接收方每次都对第一个缺失的数据进行应答，并且出现数据丢失时候还可以继续接收数据，但是只会放在缓冲区，不会交给上层。当发送方接收到三个一样的ACK的时候可以选择重发缺失的数据。但是这个有一个问题就是发送方不知道， 接收方是否收到缺失后面的数据，是只要重发缺失的数据，还是缺失的后面的数据都要发？</p>
<p><img src="/../../images/image-20240131123034373.png" alt="image-20240131123034373"></p>
<p>对于上面这个例子：</p>
<ul>
<li>如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的 Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传。</li>
<li>如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。</li>
</ul>
<h3 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h3><p>为了解决这个问题就有了<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p><img src="/../../images/image-20240131123304228.png" alt="image-20240131123304228"></p>
<p>这种方法在Linux2.4之后都是默认打开的。</p>
<h2 id="TCP流量控制、拥塞控制"><a href="#TCP流量控制、拥塞控制" class="headerlink" title="TCP流量控制、拥塞控制"></a>TCP流量控制、拥塞控制</h2><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">流量控制</a></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">拥塞控制</a></p>
<h2 id="TCP拆包、粘包的问题"><a href="#TCP拆包、粘包的问题" class="headerlink" title="TCP拆包、粘包的问题"></a>TCP拆包、粘包的问题</h2><p>TCP 传输协议是面向流的，没有数据包界限。客户端向服务端发送数据时，可能将一个完整的报文拆分成多个小报文进行发送，也可能将多个报文合并成一个大的报文进行发送。因此就有了拆包和粘包。</p>
<p>计算机网络中关于数据的基本概念：</p>
<p><strong>MTU（Maxitum Transmission Unit）</strong> 是链路层一次最大传输数据的大小。MTU 一般来说大小为 1500 byte。<strong>MSS（Maximum Segement Size）</strong> 是指 TCP 最大报文段长度，它是传输层一次发送最大数据的大小。</p>
<p>MTU 和 MSS 一般的计算关系为：MSS &#x3D; MTU - IP 首部 - TCP首部，如果 MSS + TCP 首部 + IP 首部 &gt; MTU，那么数据包将会被拆分为多个发送。这就是拆包现象。</p>
<p>如果发送的数据量非常小，比如说只有一个字节，传输的时候要加上20字节的TCP首部和IP首部，传41个字节的数据，只会有1字节真实数据，网络利用率很低。所以提出了<strong>Nagle算法</strong></p>
<p>Nagle 算法可以理解为<strong>批量发送</strong>，也是我们平时编程中经常用到的优化思路，它是在数据未得到确认之前先写入缓冲区，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。这个时候就会出现粘包的现象。</p>
<h3 id="拆包-x2F-粘包的解决方案"><a href="#拆包-x2F-粘包的解决方案" class="headerlink" title="拆包&#x2F;粘包的解决方案"></a>拆包&#x2F;粘包的解决方案</h3><p><img src="/../../images/CgqCHl-iZk2ALa_sAAD704YRY80575.png" alt="Drawing 3.png"></p>
<p>在客户端和服务端通信的过程中，服务端一次读到的数据大小是不确定的。如上图所示，拆包&#x2F;粘包可能会出现以下五种情况：</p>
<ul>
<li>服务端恰巧读到了两个完整的数据包 A 和 B，没有出现拆包&#x2F;粘包问题；</li>
<li>服务端接收到 A 和 B 粘在一起的数据包，服务端需要解析出 A 和 B；</li>
<li>服务端收到完整的 A 和 B 的一部分数据包 B-1，服务端需要解析出完整的 A，并等待读取完整的 B 数据包；</li>
<li>服务端接收到 A 的一部分数据包 A-1，此时需要等待接收到完整的 A 数据包；</li>
<li>数据包 A 较大，服务端需要多次才可以接收完数据包 A。</li>
</ul>
<h4 id="消息长度固定"><a href="#消息长度固定" class="headerlink" title="消息长度固定"></a>消息长度固定</h4><p>每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要空位补齐。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+----+------+------+---+----+</span></span><br><span class="line"></span><br><span class="line">| AB | CDEF | GHIJ | K | LM |</span><br><span class="line"></span><br><span class="line"><span class="addition">+----+------+------+---+----+</span></span><br></pre></td></tr></table></figure>

<p>假设我们的固定长度为 4 字节，那么如上所示的 5 条数据一共需要发送 4 个报文：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+------+------+------+------+</span></span><br><span class="line"></span><br><span class="line">| ABCD | EFGH | IJKL | M000 |</span><br><span class="line"></span><br><span class="line"><span class="addition">+------+------+------+------+</span></span><br></pre></td></tr></table></figure>

<p>消息定长法使用非常简单，但是缺点也非常明显，无法很好设定固定长度的值，如果长度太大会造成字节浪费，长度太小又会影响消息传输，所以在一般情况下消息定长法不会被采用。</p>
<h4 id="特定分隔符"><a href="#特定分隔符" class="headerlink" title="特定分隔符"></a>特定分隔符</h4><p>既然接收方无法区分消息的边界，那么我们可以在每次发送报文的尾部加上<strong>特定分隔符</strong>，接收方就可以根据特殊分隔符进行消息拆分。以下报文根据特定分隔符 \n 按行解析，即可得到 AB、CDEF、GHIJ、K、LM 五条原始报文。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+-------------------------+</span></span><br><span class="line"></span><br><span class="line">| AB\nCDEF\nGHIJ\nK\nLM\n |</span><br><span class="line"></span><br><span class="line"><span class="addition">+-------------------------+</span></span><br></pre></td></tr></table></figure>

<p>由于在发送报文时尾部需要添加特定分隔符，所以对于分隔符的选择一定要避免和消息体中字符相同，以免冲突。否则可能出现错误的消息拆分。比较推荐的做法是将消息进行编码，例如 base64 编码，然后可以选择 64 个编码字符之外的字符作为特定分隔符。特定分隔符法在消息协议足够简单的场景下比较高效，例如大名鼎鼎的 Redis 在通信过程中采用的就是换行分隔符。</p>
<h4 id="消息长度-消息内容"><a href="#消息长度-消息内容" class="headerlink" title="消息长度 + 消息内容"></a>消息长度 + 消息内容</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">消息头     消息体</span><br><span class="line"></span><br><span class="line"><span class="addition">+--------+----------+</span></span><br><span class="line"></span><br><span class="line">| Length |  Content |</span><br><span class="line"></span><br><span class="line"><span class="addition">+--------+----------+</span></span><br></pre></td></tr></table></figure>

<p><strong>消息长度 + 消息内容</strong>是项目开发中最常用的一种协议，如上展示了该协议的基本格式。消息头中存放消息的总长度，例如使用 4 字节的 int 值记录消息的长度，消息体实际的二进制的字节数据。接收方在解析数据时，首先读取消息头的长度字段 Len，然后紧接着读取长度为 Len 的字节数据，该数据即判定为一个完整的数据报文。依然以上述提到的原始字节数据为例，使用该协议进行编码后的结果如下所示：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+-----+-------+-------+----+-----+</span></span><br><span class="line"></span><br><span class="line">| 2AB | 4CDEF | 4GHIJ | 1K | 2LM |</span><br><span class="line"></span><br><span class="line"><span class="addition">+-----+-------+-------+----+-----+</span></span><br></pre></td></tr></table></figure>

<p>消息长度 + 消息内容的使用方式非常灵活，且不会存在消息定长法和特定分隔符法的明显缺陷。当然在消息头中不仅只限于存放消息的长度，而且可以自定义其他必要的扩展字段，例如消息版本、算法类型等。</p>
<h2 id="TCP的keep-alive和HTTP的keep-alive是一个东西吗"><a href="#TCP的keep-alive和HTTP的keep-alive是一个东西吗" class="headerlink" title="TCP的keep alive和HTTP的keep alive是一个东西吗"></a>TCP的keep alive和HTTP的keep alive是一个东西吗</h2><p>显然不是，HTTP是应用层用户实现的，而TCP是操作系统内核实现的。</p>
<p>HTTP的keep alive指的是，HTTP 长连接机制，为了解决HTTP1.0每次请求都要重新进行三次握手和四次挥手的过程。</p>
<p>TCP的keep alive是传输层的内核实现的，为的是防止客户端建立连接后长时间不发送数据，导致客户端资源浪费的情况，TCP服务端定时会发送探测报文，如果长时间得不到客户端的应答就会主动断开TCP连接。</p>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。</p>
<p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不白，没头没脑的作风不是计算机网络的风格。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。所以ICMP就是当数据传输出现问题的时候会给发送方提供错误信息的协议。</p>
<p><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
<p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。</p>
<p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p>
<ul>
<li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li>
<li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li>
</ul>
<p><img src="/../../images/image-20240201141942077.png" alt="image-20240201141942077"></p>
<h2 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h2><blockquote>
<p>回送消息 —— 类型 <code>0</code> 和 <code>8</code></p>
</blockquote>
<p><strong>回送消息</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息实现的。</p>
<p><img src="/../../images/image-20240201142115543.png" alt="image-20240201142115543"></p>
<h2 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h2><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p>
<ul>
<li><p>目标不可达消息 —— 类型 为 <code>3</code></p>
</li>
<li><p>原点抑制消息 —— 类型 <code>4</code></p>
</li>
</ul>
<p>为了降低发送方发送的速度，就会发送这种报文</p>
<ul>
<li>重定向消息 —— 类型 <code>5</code></li>
</ul>
<p>路由器发现了一个更优的路由路径，就会告诉源主机</p>
<ul>
<li>超时消息 —— 类型 <code>11</code></li>
</ul>
<p>报文每次经过一个路由器TTL都会减1，直到0 就会被丢弃，告诉源主机超时</p>
<h2 id="ping的工作原理"><a href="#ping的工作原理" class="headerlink" title="ping的工作原理"></a>ping的工作原理</h2><p>ping 命令就是使用了 ICMP协议的查询报文，当一个主机用ping 命令判断对方ip是否可达的时候，源主机的网络层会构建ICMP报文，并且将报文类型设置为<strong>回送请求报文</strong>，并且为了计算延迟会加上发送时间。</p>
<p>让后ICMP报文被加上IP头，构建成IP数据包交给数据链路层，数据链路层根据ARP协议找到IP对应的MAC地址，加上MAC信息封装成帧，然后将数据发送出去。</p>
<p>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p>
<p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p>
<p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，然后再发送出去给主机 A。</p>
<p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p>
<p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p>
<h2 id="traceroute-——-差错报文类型的使用"><a href="#traceroute-——-差错报文类型的使用" class="headerlink" title="traceroute —— 差错报文类型的使用"></a>traceroute —— 差错报文类型的使用</h2><p>另外一个使用ICMP协议的就是traceroute工具，通过这个工具可以直到一个请求经过了哪些路由器。</p>
<p>它的原理就是利用 IP 包的<strong>生存期限</strong> 从 <code>1</code> 开始按照顺序递增的同时发送 <strong>UDP 包</strong>，强制接收 <strong>ICMP 超时消息</strong>的一种方法。</p>
<p>比如，将 TTL 设置 为 <code>1</code>，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是<strong>时间超时</strong>。</p>
<p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p>
<p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p>
<p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io">异梦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io/2022/08/19/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://yimeng436.github.io/2022/08/19/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yimeng436.github.io" target="_blank">异梦的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></div><div class="post_share"><div class="social-share" data-image="/img/top.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/19/Go%E9%9D%A2%E8%AF%95%E9%A2%98/Go%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go面试</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/17/CV%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/CV%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"><img class="next-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CV中的注意力机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="计算机网络面试题"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-21</div><div class="title">计算机网络面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">异梦</div><div class="author-info__description">欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yimeng436" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2441844062@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">体系结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">为什么要分层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-number">3.1.</span> <span class="toc-text">HTTP协议相关内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">3.2.</span> <span class="toc-text">队头阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">连接状态管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">HTTP报文格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-number">3.4.1.</span> <span class="toc-text">请求行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%A1%8C"><span class="toc-number">3.4.2.</span> <span class="toc-text">状态行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">3.4.3.</span> <span class="toc-text">头部字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.5.</span> <span class="toc-text">HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%C3%97%C3%97"><span class="toc-number">3.5.1.</span> <span class="toc-text">1××</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%C3%97%C3%97"><span class="toc-number">3.5.2.</span> <span class="toc-text">2××</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%C3%97%C3%97"><span class="toc-number">3.5.3.</span> <span class="toc-text">3××</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%C3%97%C3%97"><span class="toc-number">3.5.4.</span> <span class="toc-text">4××</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%C3%97%C3%97"><span class="toc-number">3.5.5.</span> <span class="toc-text">5××</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-number">3.6.</span> <span class="toc-text">HTTPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-1%E3%80%81HTTP2-0%E3%80%81HTTP3-0"><span class="toc-number">3.7.</span> <span class="toc-text">HTTP1.1、HTTP2.0、HTTP3.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1"><span class="toc-number">3.7.1.</span> <span class="toc-text">HTTP1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2-0"><span class="toc-number">3.7.2.</span> <span class="toc-text">HTTP2.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP3-0"><span class="toc-number">3.7.3.</span> <span class="toc-text">HTTP3.0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DNS"><span class="toc-number">4.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP"><span class="toc-number">5.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">TCP 三次握手过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%9F%E9%97%B4%E6%AF%8F%E6%AC%A1%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%A4%B1%E5%88%86%E5%88%AB%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">三次握手期间每次出现丢失分别会发生什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.2.1.</span> <span class="toc-text">第一次握手出现丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.2.2.</span> <span class="toc-text">第二次握手丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.2.3.</span> <span class="toc-text">第三次握手丢失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%9C%A8%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E5%BC%80%E5%A7%8B%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">为什么需要第三次握手，而不直接在第三次握手的时候就开始发送数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">为什么TCP建立连接的时候，初始化的序列号都是不一样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">5.5.</span> <span class="toc-text">TCP四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">5.5.1.</span> <span class="toc-text">为什么挥手需要四次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">5.5.2.</span> <span class="toc-text">什么情况会出现三次挥手？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%AF%8F%E6%AC%A1%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%A4%B1%E5%88%86%E5%88%AB%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">四次挥手每次出现丢失分别会发生什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.6.1.</span> <span class="toc-text">第一次挥手出现丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.6.2.</span> <span class="toc-text">第二次挥手出现丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E3%80%81%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.6.3.</span> <span class="toc-text">第三次、第四次挥手出现丢失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2MSL%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">为什么TIME_WAIT 等待的时间是 2MSL？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81TIME-WAIT-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">为什么需要TIME_WAIT 状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIME-WAIT%E8%BF%87%E5%A4%9A%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">TIME_WAIT过多会有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">服务器出现大量 TIME_WAIT 状态的原因有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">5.11.</span> <span class="toc-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.12.</span> <span class="toc-text">如果已经建立了连接，但是服务端的进程崩溃会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%EF%BC%8C-%E5%8E%9F%E6%9C%AC%E7%9A%84-TCP-%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97%EF%BC%9F"><span class="toc-number">5.13.</span> <span class="toc-text">拔掉网线后， 原本的 TCP 连接还存在吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84IP%E6%88%96%E8%80%85%E7%AB%AF%E5%8F%A3%E5%8F%91%E8%B5%B7%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.14.</span> <span class="toc-text">向一个不存在的IP或者端口发起一个TCP连接会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">5.15.</span> <span class="toc-text">TCP重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">5.15.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">5.15.2.</span> <span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SACK"><span class="toc-number">5.15.3.</span> <span class="toc-text">SACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.16.</span> <span class="toc-text">TCP流量控制、拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8B%86%E5%8C%85%E3%80%81%E7%B2%98%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.17.</span> <span class="toc-text">TCP拆包、粘包的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E5%8C%85-x2F-%E7%B2%98%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.17.1.</span> <span class="toc-text">拆包&#x2F;粘包的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6%E5%9B%BA%E5%AE%9A"><span class="toc-number">5.17.1.1.</span> <span class="toc-text">消息长度固定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">5.17.1.2.</span> <span class="toc-text">特定分隔符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6-%E6%B6%88%E6%81%AF%E5%86%85%E5%AE%B9"><span class="toc-number">5.17.1.3.</span> <span class="toc-text">消息长度 + 消息内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84keep-alive%E5%92%8CHTTP%E7%9A%84keep-alive%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97"><span class="toc-number">5.18.</span> <span class="toc-text">TCP的keep alive和HTTP的keep alive是一个东西吗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ICMP"><span class="toc-number">6.</span> <span class="toc-text">ICMP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">查询报文类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">差错报文类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">ping的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#traceroute-%E2%80%94%E2%80%94-%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">traceroute —— 差错报文类型的使用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="MySQL原理"/></a><div class="content"><a class="title" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理">MySQL原理</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="算法笔记"/></a><div class="content"><a class="title" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记">算法笔记</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="前端知识"/></a><div class="content"><a class="title" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识">前端知识</a><time datetime="2023-06-05T16:00:00.000Z" title="发表于 2023-06-06 00:00:00">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="FSAF论文"/></a><div class="content"><a class="title" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文">FSAF论文</a><time datetime="2022-10-13T16:00:00.000Z" title="发表于 2022-10-14 00:00:00">2022-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="Faster-RCNN论文"/></a><div class="content"><a class="title" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文">Faster-RCNN论文</a><time datetime="2022-08-24T16:00:00.000Z" title="发表于 2022-08-25 00:00:00">2022-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 异梦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>