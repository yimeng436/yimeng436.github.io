<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机网络面试题 | 异梦的博客</title><meta name="keywords" content="计算机基础"><meta name="author" content="异梦"><meta name="copyright" content="异梦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络常见面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络面试题">
<meta property="og:url" content="https://yimeng436.github.io/2022/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="异梦的博客">
<meta property="og:description" content="计算机网络常见面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yimeng436.github.io/img/top.png">
<meta property="article:published_time" content="2022-08-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-02-11T07:40:36.734Z">
<meta property="article:author" content="异梦">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yimeng436.github.io/img/top.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yimeng436.github.io/2022/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-11 15:40:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">异梦的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-20T16:00:00.000Z" title="发表于 2022-08-21 00:00:00">2022-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-11T07:40:36.734Z" title="更新于 2024-02-11 15:40:36">2024-02-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><h2 id="介绍OSI七层网络模型、各层协议有哪些？"><a href="#介绍OSI七层网络模型、各层协议有哪些？" class="headerlink" title="介绍OSI七层网络模型、各层协议有哪些？"></a>介绍OSI七层网络模型、各层协议有哪些？</h2><blockquote>
<p>OSI网络模型将网络分为了：物理层、链路层、网络层、传输层、会话层、表示层、应用层。应用层协议有：HTTP、FTP、DNS等；传输层协议有：TCP、UDP协议；网络层协议有：IP、ICMP、ARP协议；</p>
<p>但是OSI模型只是理论的模型，没有考虑实际应用，实际没有采用这种模型，而是采用的是TCP&#x2F;IP网络模型。TCP&#x2F;IP模型将表示层 、会话层、应用层合并为应用层，物理层和链路层合并为网络接口层。</p>
</blockquote>
<h2 id="IP协议和TCP协议属于哪一层？"><a href="#IP协议和TCP协议属于哪一层？" class="headerlink" title="IP协议和TCP协议属于哪一层？"></a>IP协议和TCP协议属于哪一层？</h2><blockquote>
<p>IP协议：网络层</p>
<p>TCP协议：传输层</p>
</blockquote>
<h2 id="输入网址后会发生什么？"><a href="#输入网址后会发生什么？" class="headerlink" title="输入网址后会发生什么？"></a>输入网址后会发生什么？</h2><blockquote>
<p>输入网址后，浏览器会解析出路径、域名等信息，然后构建HTTP请求报文。</p>
<p>接着利用DNS对域名进行解析得到域名对应的IP地址；</p>
<p>有了IP地址之后，TCP层和IP层会分别在HTTP数据进行封装加上TCP头以及IP头，加上源IP、端口以及目的IP、端口；</p>
<p>然后就开始进行TCP三次握手，以第一次握手为例，会将TCP头的SYN标志位设为1，表示是客户端的SYN请求报文；</p>
<p>接着就交给数据链路层，数据链路层使用ARP协议，据目的IP找到目的IP对应的MAC地址，如果是同一个局域网的话就直接是目的IP的MAC，否则就是路由器的MAC地址，得到MAC地址之后就将数据封装为帧；</p>
<p>交给物理层，物理层会把数据发给交换机，最终找到目标服务器，服务器收到之后会自下而上逐层解析出数据，进行第二次握手。</p>
<p>当双方都完成三次握手之后，如果是HTTP协议那么就可以直接开始传送数据，如果是HTTPS请求的话，还有一个TLS握手的过程。</p>
<p>建立完连接之后，服务端将客户端请求的数据响应给客户端，这就是输入网址后发生的事情。</p>
</blockquote>
<h2 id="DNS是如何解析的，属于哪一层协议？"><a href="#DNS是如何解析的，属于哪一层协议？" class="headerlink" title="DNS是如何解析的，属于哪一层协议？"></a>DNS是如何解析的，属于哪一层协议？</h2><blockquote>
<p>DNS属于应用层协议，DNS解析的整个流程涉及到本地域名服务器、根域名服务器、顶级域名服务器、二级域名服务器等。<br>首先用户输入url之后，会先查找浏览器缓存，如果有缓存则不会进行DNS解析的过程。没有缓存则会查询系统域名映射表比如说host文件，如果有做映射也不会走后面的DNS解析。只有上面的两个都没命中才会开始DNS的流程，客户端向本地域名服务器递归地发起DNS查询，如果本地域名服务器有该域名的映射则直接返回；否则本地域名服务器会依次向根域名服务器、顶级域名服务器、二级域名服务器.. 以迭代的方式发起查询，最后返回给客户端，并且本地域名服务器会缓存这个域名的查询结果。</p>
</blockquote>
<h2 id="浏览器没有显示页面的原因？"><a href="#浏览器没有显示页面的原因？" class="headerlink" title="浏览器没有显示页面的原因？"></a>浏览器没有显示页面的原因？</h2><blockquote>
<p>首先，要先确定客户端自己本身是否联网，别的网页如果可以进入则表示是对这个域名的问题。</p>
<p>然后可以通过抓包查看DNS是否解析出了域名对应的IP，如果没有解析出来，则表示域名错了；</p>
<p>如果解析出了 IP地址，则可以通过抓包看看有没有建立TCP连接：</p>
<ul>
<li>没有建立TCP连接，可以查看是否监听对应的端口</li>
<li>建立了TCP连接，查看HTTP返回的响应码，根据状态码判断是什么问题</li>
</ul>
<p>如果客户端网络没有出现问题，可以通过ping查看目标的延迟是不是很高，如果很高可以查看当前请求是否非常多导致超过带宽上限；或者是业务接口处理的时间比较长。</p>
<p>总之，可以通过一层层向上排查，最终确定导致页面无法显示的原因。</p>
</blockquote>
<h2 id="TCP连接一个不存在的IP会出现什么问题"><a href="#TCP连接一个不存在的IP会出现什么问题" class="headerlink" title="TCP连接一个不存在的IP会出现什么问题"></a>TCP连接一个不存在的IP会出现什么问题</h2><blockquote>
<p>如果是一个局域网对于不存在的IP，由于不会存在路由器转发的过程，那么客户端在查询IP对于的MAC地址的时候，无法查询到对应的MAC地址，从而导致没办法构建MAC头信息，使得无法发出SYN报文</p>
<p>如果不是同一个局域网的IP，那么会有路由转发过程，所以在构建SYN报文的时候，不会像上一种情况一样找不到MAC地址，因为路由器会返回自己的MAC地址，但是由于IP还是不存在的，所以SYN报文会在网络中消亡，客户端在经过超时时间之后会重新发送SYN报文，直到达到最大重试次数。</p>
</blockquote>
<h2 id="TCP连接一个错误的端口会出现什么问题"><a href="#TCP连接一个错误的端口会出现什么问题" class="headerlink" title="TCP连接一个错误的端口会出现什么问题"></a>TCP连接一个错误的端口会出现什么问题</h2><blockquote>
<p>端口错误，TCP在建立连接的时候SYN到达目的IP之后，但是服务器没有监听这个端口，所以没办法响应SYN应答，但是内核会发送一个RST报文给客户端，客户端收到RST报文之后就会断开TCP连接。</p>
</blockquote>
<h2 id="客户端UDP发送一个IP存在端口不存在的报文会发生什么？"><a href="#客户端UDP发送一个IP存在端口不存在的报文会发生什么？" class="headerlink" title="客户端UDP发送一个IP存在端口不存在的报文会发生什么？"></a>客户端UDP发送一个IP存在端口不存在的报文会发生什么？</h2><blockquote>
<p>由于UDP不存在建立连接的步骤，以及UDP没有RST报文，这个时候会在网络层层通过ICMP协议来报告客户端端口不可达信息。</p>
</blockquote>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP报文的格式？怎么分割的？"><a href="#HTTP报文的格式？怎么分割的？" class="headerlink" title="HTTP报文的格式？怎么分割的？"></a>HTTP报文的格式？怎么分割的？</h2><blockquote>
<p>HTTP报文是明文，HTTP报文包括请求报文和响应报文。他们的格式基本上都是相同的，分为起始行、头部和实体。</p>
<p>起始行：包括请求或者响应的基本信息，比如请求方法、URL、HTTP版本信息；</p>
<p>头部：k-v键值对的形式保存的数据，比如Host、Content-type以及用户自定义的一些值</p>
<p>实体：请求或者响应的数据</p>
<p>起始行和头部通过  \r\n进行分隔，头部和实体通过空行进行分割。</p>
</blockquote>
<h2 id="HTTP哪些请求是安全、幂等的"><a href="#HTTP哪些请求是安全、幂等的" class="headerlink" title="HTTP哪些请求是安全、幂等的"></a>HTTP哪些请求是安全、幂等的</h2><blockquote>
<p>这里的安全指的是，不会修改服务器数据的请求，所以GET方法肯定是幂等的，GET请求是一个只读的请求。而POST、PUT、DELETE都是不安全的请求</p>
<p>幂等指的是，多次请求得到的结果都是一样的，GET请求肯定是幂等的，因为只读。DELETE和PUT请求也是幂等的，多次删除和多次修改同样的数据结果肯定是一样的，而POST请求可能会创建多个资源所以不是幂等的。</p>
</blockquote>
<h2 id="GET和POST的区别？GET一定保证幂等性吗？"><a href="#GET和POST的区别？GET一定保证幂等性吗？" class="headerlink" title="GET和POST的区别？GET一定保证幂等性吗？"></a>GET和POST的区别？GET一定保证幂等性吗？</h2><blockquote>
<p>语义上来看，GET请求是获取服务器资源的方法，POST请求是向服务器提交数据的。</p>
<p>GET请求是只读请求，通常来说是保证安全性和幂等性的；而POST请求不保证安全性和幂等性。</p>
<p>GET请求的请求参数都是放在URL上的形成querystring，而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、application&#x2F;json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。</p>
<p>GET请求只是语义上是幂等的只读的，但是开发者也可以不遵循规范去请求，如果开发者让GET请求去增加资源则会出现不满足幂等性的情况。</p>
</blockquote>
<h2 id="HTTP有什么状态码"><a href="#HTTP有什么状态码" class="headerlink" title="HTTP有什么状态码"></a>HTTP有什么状态码</h2><blockquote>
<p>1x：提示信息，中间信息，后续还会有操作的</p>
<p>2x：表示请求成功，请求被正确处理。</p>
<p>3x：表示请求重定向，301永久重定向；302临时重定向；</p>
<p>4x：客户端错误，400请求错误没有明确的错误信息；403禁止访问；404url错误；</p>
<p>5x：服务端错误，500服务端代码错误；502网关代理出现错误；</p>
</blockquote>
<h2 id="重定向是哪一类状态码-临时重定向和永久重定向有什么区别"><a href="#重定向是哪一类状态码-临时重定向和永久重定向有什么区别" class="headerlink" title="重定向是哪一类状态码?临时重定向和永久重定向有什么区别?"></a>重定向是哪一类状态码?临时重定向和永久重定向有什么区别?</h2><blockquote>
<p>重定向是3开头的状态码。</p>
<p>永久重定向的状态码是301，浏览器收到301的时候会记忆重定向后的URL地址，下次访问的时候不需要访问旧的URL，直接转到新URL进行访问。</p>
<p>临时重定向的状态码是302，浏览器收到302的时候不会记忆重定向后的URL，下次访问的时候还是会访问旧的URL，如果还是302才会访问新的URL。比如说夜间更新就很适合使用临时重定向。</p>
</blockquote>
<h2 id="HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.1和HTTP2.0的区别"></a>HTTP1.1和HTTP2.0的区别</h2><blockquote>
<p>HTTP1.1是经典的一次一发的处理请求方式，所以它的请求是不能并发的。如果有一个请求被阻塞了就会出现队头阻塞的问题。而HTTP2.0通过引入多路复用，并且通过流标标识符，双方通过这个流标识符来标记。多个流复用一个TCP连接，这个流标识符使得数据不需要按顺序达到，从而解决了HTTP1.1请求无法并发的问题。</p>
<p>HTTP1.1的报文头部是明文存储，基本信息都是重复的，除了基本信息还有cookie哪些数据每次发送都需要携带，显得HTTP1.1报文非常的臃肿。而HTTP2.0对头部也进行了压缩，降低了传输的成本，数据实体部分HTTP2.0用二进制编码代替了HTTP1.1的ASCII码，加快了解析速度。</p>
<p>HTTP2.0有一个服务器推送的功能，请求一个HTML的时候，服务器会把相关的CSS、JS都响应回来，减少了消息传递的次数。</p>
</blockquote>
<h2 id="HTTP2-0和HTTP3-0的区别"><a href="#HTTP2-0和HTTP3-0的区别" class="headerlink" title="HTTP2.0和HTTP3.0的区别"></a>HTTP2.0和HTTP3.0的区别</h2><blockquote>
<p>HTTP2.0虽然在HTTP1.1上做了很大的改进，尤其是请求并发，但是HTTP2.0是应用层协议，它的steam机制是在应用层实现的，并且是基于TCP的，而TCP又是一个面向字节的可靠传出协议，它不会管应用的数据是什么，都会封装成数据段，按照TCP的发送规则进行传输，stream又是多路复用一个TCP连接的，这就导致了当有一个stream出现丢失的话，整个TCP都要等待这个数据重传，即使别的stream的数据段收到了也不会交给应用层，在HTTP的角度来看，其实也是出现了阻塞的，这是HTTP2.0的最大的问题TCP队头阻塞。</p>
<p>所以HTTP没有完全解决队头阻塞的问题，为了解决这个问题HTTP3.0传输层采用了UDP协议，并且在应用层和传输层之间加了一个QUIC层，通过QUIC层来保证数据可靠性。UDP协议不会有重传、流量控制、拥塞控制的机制，这就解决了TCP层面的队头阻塞的问题，通用使用stream机制来解决应用层的队头阻塞问题。所以HTTP3.0完全解决了队头阻塞的问题。</p>
<p>另外，HTTP3.0建立连接比HTTP2.0高效。QUIC层整合了原本的TCP+TLS建立连接的过程，将原本的TCP+TLS握手过程，整合成了QUIC握手过程，只需要三次握手就能完成连接建立。</p>
<p>最后，HTTP3.0不使用源IP、端口和目的IP、端口这样的四元组标识一个连接，而是在QUIC握手的时候会共同达成一个连接ID，通过连接ID来标识一个连接，这使得在网络发生切换的时候不会出现要重新建立连接的过程。</p>
</blockquote>
<h2 id="HTTP用户后续的操作，服务端如何知道属于同一个用户-追问-如果服务端是一个集群机器？"><a href="#HTTP用户后续的操作，服务端如何知道属于同一个用户-追问-如果服务端是一个集群机器？" class="headerlink" title="HTTP用户后续的操作，服务端如何知道属于同一个用户?追问:如果服务端是一个集群机器？"></a>HTTP用户后续的操作，服务端如何知道属于同一个用户?追问:如果服务端是一个集群机器？</h2><blockquote>
<p>cookie机制，客户端发送请求之后，服务端会进行响应并且携带一个set-cookie字段值，通知客户端保存这个cookie值，下次客户端请求会携带这个cookie值，服务端对比记录的cookie值。但是cookie存储的是k-v的形式，会携带敏感信息会出现安全性的问题。</p>
<p>然后就出现了session id的方式，服务端返回的是一个没有规律的字符串，客户端后面的请求都携带这个session id，服务端对比session id 是否合法。session id的问题是当请求量大的时候，服务端需要保存大量的session id，会造成内存占满的危险。</p>
<p>然后就出现JWT的机制，JTW机制根据用户信息以及时间信息进行加密得到一个字符串token，服务端不需要保存这个字符串，后面客户端请求同样携带这个token值，服务端通过对token解码得到用户的信息，从而对比请求是否合法。</p>
</blockquote>
<p><strong>追答</strong></p>
<blockquote>
<p>JWT机制保存的不是状态而是加密信息，所以天然适合分布式的系统，所以JWT是一个很不错的解决集群用户状态保存的机制。</p>
<p>对于session机制，则可以通过redis进行保存，服务端每次从redis中取出session id判断用户是否合法，但是这种方式容易出现redis单点故障，需要通过redis集群来解决，这种做法成本比JWT机制高太多。</p>
</blockquote>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><blockquote>
<p>cookie是存在客户端的，一般有大小限制，比如说限制数据保存大小为4K；session是存在服务端的，一般不会有大小限制。</p>
<p>session可以通过cookie来实现，cookie安全性比session低；</p>
</blockquote>
<h2 id="什么是跨域，什么情况下会发生跨域"><a href="#什么是跨域，什么情况下会发生跨域" class="headerlink" title="什么是跨域，什么情况下会发生跨域"></a>什么是跨域，什么情况下会发生跨域</h2><blockquote>
<p>当一个网页尝试访问不同源的资源的时候，就会出现跨域请求。只要域名、协议、端口有任意一个不同都会被认为是不同源的URL。</p>
<p>浏览器不允许跨域请求，出现跨域请求之后，如果没有处理浏览器会抛出一个错误。如果想绕过这个限制，需要使用CORS跨域资源共享技术，服务器在响应头上添加Access-Control-Allow-Origin 字段，浏览器读取到了 就会放行。</p>
</blockquote>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTPS和HTTP有什么区别"><a href="#HTTPS和HTTP有什么区别" class="headerlink" title="HTTPS和HTTP有什么区别"></a>HTTPS和HTTP有什么区别</h2><blockquote>
<p>主要有以下区别：</p>
<ul>
<li>连接建立，HTTP只需要经过三次握手就能够完成连接建立；HTTPS在完成三次握手之后，还需要TLS握手的过程对后面的数据进行加密保护</li>
<li>安全性方面，HTTP是明文，HTTPS是加密后的数据，所以HTTPS安全性较高</li>
<li>端口号，HTTP默认是80，HTTPS默认是443</li>
<li>HTTPS还需要数字证书来证明，服务端的身份</li>
</ul>
</blockquote>
<h2 id="有哪些加密算法"><a href="#有哪些加密算法" class="headerlink" title="有哪些加密算法"></a>有哪些加密算法</h2><blockquote>
<p>对称加密：使用同一个密钥进行加密和解密，如果密钥被窃取则加密效果失效。比如说AES算法</p>
<p>非对称加密：密钥分为公钥和私钥，用公钥进行加密，私钥进行解密，安全性较高。比如RSA算法</p>
</blockquote>
<h2 id="HTTPS建立连接的过程"><a href="#HTTPS建立连接的过程" class="headerlink" title="HTTPS建立连接的过程"></a>HTTPS建立连接的过程</h2><blockquote>
<p>HTTPS除了会经过TCP的三次握手建立连接的过程以外，还有一个TLS四次握手的过程。</p>
<p>第一次握手，客户端发送Client Hello消息，消息里面包括 TLS版本和密码套件以及一个随机生成的随机数，这个随机数是后面生成对称加密密钥的一部分。</p>
<p>第二次握手，服务端发送Server Hello消息，消息里面包括对TLS版本以及密码套件以及一个服务段端的随机数，这个随机数也是对称加密的一部分。除此之外为了证明服务端身份，服务端会把数字证书一起发给客户端。</p>
<p>客户端收到之后，会对证书进行确认，通过CA机构的公钥解密得到服务端的公钥。</p>
<p>第三次握手，客户端再次生成一个随机数，并且通过服务端的公钥对这个进行加密，通过Client key Exchange消息发送给服务端，服务端收到这个随机数之后用自己的私钥进行解密，双方就有了三个随机数，这三个随机数通过加密算法得到一个对称加密的密钥。得到密钥之后客户端会把上面的内容做一个摘要，通过对称加密的密钥进行加密发给服务端，让服务端进行验证。</p>
<p>第四次握手，服务端和客户端进行同样的操作，用对称加密的密钥进行加密，发送给客户端进行确认，如果双方加解密都没有问题，那么TLS四次握手就完成了。</p>
</blockquote>
<h2 id="HTTPS过程经过了几次对称加密和非对称加密"><a href="#HTTPS过程经过了几次对称加密和非对称加密" class="headerlink" title="HTTPS过程经过了几次对称加密和非对称加密"></a>HTTPS过程经过了几次对称加密和非对称加密</h2><blockquote>
<p>在TLS握手的时候，服务端会把数字证书发给客户端，客户端会用CA机构的公钥解密得到服务端的公钥，然后对自己生成的第二个随机数进行加密发给服务端，服务端收到后用私钥进行解密，这里就进行了一次非对称加密。</p>
<p>得到对称加密的密钥之后，双方都会对整个TLS握手过程的数据进行一次小结，用密钥进行加密发给对方，双方对加密后的内容用对称密钥进行解密，所以在建立连接的时候就会进行两次对称加密。</p>
<p>TLS握手结束后，双发收发数据都是通过对称加密的形式完成的。</p>
</blockquote>
<h2 id="HTTPS为什么不直接用非对称加密算法来加密HTTP报文"><a href="#HTTPS为什么不直接用非对称加密算法来加密HTTP报文" class="headerlink" title="HTTPS为什么不直接用非对称加密算法来加密HTTP报文"></a>HTTPS为什么不直接用非对称加密算法来加密HTTP报文</h2><blockquote>
<p>相比于对称加密，非对称加密的CPU开销更大，而且更耗时。而HTTP报文通常包含大量的数据，如果都使用非对称加密算法进行加密，难免会造成性能下降，延迟增加。</p>
</blockquote>
<h2 id="HTTPS会对URL加密吗"><a href="#HTTPS会对URL加密吗" class="headerlink" title="HTTPS会对URL加密吗"></a>HTTPS会对URL加密吗</h2><blockquote>
<p>HTTPS会对URL进行加密，因为HTTPS会对整个HTTP报文都加密，URL是HTTP报文的头部信息，所以HTTPS会对URL进行加密，在浏览器能够看到原始内容是因为，浏览器帮我们解密了。</p>
</blockquote>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP三次握手的流程"><a href="#TCP三次握手的流程" class="headerlink" title="TCP三次握手的流程"></a>TCP三次握手的流程</h2><blockquote>
<p>第一次握手，客户端向服务端发出SYN请求报文，并且随机一个序列号。此时客户端进入SYN_SENT状态</p>
<p>第二次握手，服务端收到SYN请求报文后，对这个报文进行响应，会发送一个SYN-ACK报文，应答的确认号为客户端的序列号+1，并且服务端也会初始化一个序列号。此时服务端进入SYN_RCVD状态。</p>
<p>第三次握手，客户端收到SYN响应报文之后，会开始发送一个ACK确认报文，确认号为服务端的序列号+1，此时客户端处于ESTABLISHED状态。</p>
<p>服务端收到ACK确认报文之后也进入ESTABLISHED状态。</p>
</blockquote>
<h2 id="为什么要三次握手，两次不行吗"><a href="#为什么要三次握手，两次不行吗" class="headerlink" title="为什么要三次握手，两次不行吗"></a>为什么要三次握手，两次不行吗</h2><blockquote>
<p>最主要的就是为了防止历史连接，在一次客户端发送一次SYN请求报文出现了延迟。触发超时重传之后，发了发送了一个新的SYN请求报文，这次的SYN请求报文被成功接收，并且完成了TCP建立以及数据传输，双方断开TCP连接。此时第一次延迟的报文到达服务端，如果用两次握手来建立连接的话，服务端对这个SYN报文进行应答时，就已经进入ESTABLISHED状态，但是客户端此时已经关闭了TCP连接，就不会处理这个报文，那服务端就一直会出现ESTABLISHED状态，直到超过了重传次数。这就造成了不必要的服务器资源的浪费。</p>
<p>另外三次握手是为了让双方都知道，双方都具有收发能力，如果只有两次握手，服务端只知道客户端具有发送消息的能力，而不知道客户端是否具有接收消息的能力。</p>
</blockquote>
<h2 id="第二次握手出现丢包，会发生什么？"><a href="#第二次握手出现丢包，会发生什么？" class="headerlink" title="第二次握手出现丢包，会发生什么？"></a>第二次握手出现丢包，会发生什么？</h2><blockquote>
<p>第二次握手出现丢包，会导致客户端、服务器双方都以为是自己的消息出现了丢失，所以客户端和服务端都会进行超时重传，客户端重传SYN报文，服务端重传SYN-ACK报文。</p>
</blockquote>
<h2 id="第三次握手出现丢包，会发生什么？"><a href="#第三次握手出现丢包，会发生什么？" class="headerlink" title="第三次握手出现丢包，会发生什么？"></a>第三次握手出现丢包，会发生什么？</h2><blockquote>
<p>第三次丢包的话，服务端一直收不到对SYN-ACK报文的应答报文，就会触发SYN-ACK报文的超时重传。客户端不会重传，因为ACK报文是不会被重传的。会一直进行超时重传直到达到最大重传次数。</p>
</blockquote>
<h2 id="TCP四次挥手的过程"><a href="#TCP四次挥手的过程" class="headerlink" title="TCP四次挥手的过程"></a>TCP四次挥手的过程</h2><blockquote>
<p>第一次挥手，客户端在准备断开TCP连接的时候，会发送FIN报文给服务端，进入FIN_WAIT_1状态。</p>
<p>第二次挥手，服务端在收到FIN报文的时候，会发送ACK应答报文给客户端，并且进入CLOSE_WAIT状态。</p>
<p>客户端收到服务端的ACK应答报文就会进入FIN_WAIT_2状态。</p>
<p>第三次挥手，服务端在处理完数据之后，就会发送一个FIN报文给客户端，进入LAST_ACK状态。</p>
<p>第四次挥手，客户端收到服务端的FIN报文后，会发送ACK响应报文给服务端，进入TIME_WAIT状态，并且经过2MSL的时间后就进入CLOSE状态。</p>
<p>服务端收到FIN的ACK响应报文就进入CLOSE状态。</p>
</blockquote>
<h2 id="断开TCP为什么要四次挥手，三次不可以吗？"><a href="#断开TCP为什么要四次挥手，三次不可以吗？" class="headerlink" title="断开TCP为什么要四次挥手，三次不可以吗？"></a>断开TCP为什么要四次挥手，三次不可以吗？</h2><blockquote>
<p>TCP是全双工的通信，收发双方都具有接收和发送的能力，所以断开时需要确保双方都没有数据要发送了才能够断开。客户端通过FIN报文来告诉服务端已经没有数据要发送了，服务端对FIN报文进行确认应答，但是服务端可能还有数据还没有处理完，所以不会立即发送FIN报文给客户端，而是将发送FIN报文的时机交给应用程序来掌握，当服务端数据都处理完了，就会调用断开连接的函数，内核就会发送FIN报文给客户端，表示服务端的数据也都发送完了，所以第二次和第三次握手一般都会分开。有了第三次挥手服务端的FIN报文就需要客户端第四次挥手对FIN报文的应答报文。如果只有三次挥手则可能会出现其中一方有数据没处理完导致数据丢失的情况。</p>
<p>但是在一些情况下TCP只会进行三次挥手，当服务端收到FIN报文，并且数据处理的同时还开启了延迟确认机制，那么就有可能只要三次挥手就能够完成TCP连接断开。</p>
</blockquote>
<h2 id="为什么要有TIME-WAIT状态，并且为什么设置为2MSL"><a href="#为什么要有TIME-WAIT状态，并且为什么设置为2MSL" class="headerlink" title="为什么要有TIME_WAIT状态，并且为什么设置为2MSL"></a>为什么要有TIME_WAIT状态，并且为什么设置为2MSL</h2><blockquote>
<p>TIME_WAIT状态是主动发起关闭TCP连接的一方才会有的状态，这个状态是为了确保被关闭方能够正确的接收到FIN报文的应答，如果主动关闭方一发送FIN应答报文就进入关闭状态，那这个FIN应答丢失就没有容错，被关闭方就不能即使断开连接。</p>
<p>设置为2MSL的目的是为了防止当前连接的历史报文被后面端口复用的连接获取，导致数据混乱。2MSL能够保证双方发送的数据能够在网络中消亡，新的连接就不会接收到历史报文了。除此之外，2MSL能够至少应付一次FIN应答报文丢失的情况。</p>
<p>不设置更多的TIME_WAIT的时间是因为，在一个丢包率为1%的糟糕网络中，连续出现两次丢包的概率也是非常低的，相比于设置更大的TIME_WAIT时间，如果真出现了两次丢包，那就让被关闭方重发次数达到最大限制吧。</p>
</blockquote>
<h2 id="服务端出现大量的TIME-WAIT的原因"><a href="#服务端出现大量的TIME-WAIT的原因" class="headerlink" title="服务端出现大量的TIME_WAIT的原因"></a>服务端出现大量的TIME_WAIT的原因</h2><blockquote>
<p>由于TIME_WAIT状态只会出现在主动断开连接的一方，所以服务器是主动断开连接的一方。所以就是大量服务端断开TCP的原因。</p>
<p>1、HTTP没有使用长连接，短链接的情况下， 服务端发送完数据就会主动关闭TCP连接，当请求量大的时候就会出现大量的主动断开TCP连接的操作，从而出现大量TIME_WAIT状态。</p>
<p>2、使用长连接时候，设置的一条连接能够发送的最大请求数过小，在高QPS的时候同样会使得服务端频繁的断开连接，出现大量的TIME_WAIT状态。</p>
</blockquote>
<h2 id="TCP粘包拆包是什么原因？怎么解决"><a href="#TCP粘包拆包是什么原因？怎么解决" class="headerlink" title="TCP粘包拆包是什么原因？怎么解决"></a>TCP粘包拆包是什么原因？怎么解决</h2><blockquote>
<p>TCP是面向字节流的连接，他并不关心数据的边界，如果数据超过MSS大小就会把数据分为多个TCP段进行发送。如果一个数据太小，就会根据Nagle算法将多个小的数据包堆积成一个大的TCP段一起发送。这就是TCP粘包和拆包。</p>
<p>其实TCP粘包和拆包并不是TCP的问题，而是TCP特性导致的，要解决需要在应用层进行处理比如说：</p>
<ul>
<li>固定消息长度，固定数据报文的长度，每次接收方累计收到固定长度后，就认为收到了一个完整的消息。当数据小于固定长度时候，需要进行填充。这种做法的缺点也很明显，不好确定长度。</li>
<li>特定分隔符号，每个数据报文的尾部都加上一个特定的分隔符，应用层根据分隔符来拆分数据。这种做法对分隔符的要求较高，要避免数据内容出现分隔符号，从而导致数据错误。</li>
<li>消息长度+内容，消息头保存消息的总长度，接收方根据消息的总长度以及每次读取的消息的长度来判断是否接收到了完整的数据，这种方式比较灵活，没有明显的不足。所以大部分都采用这种方式来解决TCP粘包拆包的问题</li>
</ul>
</blockquote>
<h2 id="TCP的keepalive了解吗？说说和HTTP的keepalive有什么区别？"><a href="#TCP的keepalive了解吗？说说和HTTP的keepalive有什么区别？" class="headerlink" title="TCP的keepalive了解吗？说说和HTTP的keepalive有什么区别？"></a>TCP的keepalive了解吗？说说和HTTP的keepalive有什么区别？</h2><blockquote>
<p>TCP的keepalive是服务端为了防止客户端建立连接不发送数据，导致资源浪费的一个保活机制。服务端长时间没收到客户端的消息的时候，就会通过这个机制发送一个探测报文来判断客户端是否还存活，如果没有收到探测报文的应答，就会重传，超过指定次数的时候，服务端就会主动断开连接。这个功能是由内核实现的</p>
<p>HTTP的keepalive是表示使用HTTP长连接的方式。它是为了避免频繁的进行三次握手和四次挥手建立连接的。该功能是应用程序实现的。</p>
</blockquote>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><blockquote>
<p>TCP需要经过三次握手才能建立连接，UDP不需要。</p>
<p>TCP报文头部有很多标志位，UDP头部只有源ip、端口；目的ip、端口。</p>
<p>TCP有拥塞控制和流量控制，UDP没有。</p>
<p>TCP是面向字节流的协议，数据之间没有明显的边界；UDP数据之间有明显的边界，都是一个个数据报的形式发送的。</p>
</blockquote>
<h2 id="视频会议用的是UDP还是TCP，UDP丢包会出现什么现象？"><a href="#视频会议用的是UDP还是TCP，UDP丢包会出现什么现象？" class="headerlink" title="视频会议用的是UDP还是TCP，UDP丢包会出现什么现象？"></a>视频会议用的是UDP还是TCP，UDP丢包会出现什么现象？</h2><blockquote>
<p>视频会议用的是UDP协议，因为视频会议对实时性要求较高，UDP协议的实时性比TCP好。视频会议使用UDP协议，出现丢包的话，最多也就是出现一些短暂的卡顿，如果后面的包被正常接收，不会对用户体验产生较大的影响。相反如果是TCP协议来做视频会议的话，那么出现一个丢包就会一直卡住，直到接收到丢失的这个包为止，这样的实时性就较差了。</p>
</blockquote>
<h2 id="UDP怎么改造成为一个可靠的传输？"><a href="#UDP怎么改造成为一个可靠的传输？" class="headerlink" title="UDP怎么改造成为一个可靠的传输？"></a>UDP怎么改造成为一个可靠的传输？</h2><blockquote>
<p>可以把TCP实现的那些在应用层实现一遍。</p>
<p>增加序列号和确认机制，让UDP的数据可以按序接收，并且增加超时重传机制，配合确认号机制，让发送方在一定时间内没有收到该序号的确认消息，就重传该数据包。</p>
<p>并且可以在应用层开辟一个内存，来实现滑动窗口，让发送方可以批量发送和接收，这样不仅可以提高传输效率，还可以和TCP一样，在滑动窗口的基础上实现流量控制和以及考虑网络拥塞情况进行拥塞控制。使得发送方能根据接收方接收的能力以及网络的拥堵情况来控制发送数据的速度。</p>
<p>相比于TCP，将UDP改成可靠的传输协议的优势有：可以更灵活的控制所选择的拥塞控制的算法，因为是在应用层实现的，不需要改操作系统内核。此外可以摆脱源IP、端口，目的IP、端口这样标识一个连接的约束，转而在建立连接的时候约定一个连接ID来标识一个连接，这样在网络切换的时候，不会因为IP、端口发生变换，导致重新建立连接。</p>
</blockquote>
<h2 id="TCP和UDP可以使用同一个端口吗？"><a href="#TCP和UDP可以使用同一个端口吗？" class="headerlink" title="TCP和UDP可以使用同一个端口吗？"></a>TCP和UDP可以使用同一个端口吗？</h2><blockquote>
<p>UDP默认的端口号是53，TCP默认端口号是80，默认端口号不是同一个。但是它们的端口号是可以公用的，因为IP头会有一个协议号字段，会标记数据采用的是什么协议进行发送的。接收方收到之后，会根据这个协议号来判断是用UDP模块去接收还是TCP模块去接收。这两个模块在内核中也是独立存在的不会出现冲突。</p>
</blockquote>
<h2 id="TCP是怎么保证可靠性的？"><a href="#TCP是怎么保证可靠性的？" class="headerlink" title="TCP是怎么保证可靠性的？"></a>TCP是怎么保证可靠性的？</h2><blockquote>
<p>1、建立连接需要经过三次握手才能建立，这样可以确认双方都有收发能力</p>
<p>2、有确认机制、以及超时重传机制。可以保证数据的有序性，客户端可以知道哪些数据包可能出现了丢失</p>
<p>3、有流量控制和拥塞控制，客户端不会一直发送，而是会根据接收方接受能力，以及完网络拥挤程度进行发送，这样就不会出现一直丢包的情况。</p>
</blockquote>
<h2 id="流量控制和拥塞控制有什么区别"><a href="#流量控制和拥塞控制有什么区别" class="headerlink" title="流量控制和拥塞控制有什么区别"></a>流量控制和拥塞控制有什么区别</h2><blockquote>
<p>流量控制，是端到端的，目的是为了防止发送方发送的过快，接收方处理不过来的问题。由滑动窗口实现，接收方在响应的AKC中会携带接收窗口的大小。</p>
<p>拥塞控制，是面向网络的，是为了防止网络中有大量的数据在传输，导致输出延迟。是通过几个算法来实现的：慢启动、拥塞避免、快重传和快速恢复。</p>
</blockquote>
<h2 id="滑动窗口是怎么设计的，解决了什么问题？"><a href="#滑动窗口是怎么设计的，解决了什么问题？" class="headerlink" title="滑动窗口是怎么设计的，解决了什么问题？"></a>滑动窗口是怎么设计的，解决了什么问题？</h2><blockquote>
<p>收发双方都有一个缓冲区，这个缓冲区的大小分表表示了最大能够发送的数据和最大能够接收的数据。有了缓冲区之后，发送方可以批量的将数据发送出去，提升了发送的效率。</p>
<p>发送方有了缓冲区之后，可以根据缓冲区的大小来限制发送方的发送速度，从而防止出现发送方发送过快，导致接收方处理不及时，出现丢包的问题。</p>
</blockquote>
<h2 id="拥塞控制是怎么实现的"><a href="#拥塞控制是怎么实现的" class="headerlink" title="拥塞控制是怎么实现的"></a>拥塞控制是怎么实现的</h2><blockquote>
<p>拥塞控制是通过几个算法来实现的：</p>
<p>慢启动 &#x3D;&gt; 拥塞避免 &#x3D;&gt; 超时重传 &#x3D;&gt; 慢启动：</p>
<p>初始化一个较小的拥塞窗口，然后每次收到一个确认，拥塞窗口的大小就翻倍。一直到慢启动门限值。</p>
<p>到达慢启动门限值之后，就进入拥塞避免算法，每次收到确认就对拥塞窗口加一。</p>
<p>如果出现了超时，直接把拥塞窗口降为1，并且把慢启动门限值设置为当前拥塞窗口的1&#x2F;2，然后重新进行慢启动。</p>
<p>这一套算法的流程，在出现超时重传的时候要重新进行慢启动，这个过程是很耗时的，可能当前网络也没有这么差，突然降到1的拥塞窗口，会让用户感觉突然变卡了很多，所以就有了另一套算法流程。</p>
<p>慢启动 &#x3D;&gt; 拥塞避免 &#x3D;&gt; 快速重传 &#x3D; &gt; 快速恢复：</p>
<p>前两个步骤都是一样的，由于出现拥塞的时候不一定会马上出现超时重传，而触发超时重传的代价太大了，所以当收到三个同样的ACK的时候，会认为网络有点卡，但是还能收到ACK又不是那么卡，所以会进行快速重传和快速恢复。</p>
<p>快速重传，快速重传算法是收到了三个同样的ACK才会触发的，此时会将门限值和拥塞窗口都设为当前拥塞窗口的1&#x2F;2，再进入快速恢复算法。</p>
<p>快速回复算法，此时发送方只会认为是有部分报文段丢失，并且丢失的报文后面的报文都被接收的只有接收了才会发重复的ACK，所以说明还可以适当增加拥塞窗口，也就是会让拥塞窗口+3，这个3就是表示丢失报文后面有三个报文被接收方接收了，然后重传丢失报文，如果重传的报文被接受了，就会回复一个新的ACK，此时就将拥塞窗口设置为门限值，直接进入拥塞避免算法。</p>
</blockquote>
<h2 id="一个服务端进程最多能建立多少个TCP连接？"><a href="#一个服务端进程最多能建立多少个TCP连接？" class="headerlink" title="一个服务端进程最多能建立多少个TCP连接？"></a>一个服务端进程最多能建立多少个TCP连接？</h2><blockquote>
<p>TCP连接是通过 源IP、端口；目的IP、端口这样的四元组来标识。假设服务端进程只监听一个端口号，服务端IP不会发生改变，那么能够建立最大的TCP连接就等于 <strong>客户端IP×客户端端口数</strong>，IP是32位的，端口号是16位的。所以理论上可以创建 2的48次方的TCP连接。</p>
<p>但是实际上不会达到这么大的连接数，因为每个TCP连接都是一个文件，所以会受到文件描述符的限制；另外每个TCP连接都需要占用内存，所以还会收到内存的限制。</p>
</blockquote>
<h2 id="一台服务器最多能连接多少TCP连接？"><a href="#一台服务器最多能连接多少TCP连接？" class="headerlink" title="一台服务器最多能连接多少TCP连接？"></a>一台服务器最多能连接多少TCP连接？</h2><blockquote>
<p>TCP连接是通过 源IP、端口；目的IP、端口这样的四元组来标识。对于一台服务器来说，理论上可以有很多个服务进程，让每个进程都监听不同的端口，这样能够建立最大的TCP连接就等于 <strong>客户端IP×客户端端口数×服务端端口数</strong>，IP是32位的，端口号是16位的。所以理论上可以创建 2的64次方的TCP连接。</p>
<p>但是实际上不会达到这么大的连接数，因为每个TCP连接都是一个文件，所以会受到文件描述符的限制；另外每个TCP连接都需要占用内存，所以还会收到内存的限制。</p>
</blockquote>
<h2 id="已经建立TCP连接，服务端断电了会发生什么？"><a href="#已经建立TCP连接，服务端断电了会发生什么？" class="headerlink" title="已经建立TCP连接，服务端断电了会发生什么？"></a>已经建立TCP连接，服务端断电了会发生什么？</h2><blockquote>
<p>需要分情况来看：</p>
<p>如果客户端还有数据发送，发送的数据一直得不到应答，所以会一直触发超时重传，直到到达指定的次数，客户端就会自动断开TCP连接。</p>
<p>如果客户端没有数据发送：</p>
<ul>
<li>如果没有开启keep alive机制，那么客户端就会一直保持当前的状态</li>
<li>如果开启了keep alive机制，那么达到一定时间没有进行通信，那么就会发送一个探测报文，如果没有收到响应，就进行重传，直到到达探测报文次数上限断开TCP连接</li>
</ul>
</blockquote>
<h2 id="已建立TCP连接，服务端进程奔溃会发生什么？"><a href="#已建立TCP连接，服务端进程奔溃会发生什么？" class="headerlink" title="已建立TCP连接，服务端进程奔溃会发生什么？"></a>已建立TCP连接，服务端进程奔溃会发生什么？</h2><blockquote>
<p>TCP的连接信息是内核进行维护的，进程奔溃之后，内核会回收TCP的资源。内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</p>
<p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
</blockquote>
<h2 id="向一个不存在的IP或者端口发起一个TCP连接会发生什么？"><a href="#向一个不存在的IP或者端口发起一个TCP连接会发生什么？" class="headerlink" title="向一个不存在的IP或者端口发起一个TCP连接会发生什么？"></a>向一个不存在的IP或者端口发起一个TCP连接会发生什么？</h2><p><strong>问题一：不存在的IP发起TCP连接</strong></p>
<blockquote>
<p>情况一：客户端和服务端在同一个局域网内<br>这种情况，不需要经过路由器转发，所以直接通过ARP协议询问目的IP的MAC地址，但是局域网内没有对应的IP导致，无法得到响应没有 MAC地址就无法封装MAC头，导致SYN消息没办法发出去。</p>
<p>情况二：客户端和服务端不在同一个局域网内<br>这种情况，需要通过路由器转发，会把SYN报文发给对饮的路由器，路由器会帮忙转发，但是由于无法找到目的IP，所以没办法得到SYN应答，客户端会重发SYN报文直到超过重试次数</p>
</blockquote>
<p><strong>问题二：不存在的端口发起TCP连接</strong></p>
<blockquote>
<p>相当于是服务端，没有进程监听这个端口所以没有目标会接收到这个SYN报文，内核会响应客户端一个RST报文，客户端收到RST报文之后就会释放连接</p>
</blockquote>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="ping的工作原理"><a href="#ping的工作原理" class="headerlink" title="ping的工作原理"></a>ping的工作原理</h2><blockquote>
<p>ping命令的作用是，判断目的主机是否可达。利用了ICMP协议实现，使用的是ICMP的回送请求报文，源主机构建ICMP报文，并且记录发送的时间，如果目的主机收到了，就会构建回送响应消息数据包，发还给源主机，这样源主机就可以判断目的IP是否可达，并且计算延迟。</p>
</blockquote>
<h2 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h2><blockquote>
<p>交换机工作在MAC层，负责数据帧的交换与转发，会根据MAC地址来转发数据包，实现局域网设备之间的通信。</p>
<p>路由器工作在网络层，负责IP数据报的路由和转发，会根据IP地址来转发数据报，实现不同网络之间的通信。</p>
</blockquote>
<h2 id="IP地址和MAC地址的区别"><a href="#IP地址和MAC地址的区别" class="headerlink" title="IP地址和MAC地址的区别"></a>IP地址和MAC地址的区别</h2><blockquote>
<p>IP地址用于在网络中唯一标识和定位设备，他是在网络层使用的地址，用于实现不同网络之间的通信。</p>
<p>MAC地址用于在局域网中唯一标识和定位设备，他是在数据链路层使用的地址，用于实现局域网内设备之间的通信。</p>
</blockquote>
<h2 id="NAT是什么协议？"><a href="#NAT是什么协议？" class="headerlink" title="NAT是什么协议？"></a>NAT是什么协议？</h2><blockquote>
<p>NAT协议的作用是让局域网内的主机能够和互联网别的主机进行通信。比较常见的做法就是端口转换，会<strong>将不同的私有ip+端口号的客户端，转换为共同共有ip+不同端口号</strong>的形式，这样的做法可以很好的节省公用的IP地址资源，因为多个内部设备可以共享一个IP地址</p>
</blockquote>
<h1 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h1><h2 id="DNS劫持是什么"><a href="#DNS劫持是什么" class="headerlink" title="DNS劫持是什么?"></a>DNS劫持是什么?</h2><blockquote>
<p>DNS劫持指的是，攻击者通过攻击DNS服务器，从而给用户提供错误的解析结果，从而拿到用户的真实数据。这种攻击手段利用的是，用户通过域名访问页面的时候，需要经过DNS解析得到域名IP这一过程。</p>
<p>解决方法就是可以通过更换DNS服务器，绕过被劫持的DNS服务器。</p>
</blockquote>
<h2 id="DNS污染是什么？"><a href="#DNS污染是什么？" class="headerlink" title="DNS污染是什么？"></a>DNS污染是什么？</h2><blockquote>
<p>DNS污染和DNS劫持很像，都是通过攻击DNS服务器，目的都是让用户收到虚假的DNS解析的IP结果。但是DNS劫持的范围一般比较大，是对整个DNS服务器都进行影响，让整个DNS服务器返回的都是错误的解析结果。而DNS污染范围一般比较小，是通过监听DNS服务器是否发起对某个IP的DNS查询请求，如果有就返回对这个IP的错误解析结果。</p>
</blockquote>
<h2 id="DDOS攻击是什么？如何预防"><a href="#DDOS攻击是什么？如何预防" class="headerlink" title="DDOS攻击是什么？如何预防"></a>DDOS攻击是什么？如何预防</h2><blockquote>
<p>DDOS全称是分布式服务拒绝攻击，通过大量的请求的服务器进行攻击，以占满服务器的CPU、带宽、内存等资源的攻击手段。</p>
<p>一般可以通过：</p>
<ul>
<li>流量清洗：对同一个IP的请求次数进行限制，对异常的IP进行限制</li>
<li>增加用户校验，比如人脸、验证码等方式。</li>
</ul>
</blockquote>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><blockquote>
<p>SQL注入其实就是通过拼接，植入恶意的SQL语句，比如说查询的时候加上OR 1&#x3D;1，这样后面的条件永远为真，就会把所有数据都返回，这样就造成了数据泄露。</p>
<p>解决方法：</p>
<p>首先可以在业务层面上加上参数判断，在后端对请求的参数进行校验，比如说条件只能是数字的时候，判断是否为整数，不是直接报错。</p>
<p>还可以使用正则校验 ，判断是否含有不合法的字符。</p>
<p>另外还有一个用的很多的是SQL层面的防止SQL注入的方式，就是SQL预处理。SQL预处理会先将要执行的SQL语句的模板交给SQL引擎，得到相应的执行计划，然后把请求的参数都按照参数的形式传给SQL执行器，这样OR 1&#x3D;1这样的参数也就只是一个普通的字符串，从而根本上解决SQL注入的问题。</p>
</blockquote>
<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><blockquote>
<p>XSS攻击是跨站点脚本攻击，主要是通过植入js脚本代码，如果服务器保存了，后面访问网站的时候，就会执行这些恶意代码，就可以获取到敏感信息。</p>
<p>解决方法：</p>
<ul>
<li>输入验证和过滤，过滤掉js的 <code>&lt;&gt;</code> 的代码。</li>
</ul>
</blockquote>
<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><blockquote>
<p>CSRF攻击是跨站点伪造请求攻击，核心是利用的Cookie和session id，用户在网站A进行了登录，如果开启了一个恶意网站B，恶意网站B发起对恶意网站A的请求，由于浏览器有网站A的cookie信息，恶意网站B就能够发起恶意请求。</p>
<p>解决方法：</p>
<ul>
<li>只接受同源请求</li>
<li>对于敏感操作增加验证</li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io">异梦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io/2022/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/">https://yimeng436.github.io/2022/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yimeng436.github.io" target="_blank">异梦的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></div><div class="post_share"><div class="social-share" data-image="/img/top.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/21/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="prev-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL面试题</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/21/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/19/%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-19</div><div class="title">计算机网络</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">异梦</div><div class="author-info__description">欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yimeng436" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2441844062@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8DOSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E3%80%81%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">介绍OSI七层网络模型、各层协议有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E5%92%8CTCP%E5%8D%8F%E8%AE%AE%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">IP协议和TCP协议属于哪一层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">输入网址后会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E7%9A%84%EF%BC%8C%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">DNS是如何解析的，属于哪一层协议？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">浏览器没有显示页面的原因？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84IP%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">TCP连接一个不存在的IP会出现什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">TCP连接一个错误的端口会出现什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFUDP%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AAIP%E5%AD%98%E5%9C%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%8A%A5%E6%96%87%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">客户端UDP发送一个IP存在端口不存在的报文会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP"><span class="toc-number">2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%86%E5%89%B2%E7%9A%84%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP报文的格式？怎么分割的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%E6%98%AF%E5%AE%89%E5%85%A8%E3%80%81%E5%B9%82%E7%AD%89%E7%9A%84"><span class="toc-number">2.2.</span> <span class="toc-text">HTTP哪些请求是安全、幂等的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FGET%E4%B8%80%E5%AE%9A%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">GET和POST的区别？GET一定保证幂等性吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%9C%89%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.4.</span> <span class="toc-text">HTTP有什么状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%98%AF%E5%93%AA%E4%B8%80%E7%B1%BB%E7%8A%B6%E6%80%81%E7%A0%81-%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">重定向是哪一类状态码?临时重定向和永久重定向有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-1%E5%92%8CHTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">HTTP1.1和HTTP2.0的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP2-0%E5%92%8CHTTP3-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text">HTTP2.0和HTTP3.0的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%94%A8%E6%88%B7%E5%90%8E%E7%BB%AD%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7-%E8%BF%BD%E9%97%AE-%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%99%A8%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">HTTP用户后续的操作，服务端如何知道属于同一个用户?追问:如果服务端是一个集群机器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">cookie和session的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.10.</span> <span class="toc-text">什么是跨域，什么情况下会发生跨域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTPS"><span class="toc-number">3.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%92%8CHTTP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">HTTPS和HTTP有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">有哪些加密算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">HTTPS建立连接的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E8%BF%87%E7%A8%8B%E7%BB%8F%E8%BF%87%E4%BA%86%E5%87%A0%E6%AC%A1%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">3.4.</span> <span class="toc-text">HTTPS过程经过了几次对称加密和非对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%9D%A5%E5%8A%A0%E5%AF%86HTTP%E6%8A%A5%E6%96%87"><span class="toc-number">3.5.</span> <span class="toc-text">HTTPS为什么不直接用非对称加密算法来加密HTTP报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E4%BC%9A%E5%AF%B9URL%E5%8A%A0%E5%AF%86%E5%90%97"><span class="toc-number">3.6.</span> <span class="toc-text">HTTPS会对URL加密吗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP"><span class="toc-number">4.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">TCP三次握手的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97"><span class="toc-number">4.2.</span> <span class="toc-text">为什么要三次握手，两次不行吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%8C%85%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">第二次握手出现丢包，会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%8C%85%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">第三次握手出现丢包，会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.5.</span> <span class="toc-text">TCP四次挥手的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E5%BC%80TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%B8%89%E6%AC%A1%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">断开TCP为什么要四次挥手，三次不可以吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89TIME-WAIT%E7%8A%B6%E6%80%81%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AE%E4%B8%BA2MSL"><span class="toc-number">4.7.</span> <span class="toc-text">为什么要有TIME_WAIT状态，并且为什么设置为2MSL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F%E7%9A%84TIME-WAIT%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.8.</span> <span class="toc-text">服务端出现大量的TIME_WAIT的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">4.9.</span> <span class="toc-text">TCP粘包拆包是什么原因？怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84keepalive%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E5%92%8CHTTP%E7%9A%84keepalive%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">TCP的keepalive了解吗？说说和HTTP的keepalive有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE%E7%94%A8%E7%9A%84%E6%98%AFUDP%E8%BF%98%E6%98%AFTCP%EF%BC%8CUDP%E4%B8%A2%E5%8C%85%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">视频会议用的是UDP还是TCP，UDP丢包会出现什么现象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E6%80%8E%E4%B9%88%E6%94%B9%E9%80%A0%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">UDP怎么改造成为一个可靠的传输？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">TCP和UDP可以使用同一个端口吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.15.</span> <span class="toc-text">TCP是怎么保证可靠性的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.16.</span> <span class="toc-text">流量控制和拥塞控制有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">滑动窗口是怎么设计的，解决了什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">4.18.</span> <span class="toc-text">拥塞控制是怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%9A%E8%83%BD%E5%BB%BA%E7%AB%8B%E5%A4%9A%E5%B0%91%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">4.19.</span> <span class="toc-text">一个服务端进程最多能建立多少个TCP连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%80%E5%A4%9A%E8%83%BD%E8%BF%9E%E6%8E%A5%E5%A4%9A%E5%B0%91TCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">4.20.</span> <span class="toc-text">一台服务器最多能连接多少TCP连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%96%AD%E7%94%B5%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.21.</span> <span class="toc-text">已经建立TCP连接，服务端断电了会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%B2%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E7%A8%8B%E5%A5%94%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.22.</span> <span class="toc-text">已建立TCP连接，服务端进程奔溃会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84IP%E6%88%96%E8%80%85%E7%AB%AF%E5%8F%A3%E5%8F%91%E8%B5%B7%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.23.</span> <span class="toc-text">向一个不存在的IP或者端口发起一个TCP连接会发生什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">ping的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">路由器和交换机的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E5%92%8CMAC%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">IP地址和MAC地址的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NAT%E6%98%AF%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">NAT是什么协议？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="toc-number">6.</span> <span class="toc-text">网络攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.</span> <span class="toc-text">DNS劫持是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E6%B1%A1%E6%9F%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">DNS污染是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DDOS%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2"><span class="toc-number">6.3.</span> <span class="toc-text">DDOS攻击是什么？如何预防</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">6.4.</span> <span class="toc-text">SQL注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS%E6%94%BB%E5%87%BB"><span class="toc-number">6.5.</span> <span class="toc-text">XSS攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF%E6%94%BB%E5%87%BB"><span class="toc-number">6.6.</span> <span class="toc-text">CSRF攻击</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="MySQL原理"/></a><div class="content"><a class="title" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理">MySQL原理</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="算法笔记"/></a><div class="content"><a class="title" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记">算法笔记</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="前端知识"/></a><div class="content"><a class="title" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识">前端知识</a><time datetime="2023-06-05T16:00:00.000Z" title="发表于 2023-06-06 00:00:00">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="FSAF论文"/></a><div class="content"><a class="title" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文">FSAF论文</a><time datetime="2022-10-13T16:00:00.000Z" title="发表于 2022-10-14 00:00:00">2022-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="Faster-RCNN论文"/></a><div class="content"><a class="title" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文">Faster-RCNN论文</a><time datetime="2022-08-24T16:00:00.000Z" title="发表于 2022-08-25 00:00:00">2022-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 异梦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>