<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL面试题 | 异梦的博客</title><meta name="keywords" content="MySQL"><meta name="author" content="异梦"><meta name="copyright" content="异梦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL常见面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL面试题">
<meta property="og:url" content="https://yimeng436.github.io/2022/08/21/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="异梦的博客">
<meta property="og:description" content="MySQL常见面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yimeng436.github.io/img/top.png">
<meta property="article:published_time" content="2022-08-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-21T08:27:00.018Z">
<meta property="article:author" content="异梦">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yimeng436.github.io/img/top.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yimeng436.github.io/2022/08/21/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-21 16:27:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">异梦的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-20T16:00:00.000Z" title="发表于 2022-08-21 00:00:00">2022-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-21T08:27:00.018Z" title="更新于 2024-01-21 16:27:00">2024-01-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="一条SQL的执行过程"><a href="#一条SQL的执行过程" class="headerlink" title="一条SQL的执行过程"></a>一条SQL的执行过程</h2><p>MySQL是典型的CS架构的模型，主要可以分为三层：连接层、服务层、引擎层。无论用户以什么形式发送请求，都是连接层处理建立连接；服务层分析优化；引擎层执行调用文件系统进行操作，返回给用户。</p>
<p>具体流程如下：</p>
<blockquote>
<p>1、连接层：接收请求并且建立连接，解析出SQL语句</p>
<p>2、SQL语句查询缓存，如果命中直接返回</p>
<p>3、未命中则将SQL语句交给服务层</p>
<p>4、服务层的解析器会对SQL语句进行词法语法分析，会识别出哪些是表哪些是条件，最后得到一个语法树，如果语法或者词法出错，在这里就会被检查出来抛出异常。</p>
<p>5、通过词法和语法检查之后，服务层的优化器会对这个SQL确定一个最佳的执行计划，包括是否使用索引，用哪个索引，最后会生成一个执行计划。</p>
<p>6、有执行计划之后，服务层的执行器会根据这个执行计划，调用引擎层的一个个接口，存储引擎去调用文件系统，获取数据返回给用户。</p>
</blockquote>
<h2 id="MySQL有哪些存储引擎"><a href="#MySQL有哪些存储引擎" class="headerlink" title="MySQL有哪些存储引擎"></a>MySQL有哪些存储引擎</h2><blockquote>
<p>主要有：MyISAM、InnoDB、Memory。</p>
<p>MyISAM：不支持事务，不支持行锁，只有表锁，适合用于读多写少的情况，无日志服务</p>
<p>InnoDB：MySQL默认的引擎，支持行锁、事务，有日志服务。</p>
<p>Memory：速度快，大部分都在内存中完成，没有持久化功能，适用于临时存储</p>
</blockquote>
<h2 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h2><blockquote>
<p>InnoDB是MySQL默认的数据库引擎，优点是支持行级锁和事务，这些都是MyISAM不支持的，除了这些以外</p>
<ul>
<li>InnoDB还支持日志服务，提供容灾恢复，相比于MyISAM它不支持日志服务。</li>
<li>InnoDB支持聚簇索引，MyISAM只有非聚簇索引。</li>
<li>InnoDB支持外键，MyISAM不支持外键约束</li>
</ul>
</blockquote>
<h2 id="count-哪个引擎快"><a href="#count-哪个引擎快" class="headerlink" title="count(*)哪个引擎快"></a>count(*)哪个引擎快</h2><blockquote>
<p>如果只是单纯的count(*)，MyISAM一定最快，因为MyISAM有一个元数据就保存的是一张表的数据条数，而对于InnoDB，由于它支持事务，并且还有MVCC机制，不同的事务期间能够看到的数据量可能是不同的，所以没有设置这样的元数据保存一张表的数据条数。</p>
<p>InnoDB执行count(*)的过程，会维护一个count变量，循环遍历每次读取到一条数据就会对这个count++，时间复杂度是O(n)的，所以执行速度一定没有MyISAM快。</p>
<p>如果执行的语句带有 where条件，两者的执行情况是一样的，都需要遍历每条数据。</p>
</blockquote>
<h2 id="NULL值是怎么存储的"><a href="#NULL值是怎么存储的" class="headerlink" title="NULL值是怎么存储的"></a>NULL值是怎么存储的</h2><blockquote>
<p>不同的存储引擎行格式是不一样的，以InnoDB为例，InnoDB支持的几种行格式，大多都是以Compact格式为基础的，Compact格式存储的内容包括两部分，一部分是记录的额外信息，还有一部分是真实信息。NULL值就存在记录的额外信息里面。</p>
<p>记录额外信息包括：可变长字段的长度、NULL值、记录头信息。在一行记录中如果存在允许为NULL值的列，那么每一列就会对应一个二进制位，用0代表不为NULL，1代表不为NULL这样的形式逆序存放每一列的NULL值情况。</p>
</blockquote>
<h2 id="char和varchar有什么区别"><a href="#char和varchar有什么区别" class="headerlink" title="char和varchar有什么区别"></a>char和varchar有什么区别</h2><blockquote>
<p>char是定长字符串，varchar是变长字符串。</p>
<p>对于char来说，如果存储的字符串没有达到定义的长度，那么就会用空格去填充。而varchar则不会，varchar的真实长度会用1-2个字节的大小保存在行结构的变长字段长度的位置，所以相比于char来说一行会多使用1-2个字节的大小。</p>
<p>对于超出定义的长度的字符串，char会直接报错，而varchar会判断如果超过部分全是空格会进行截断，否则报错。</p>
</blockquote>
<h2 id="假如说一个字段是varchar-10-，但它其实只有6个字节，那他在内存中占的存储空间是多少-在文件中占的存储空间是多少"><a href="#假如说一个字段是varchar-10-，但它其实只有6个字节，那他在内存中占的存储空间是多少-在文件中占的存储空间是多少" class="headerlink" title="假如说一个字段是varchar(10)，但它其实只有6个字节，那他在内存中占的存储空间是多少?在文件中占的存储空间是多少?"></a>假如说一个字段是varchar(10)，但它其实只有6个字节，那他在内存中占的存储空间是多少?在文件中占的存储空间是多少?</h2><blockquote>
<p>varchar(10)表示可以存储的最大字符的格式是10，在加载到内存空间的时候会按照最大值进行分配也就是10，实际又只占用6个字节，在InnoDB引擎下，会用1-2个字节去存储变长字段的真实值，所以在文件系统中存储的空间就是7-8字节。</p>
</blockquote>
<h2 id="普通索引和唯一索引有什么区别-哪个更新性能更好"><a href="#普通索引和唯一索引有什么区别-哪个更新性能更好" class="headerlink" title="普通索引和唯一索引有什么区别?哪个更新性能更好?"></a>普通索引和唯一索引有什么区别?哪个更新性能更好?</h2><blockquote>
<p>普通索引没有唯一性约束，唯一索引会保证列的值是唯一的，所以每次插入的时候需要校验唯一性，所以性能上唯一索引较差。</p>
</blockquote>
<h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><h2 id="MySQL有哪些索引类型"><a href="#MySQL有哪些索引类型" class="headerlink" title="MySQL有哪些索引类型?"></a>MySQL有哪些索引类型?</h2><blockquote>
<p>按照数据类型来分的话包括：B+树索引、Hash索引、全文索引。</p>
<p>按照物理存储来分的话包括：聚簇索引、非聚簇索引。</p>
<p>按照字段特性来分包括：唯一索引、普通索引、前缀索引。</p>
<p>按照字段个数来分包括：单列索引、聚合索引。</p>
</blockquote>
<h2 id="InnoDB的索引是什么数据结构"><a href="#InnoDB的索引是什么数据结构" class="headerlink" title="InnoDB的索引是什么数据结构"></a>InnoDB的索引是什么数据结构</h2><blockquote>
<p>InnoDB的索引结构式B+树结构，索引和数据一起存储，非叶子节点只存储索引，叶子节点存储索引和数据。</p>
</blockquote>
<h2 id="为什么MySQL索引使用B-树？"><a href="#为什么MySQL索引使用B-树？" class="headerlink" title="为什么MySQL索引使用B+树？"></a>为什么MySQL索引使用B+树？</h2><blockquote>
<p>首先，索引的目的肯定是为了加快查询速度。而对于查询肯定是希望数据是有序的，从而可以使用二分进行查找。</p>
<p>所以如果使用数组进行存储，要保证数据有序的话，每次插入和删除的复杂度都是O(n)，这个开销还是比较大的。</p>
<p>使用树形结构进行存储的话，需要满足有序性的话就是二叉排序树，但是二叉排序树在极端的情况下会退化成链表，查询的复杂度会变成O(n)，这个性能也不够好。</p>
<p>如果使用平衡二叉树(或者红黑树)，反正就是让二叉树能够满足有序性的情况下，尽可能高度平衡，使得每次查询的时间复杂度能够稳定在O(log n)。但是一个节点只能有两个子节点的结构会使得，树长高的速度太快，高度变得很高之后对查询速度的影响也是非常大的。</p>
<p>所以考虑使用多叉树首先就是B树，B树比较好的解决了二叉树在数据变大的时候变得非常的高的问题，但是B树还有一个问题就是，B树非叶子节点保存的也会有数据，所以用B树存储数据的话存储成本会很高，另外在查询的时候，每次读入一个非叶节点需要把整页数据读入内存，非叶节点如果包含数据的话也会使得IO成本比较高。</p>
<p>相比于B树，B+树的优点在于非叶子节点只会保存索引，只有在叶子节点才会保存数据，所以在遍历的时候只会把索引读入内存，所以IO的开销比B树也会小很多，除此之外非叶子节点只保存索引，就可以在同样的数据页保存更多的索引。还有一个很重要的就是MySQL也比较经常使用范围查询，B+树的叶子节点之间有链表进行连接，这样的设计对于范围查询非常有帮助，而B树范围查询只能通过中序遍历得到，所以B+树是最好的数据结构，所以MySQL采用B+树存储索引数据。</p>
</blockquote>
<h2 id="MySQL为什么不使用哈希表？"><a href="#MySQL为什么不使用哈希表？" class="headerlink" title="MySQL为什么不使用哈希表？"></a>MySQL为什么不使用哈希表？</h2><blockquote>
<p>虽然哈希表在查询的时候能够达到将近O(1)的时间复杂度，但是MySQL经常要使用到范围查询，哈希表对于范围查询的支持度不高，如果要加入排序的话就会引入额外的开销。随着数据增加哈希表可能会出现大量的哈希冲突，也会影响查询的效率。</p>
<p>而B+树能够很好的解决上面的问题，因此不适用哈希表是，使用了B+树作为索引。</p>
</blockquote>
<h2 id="聚簇索引和非聚簇索引有什么区别"><a href="#聚簇索引和非聚簇索引有什么区别" class="headerlink" title="聚簇索引和非聚簇索引有什么区别"></a>聚簇索引和非聚簇索引有什么区别</h2><blockquote>
<p>聚簇索引是InnoDB才支持的一种索引，聚簇索引是主键生成的索引，一张表有且只有一个聚簇索引。这是MySQL自动会创建的一个索引。聚簇索引在B+树中，叶子节点会保存索引和数据。</p>
<p>非聚簇索引是用户通过指令创建的索引，一个表可以有很多非聚簇索引。非聚簇索引在B+树的叶子节点只会保存主键ID和索引列的值。</p>
<p> 查询的时候用非聚簇索引查询的时候只会查询出行数据的主键ID，需要通过回表， 用ID去聚簇索引中查询完整的行数据。</p>
</blockquote>
<h2 id="insert-到B-树会对B-树的结构有什么影响"><a href="#insert-到B-树会对B-树的结构有什么影响" class="headerlink" title="insert 到B+树会对B+树的结构有什么影响"></a>insert 到B+树会对B+树的结构有什么影响</h2><blockquote>
<p>对于主键Id来说，最好是递增的，因为不是递增的ID主键的话会造成B+树经常进行分裂操作，不仅影响性能，对于空间利用率也会降低。</p>
<p>如果主键是自增的话，插入的数据时候对于B+树每次都是追加操作，只有当一个节点满了之后才会分裂。</p>
<p>相反如果不是有序的话，插入时候主键可能插入到了现有数据页的某个位置，如果这个数据页满了，就会发生页分裂，这时就需要从一个数据页复制到另外一个页面，页分裂会导致大量的内存碎片，从而影响效率。</p>
</blockquote>
<h2 id="两千万条数据的MySQL，会有多高的B-树"><a href="#两千万条数据的MySQL，会有多高的B-树" class="headerlink" title="两千万条数据的MySQL，会有多高的B+树"></a>两千万条数据的MySQL，会有多高的B+树</h2><blockquote>
<p>一个数据页16KB，假设一个数据也可以存100条数据，1000条索引。</p>
<p>B+树高为1的时候，就全是数据+索引，所以可以存100条数据。</p>
<p>B+树高为2的时候，第一层是索引，有1000条索引，对应1000个数据页，每个数据页可以存100条数据，所以高度为2的时候，可以存1000X100条数据，也就是10W条数据。</p>
<p>B+树高为3的时候，前两层都是索引，所以有1000X1000的索引，也就是100W个数据页，每个数据页可以存100条数据，就有1亿条数据，所以高度为3的时候能够存1亿条数据了。</p>
<p>所以两千万条数据最多只会有3层的B+树。</p>
</blockquote>
<h1 id="索引应用"><a href="#索引应用" class="headerlink" title="索引应用"></a>索引应用</h1><h2 id="为什么要建立索引"><a href="#为什么要建立索引" class="headerlink" title="为什么要建立索引"></a>为什么要建立索引</h2><blockquote>
<p>加快查询速度。对于全表扫描来说，复杂度是O(n)，每个查询都要遍历整个表，而构建了索引，会在B+树上进行查询，查询的次数只会O(log h)，而B+树的高度一般不会超过4，也就是对比的次数不会超过4次，极大的优化的查询的时间。</p>
<p>并且索引可以确保索引列是有序的，所以在排序的时候可以避免排序，可以优化排序的开销。</p>
</blockquote>
<h2 id="选择哪些字段建立索引"><a href="#选择哪些字段建立索引" class="headerlink" title="选择哪些字段建立索引"></a>选择哪些字段建立索引</h2><blockquote>
<ul>
<li>经常被用作where查询的字段建立索引</li>
<li>经常用作排序的字段可以建立索引</li>
<li>对于部分字段需要全局唯一的，需要使用的唯一索引</li>
</ul>
</blockquote>
<h2 id="索引是越多越好吗"><a href="#索引是越多越好吗" class="headerlink" title="索引是越多越好吗"></a>索引是越多越好吗</h2><blockquote>
<p>肯定不是，索引也需要存放在磁盘上，索引越多越占磁盘空间。除此之外所以会导致数据库写入的效率变差。</p>
</blockquote>
<h2 id="索引怎么优化"><a href="#索引怎么优化" class="headerlink" title="索引怎么优化"></a>索引怎么优化</h2><blockquote>
<p>MySQL自己有一个索引下推的优化。</p>
<p>避免写会出现索引失效的SQL</p>
<p>对于聚合索引，尽量让索引能够覆盖，减少回表</p>
<p>对于主键最好使用递增的主键，减少B+树页分裂</p>
</blockquote>
<h2 id="建立的索引一定会用到吗"><a href="#建立的索引一定会用到吗" class="headerlink" title="建立的索引一定会用到吗"></a>建立的索引一定会用到吗</h2><blockquote>
<p>不会。优化器不一定会选择使用索引，优化器根据查询成本确定是否使用索引执行这条SQL。</p>
<p>此外还有可能用户编写的SQL语句会出现索引失效的情况，这些情况都不会使用到索引。</p>
</blockquote>
<h2 id="什么是最左匹配原则"><a href="#什么是最左匹配原则" class="headerlink" title="什么是最左匹配原则"></a>什么是最左匹配原则</h2><blockquote>
<p>最左匹配原则是在联合索引情况下，在查询的时候会从左到右依次匹配索引，当匹配到第一个无法使用索引的条件之后，后面的条件都无法使用索引。</p>
<p>就比如说构建了（a，b，c）联合索引，使用where a&#x3D;? and b&#x3D;?的时候都可以走索引查询。而如果是where b&#x3D;? and c&#x3D;? 就无法使用索引查询。</p>
</blockquote>
<h2 id="联合索引-a-b-c-，下面的查询语句会不会走索引-如果走具体是哪些字段能走"><a href="#联合索引-a-b-c-，下面的查询语句会不会走索引-如果走具体是哪些字段能走" class="headerlink" title="联合索引(a,b,c)，下面的查询语句会不会走索引?如果走具体是哪些字段能走?"></a>联合索引(a,b,c)，下面的查询语句会不会走索引?如果走具体是哪些字段能走?</h2><ul>
<li>select * from T where a&#x3D;1 and b&#x3D;2 and c&#x3D;3;</li>
</ul>
<blockquote>
<p>a、b、c都可以走索引</p>
</blockquote>
<ul>
<li>select * from T where a&#x3D;1 and b&gt;2 and c&#x3D;3;</li>
</ul>
<blockquote>
<p>a、b可以走索引，c不能走索引，但是c可以走索引下推</p>
</blockquote>
<ul>
<li>select * from T where c&#x3D;1 and a&#x3D;2 and b&#x3D;3;</li>
</ul>
<blockquote>
<p>优化器会有对这个SQL进行条件排序优化，变成可使用索引的，这个也是a、b、c都可以走索引</p>
</blockquote>
<ul>
<li>select * from T where a&#x3D;2 and c&#x3D;3;</li>
</ul>
<blockquote>
<p>a可以走索引、c不能走索引，但是可以走索引下推</p>
</blockquote>
<ul>
<li>select * from T where b&#x3D;2 and c&#x3D;3;</li>
</ul>
<blockquote>
<p>不能走索引</p>
</blockquote>
<ul>
<li>select (a,b) from T where a&#x3D;1 and b&gt;2</li>
</ul>
<blockquote>
<p>a、b都可以走索引</p>
</blockquote>
<h2 id="where-a-gt-1-and-b-x3D-2-and-c-lt-3怎么建立索引"><a href="#where-a-gt-1-and-b-x3D-2-and-c-lt-3怎么建立索引" class="headerlink" title="where a&gt;1 and b &#x3D; 2 and c&lt;3怎么建立索引?"></a>where a&gt;1 and b &#x3D; 2 and c&lt;3怎么建立索引?</h2><p>首先范围查询后面的查询是无法使用索引的，所以会等值查询应该尽量靠左。</p>
<blockquote>
<p>构建(b,a,c)索引，这样构建索引b、a都可以走索引，c不能走索引但是可以走索引下推。</p>
<p>构建(b,c,a)索引，这样构建索引b、c都可以走索引，a不能走索引但是可以走索引下推。</p>
</blockquote>
<h2 id="where-a-gt-100-and-b-x3D-100-and-c-x3D-123-order-by-d怎么建立联合索引"><a href="#where-a-gt-100-and-b-x3D-100-and-c-x3D-123-order-by-d怎么建立联合索引" class="headerlink" title="where a&gt;100 and b&#x3D;100 and c&#x3D;123 order by d怎么建立联合索引?"></a>where a&gt;100 and b&#x3D;100 and c&#x3D;123 order by d怎么建立联合索引?</h2><blockquote>
<p>如果构建 （bcad）索引：</p>
<p>bca都是可以走索引的，看着确实很不错，但是d走不了索引，而且d是要排序的字段，可能会触发外部排序，所以性能不会很好。</p>
<p>如果构建（bcda）索引：</p>
<p>b、c的等值查询，所以d也是有序的，所以d也能走索引，a不能走索引，但是可以走索引下推，而且也不会出现外部排序这种大开销的操作。</p>
<p>综上，构建bcda索引更好。</p>
</blockquote>
<h2 id="select-id-name-from-XX-where-age-gt-10-and-name-like’xx-’，有联合索引-name-age-，说一下查询过程"><a href="#select-id-name-from-XX-where-age-gt-10-and-name-like’xx-’，有联合索引-name-age-，说一下查询过程" class="headerlink" title="select id, name from XX where age &gt;10 and name like’xx%’，有联合索引(name,age)，说一下查询过程"></a>select id, name from XX where age &gt;10 and name like’xx%’，有联合索引(name,age)，说一下查询过程</h2><blockquote>
<p>由于有 name  age联合索引，并且name是右模糊查询，所以name字段是可以走索引的，但是模糊查询之后的查询是没办法走索引的，但是可以走索引下推。并且查询的列满足索引覆盖，所以不会有回表操作，直接返回给用户。</p>
</blockquote>
<h2 id="如果我定义了一个varchar类型的日期字段，并且有一个数据是-96-20230922’，如果这个日期字段上有索引，那如果我查询的wher条件是where-time-x3D-20230922不加单引号，还会命中索引吗-为什么"><a href="#如果我定义了一个varchar类型的日期字段，并且有一个数据是-96-20230922’，如果这个日期字段上有索引，那如果我查询的wher条件是where-time-x3D-20230922不加单引号，还会命中索引吗-为什么" class="headerlink" title="如果我定义了一个varchar类型的日期字段，并且有一个数据是&#96;20230922’，如果这个日期字段上有索引，那如果我查询的wher条件是where time&#x3D;20230922不加单引号，还会命中索引吗?为什么?"></a>如果我定义了一个varchar类型的日期字段，并且有一个数据是&#96;20230922’，如果这个日期字段上有索引，那如果我查询的wher条件是where time&#x3D;20230922不加单引号，还会命中索引吗?为什么?</h2><p>首先要了解常见的索引失效的场景：</p>
<ul>
<li>like模糊查询的前缀模糊查询索引会失效  “%A”</li>
<li>查询使用表达式索引会失效，where a+1&#x3D;2</li>
<li>查询时候在索引字段上使用函数会失效</li>
<li>where 里面有 or</li>
<li>隐式类型转换可能会造成所以</li>
</ul>
<blockquote>
<p>题目中问的查询显然要进行隐式类型转换，数据库中定义的类型是字符串类型的，查询的是数字类型的。所以问题就在于MySQL遇到字符串和数字的比较的时候，是将字符串转为数字还是将数字转为字符串。</p>
<p>如果是数字转为字符串，那其实这个语句相当于是where time&#x3D;CAST(20230922….)，那这样的话就不会出现索引失效，因为函数没有加载索引列上。</p>
<p>如果字符串转为数字，那其实这个语句相当于是where CAST(time as int)&#x3D;20230922，这样的情况显然是会出现索引失效的。</p>
<p>那要确定MySQL是如何操作的只需要，通过一条语句就能知道答案：select “10”&gt;9，如果是字符串转数字，那结果就是1，因为10&gt;9。如果是数字转字符串，就是用”10”和”9”进行比较，从高到底比较ascii码，”1”&lt;”9”的结果就是0。</p>
<p>实验的结果是1，所以说明MySQL遇到字符串和数字比较的时候是把字符串转为数字，那就说明这个查询会出现索引失效。</p>
</blockquote>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><blockquote>
<p>ACID</p>
<p>A：原子性，事务内的操作要么全都成功要么全都失败，通过undo log实现</p>
<p>C：一致性，事务的最终目的，事务执行前后的合法状态是一致的，比如说转账前后总金额不变</p>
<p>I：隔离性：事务之间不会相互影响，由锁和MVCC机制实现</p>
<p>D：持久性：事务一旦提交对数据的影响就是永久的，不会因为数据库宕机而丢失。通过redo log实现</p>
</blockquote>
<h2 id="事务的原子性如何保证"><a href="#事务的原子性如何保证" class="headerlink" title="事务的原子性如何保证"></a>事务的原子性如何保证</h2><blockquote>
<p>原子性主要通过undo log来保证，每次对数据库的修改操作，undo log 都会记录它的逆操作，比如插入一条数据，就会记录删除这条数据。修改了一个数据，会记录修改这个数据回原数据。</p>
<p>当事务执行的时候出现了异常，MySQL就会利用undo log恢复到原始状态。</p>
</blockquote>
<h2 id="事务的持久性如何保证"><a href="#事务的持久性如何保证" class="headerlink" title="事务的持久性如何保证"></a>事务的持久性如何保证</h2><blockquote>
<p>持久性是通过redo log来实现的。redo log会保存事务提交后对数据页做了哪些修改，由于修改都是在内存的Buffer pool内完成的，所以需要redo log来进行持久化。并且MySQL会通过WAL机制来记录数据修改和日志修改，WAL机制就是修改数据之前先修改redo log日志，只要redo log日志写入成功数据就能够保证不会丢失。</p>
</blockquote>
<h2 id="事务的隔离性如何保证"><a href="#事务的隔离性如何保证" class="headerlink" title="事务的隔离性如何保证"></a>事务的隔离性如何保证</h2><blockquote>
<p>隔离性主要是通过锁和MVCC机制实现的。</p>
</blockquote>
<h2 id="事务的一致性如何保证"><a href="#事务的一致性如何保证" class="headerlink" title="事务的一致性如何保证"></a>事务的一致性如何保证</h2><blockquote>
<p>事务的一致性是事务的目的，他是通过原子性、持久性、隔离性共同保证的，做好了这三个一致性就得到了保证。</p>
</blockquote>
<h2 id="并发事务会出现哪些问题"><a href="#并发事务会出现哪些问题" class="headerlink" title="并发事务会出现哪些问题"></a>并发事务会出现哪些问题</h2><blockquote>
<p>脏读：一个事务读取到了，另一个未提交事务对数据库的修改，但是这个事务后面回滚了，导致读取到了修改后的数据。</p>
<p>不可重复读：一个事务在执行 期间，两次对同一个数据的读取不一致</p>
<p>幻读：一个事务期间两次查询的结果数量不一致</p>
</blockquote>
<h2 id="事务的隔离级别有哪些，解决了哪些问题"><a href="#事务的隔离级别有哪些，解决了哪些问题" class="headerlink" title="事务的隔离级别有哪些，解决了哪些问题"></a>事务的隔离级别有哪些，解决了哪些问题</h2><blockquote>
<p>读未提交：最低的隔离级别，会出现脏读、不可重复读、幻读</p>
<p>读已提交：不会出现脏读，但是会出现不可重复读、幻读</p>
<p>可重复读：还会出现幻读</p>
<p>可串行化：几乎没有并发能力，事务之间串行执行，可以解决幻读</p>
</blockquote>
<h2 id="介绍一个MVCC"><a href="#介绍一个MVCC" class="headerlink" title="介绍一个MVCC"></a>介绍一个MVCC</h2><blockquote>
<p>MVCC全称多版本并发控制，通过undo log 版本链和read view 实现。通过这个机制来控制哪些数据对当前事务可见。</p>
<p>每次对数据库的修改后的数据都会通过undo log 版本链的形式进行组织，undo log版本链主要会记录修改当前数据的事务id，以及指向上一个版本的数据的指针。</p>
<p>read view就是事务在执行查询的时候，会生成的一个数据结构，这个数据结构会记录当前的事务id、MySQL的全局活跃事务id，当前MySQL中最大的事务id和最小事务id。查询的时候根据这些事务id，和undo log版本链记录的修改数据的事务id进行对比，从而判断这个版本的数据对当前事务是否可见，可见就可以读取，否则一直通过指针找到第一个可见的数据版本。</p>
<p>通过MVCC机制在事务读写并发的时候可以避免频繁加锁，极大的提高了MySQL的性能。</p>
</blockquote>
<h2 id="MVCC如何判断记录对某一事务是否可见"><a href="#MVCC如何判断记录对某一事务是否可见" class="headerlink" title="MVCC如何判断记录对某一事务是否可见"></a>MVCC如何判断记录对某一事务是否可见</h2><blockquote>
<p>首先在不同的隔离级别下，数据对事务的可见性是不太相同的，主要是因为生成read view的方式有所不同。在读已提交隔离级别下：每个select 都会创建一个新的read view；而在不可重复读的情况下，一个事务只会在第一个select 生成read view，后面的查询都公用这个read view。</p>
<p>read view 会保存的信息有：当前事务的id，创建read view的时候MySQL全局事务状态的一下信息：当前活跃的事务id列表，全局最大事务id，全局最小的活跃事务id。</p>
<p>对于每条记录它的undo log版本链包括的信息有：修改当前版本的事务id，指向上一个版本的数据的指针。</p>
<p>当一个事务进行查询的时候，先创建read view，然对比undo log 版本链的数据的事务id：</p>
<ul>
<li>如果修改数据的id等于创建read view 的id就可以读取这个版本的数据</li>
<li>如果修改数据的事务id大于read view的全局最大事务id，表示当前这个修改是在当前事务查询之后提交的，所以当前数据对事务不可见</li>
<li>如果修改数据的事务id小于read view的最小事务id，那么说明修改这条记录的事务在当前事务查询之前就已经提交，对当前事务可见。</li>
<li>如果修改数据的事务id在min和max事务id之间，就去判断这个修改数据的事务id是否在read view的活跃事务列表中：<ul>
<li>如果是，表示修改这个数据的事务还没有提交，不可见</li>
<li>否则，表示事务已经提交，数据可见</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="读已提交和可重复读的MVCC机制实现有什么区别"><a href="#读已提交和可重复读的MVCC机制实现有什么区别" class="headerlink" title="读已提交和可重复读的MVCC机制实现有什么区别"></a>读已提交和可重复读的MVCC机制实现有什么区别</h2><blockquote>
<p>主要的区别就是在创建read view的时机上有所不同。</p>
<p>读已提交：事务的每个select 都会创建一个新的read view，这就有可能前一个read view修改数据的事务还没有提交，后面的select 的时候修改事务已经提交，后面的select创建read view的时候就可能会可以读取到事务修改后的数据，导致出现了不可重复读。</p>
<p>可重复读：事务只会在第一个select 的时候创建read view，后面的查询都复用这个read view，所以能够解决不可重复读。</p>
</blockquote>
<h2 id="为什么互联网公司用读已提交的隔离级别"><a href="#为什么互联网公司用读已提交的隔离级别" class="headerlink" title="为什么互联网公司用读已提交的隔离级别"></a>为什么互联网公司用读已提交的隔离级别</h2><blockquote>
<p>四个隔离级别，读未提交和可串行化这两个太过极端肯定是不会去使用的。那么主要就是从读已提交和可重复读两个隔离级别进行选择。</p>
<p>读已提交相比于可重复读，读已提交的并发度比可重复读来的高，互联网公司对于并发度的要求会更高。此外比较重要的是可重复读隔离级别会加间隙锁，间隙锁的出现让MySQL死锁的概率变得比没有间隙锁大。主要原因就是间隙锁之间是互相兼容的，没存在独占锁和共享锁。这就导致了只要两个事务同时获得了相同间隙的锁，并且后面的需要对同一间隙的内容进行插入就会出现死锁。所以为了降低死锁的概率和并发度一般互联网项目一般使用读已提交。</p>
<p>虽然读已提交没办法解决不可重复读，但是其实这个数据事务也是提交了的，所以读出来对整体影响不会特别大。</p>
</blockquote>
<h2 id="可重复读解决了什么问题？有没有完全解决幻读？"><a href="#可重复读解决了什么问题？有没有完全解决幻读？" class="headerlink" title="可重复读解决了什么问题？有没有完全解决幻读？"></a>可重复读解决了什么问题？有没有完全解决幻读？</h2><blockquote>
<p>可重复读主要是解决了不可重复读的问题，通过间隙锁，解决了一部分幻读的情况。但是在特定的情况下幻读还是会发生。</p>
</blockquote>
<h2 id="追问什么时候会发生幻读"><a href="#追问什么时候会发生幻读" class="headerlink" title="追问什么时候会发生幻读"></a>追问什么时候会发生幻读</h2><blockquote>
<p>一种情况是查询、更新一条不存在的数据、再次查询时就会出现幻读：</p>
<p>事务A先当前读一条不存在的数据；事务B插入这条数据并且提交；事务A在B提交之后，修改这条id为5的数据，由于update不受到MVCC机制的保护，undo log版本链的第一条数据就变成了当前事务的id，根据MVCC判断数据是否可见的规则，这个修改后的数据是对事务A可见的，所以再下一次查询的时候就出现了这条数据。</p>
<p>另一种情况是，快照读和当前读混合使用的时候会出现：</p>
<p>事务A用快照查询id大于10的记录；事务B插入一条id大于10的记录；然后事务A使用同样的条件，当前读这些数据就会出现事务B刚刚插入的那些数据，所以为了保证一致性，当前读和快照读一般不建议在一个事务中一起使用。（这种情况也会可能会出现不可重复度的情况，事务B把插入改成修改）</p>
</blockquote>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><blockquote>
<p>表锁：修改表结构的meta lock、自增数据的自增锁；</p>
<p>行锁：record lock、gap lock、next-key lock、意向锁（回答的时候可以说一下目前只有InnoDB实现了行级锁）</p>
</blockquote>
<h2 id="线上修改表结构会发生什么？"><a href="#线上修改表结构会发生什么？" class="headerlink" title="线上修改表结构会发生什么？"></a>线上修改表结构会发生什么？</h2><p>这个问题，想考察的是MDL锁，首先要知道MDL锁有MDL读锁和MDL写锁。MDL不需要显示的加上锁，在执行CURD的时候自动会加上一个MDL读锁，在执行修改表结构语句的时候会加上MDL写锁。这个锁的互斥规则和普通的读写锁规则也是一样的。不仅仅是表结构，增加索引一样需要请求MDL写锁。</p>
<blockquote>
<p>首先在一个事务执行修改表结构的时候，会先去获取MDL写锁，如果此时有一个select 语句还在执行或者一个有select的事务还在执行，都是会持有MDL的读锁的，此时MDL事务就无法执行修改的语句会阻塞。一直等到事务释放了MDL读锁才会执行。</p>
<p>但是MDL写锁一旦被阻塞，由于在阻塞队列中写锁的优先级会高于读锁（不这样的话写锁线程会被饿死，通常来说读操作的会比写操作高好几个数量级），那么后续如果有select语句到来都会被阻塞。所以如果在线上修改表结构，会出现整个表无法继续执行后续的任何CURD操作。</p>
</blockquote>
<h2 id="update语句没有where条件或者where条件没有索引或者条件的索引没有命中，加什么锁"><a href="#update语句没有where条件或者where条件没有索引或者条件的索引没有命中，加什么锁" class="headerlink" title="update语句没有where条件或者where条件没有索引或者条件的索引没有命中，加什么锁"></a>update语句没有where条件或者where条件没有索引或者条件的索引没有命中，加什么锁</h2><blockquote>
<p>这些情况MySQL都会触发全表扫描，update在全表扫描的时候会对扫描的每一条数据都加上锁，相当于锁住了整个表，具体加的是什么类型的锁，和设置的隔离级别有关：</p>
<ul>
<li>RR：每条记录加的是 next-key lock</li>
<li>RC：加的是record lock</li>
</ul>
<p>所以真实情况一定要避免这些情况的发生，可以通过MySQL提供的<code>sql_safe_updates</code>参数来实现安全的update执行。</p>
</blockquote>
<h2 id="MySQL死锁"><a href="#MySQL死锁" class="headerlink" title="MySQL死锁"></a>MySQL死锁</h2><blockquote>
<p>死锁都是因为存在死锁的四个必要条件而产生的，非抢占、循环等待、占有等待、互斥。MySQL死锁大多是是因为两个线程持有锁但是互相等待对方是释放锁。</p>
<p>出现死锁时，可以通过show engine innodb status查看状态，然后分析死锁日志。</p>
<p>因为死锁是无法完全避免的，所以可以通过：</p>
<ul>
<li>开启MySQL的自动死锁检测，当MySQL发生死锁的时候，会将死锁链上的一个事务进行回滚</li>
<li>设置事务最大等待时间，超时事务回滚，锁释放</li>
<li>不可重复读对系统影响不大的时候将隔离级别设置为读已提交，这样可以减少间隙锁生成</li>
</ul>
</blockquote>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="MySQL有哪些日志"><a href="#MySQL有哪些日志" class="headerlink" title="MySQL有哪些日志"></a>MySQL有哪些日志</h2><blockquote>
<p>undo log：回滚日志，用于保证事务的原子性，以及MVCC机制</p>
<p>redo log：重做日志，用于保证事务的持久性</p>
<p>bin log：二进制日志，主要用于完成数据同步</p>
</blockquote>
<h2 id="redo-log和bin-log有什么区别和应用场景"><a href="#redo-log和bin-log有什么区别和应用场景" class="headerlink" title="redo log和bin log有什么区别和应用场景"></a>redo log和bin log有什么区别和应用场景</h2><blockquote>
<p>redo log 是InnoDB才有的日志，数据引擎层实现的日志；而bin log是MySQL Server层提供的日志</p>
<p>redo log的内容记录的是对于哪个数据页进行了什么操作；而bin log 有三种记录格式：</p>
<ul>
<li>statement：每一条数据的操作都会被记录，但是对于一些函数在主从复制的时候会出现数据不一致的情况，比如说 uuid 和 now</li>
<li>row：记录了完整的改变的数据，这个的问题就是bin log会变得很大</li>
<li>mix：混合模式，根据不同情况使用不同的存储方式</li>
</ul>
<p>redo log写入方式是循环写入；bin log 的写入方式是追加，满了就创建一个新的文件继续写不会覆盖</p>
<p>redo log的写入时机是一个事务每次修改数据都会写入redo log；而bin log只有在事务提交了才会写入bin log</p>
<p>redo log主要用于数据恢复，比如说MySQL宕机、断电；bin log主要做数据备份和主从复制</p>
</blockquote>
<h2 id="redo-log-是怎么实现持久化的"><a href="#redo-log-是怎么实现持久化的" class="headerlink" title="redo log 是怎么实现持久化的"></a>redo log 是怎么实现持久化的</h2><blockquote>
<p>当要修改一个数据的时候，MySQL就会把数据页读取到Buffer Pool中，然后在内存完成修改。MySQL采用的是WAL机制，也就是先写日志的策略，MySQL会先将操作写入redo log buffer中，然后根据一定的刷盘机制redo log buffer就会把数据持久化到磁盘的redo log file上，所以只要写入了redo log file就表示数据已经持久化完成，即使Buffer Pool中的数据因为宕机断电等原因没有写入回磁盘，也无所谓，MySQL重启的时候会通过redo log file进行操作重放得到数据。</p>
</blockquote>
<h2 id="什么是两阶段提交？为什么需要两阶段提交？过程是怎么样的？"><a href="#什么是两阶段提交？为什么需要两阶段提交？过程是怎么样的？" class="headerlink" title="什么是两阶段提交？为什么需要两阶段提交？过程是怎么样的？"></a>什么是两阶段提交？为什么需要两阶段提交？过程是怎么样的？</h2><blockquote>
<p>两阶段提交主要说的是，redo log文件有两个状态，一个是prepare 状态，该状态是事务修改已经写入redo log；但是还没有写入bin log就是这个状态，当事务提交之后也写入bin log之后，redo log的状态就是commit状态。</p>
<p>redo log 需要两个状态主要是为了防止在MySQL集群架构下的数据不一致。因为redo log和bin log的写入时机不同，redo log每次修改数据库都会写入redo log，而bin log只有在事务提交之后才会写入bin log。所以可能在bin log写入之前，数据库出现宕机等问题，导致redo log和bin log两个日志文件逻辑不一致，而在主从复制情况下，主机是通过redo log来完成恢复的，从机通过bin log完成数据恢复，这样就会导致数据的不一致。</p>
<p>过程就是给redo log设置两个状态，进行数据恢复的时候：</p>
<ul>
<li>如果redo log的状态是prepare<ul>
<li>并且没有bin log，此时就会回滚事务；</li>
<li>有bin log，说明是redo log设置commit状态的时候出现问题，此时MySQL会认为数据是完整的，不会进行数据回滚。</li>
</ul>
</li>
<li>如果是commit，更不需要回滚</li>
</ul>
</blockquote>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="怎么判断一个SQL是否走了索引"><a href="#怎么判断一个SQL是否走了索引" class="headerlink" title="怎么判断一个SQL是否走了索引"></a>怎么判断一个SQL是否走了索引</h2><blockquote>
<p>通过explain执行计划查看，结果的type字段，如果不是index或者是ALL则表示没有走索引。或者通过key字段如果是NULL也表示没有走索引。</p>
</blockquote>
<h2 id="using-index和using-where有什么区别"><a href="#using-index和using-where有什么区别" class="headerlink" title="using index和using where有什么区别"></a>using index和using where有什么区别</h2><blockquote>
<p>using index表示使用到了索引覆盖，不需要回表操作；</p>
<p>using where 表示的是存储引擎返回的数据并不是都满足where 条件的，where过滤条件是在server 层进行过滤的，这个时候就会出现using where，索引下推可以解决出现using where的情况。</p>
</blockquote>
<h2 id="怎么找到慢SQL"><a href="#怎么找到慢SQL" class="headerlink" title="怎么找到慢SQL"></a>怎么找到慢SQL</h2><blockquote>
<p>首先要开启慢查询日志，并且设置执行超过多少秒为慢SQL，然后就可以在慢SQL日志里面看到些SQL超过了指定的时间。</p>
</blockquote>
<h2 id="如何优化慢SQL"><a href="#如何优化慢SQL" class="headerlink" title="如何优化慢SQL"></a>如何优化慢SQL</h2><blockquote>
<ul>
<li>避免select *</li>
<li>避免全表扫描</li>
<li>索引能不能走索引覆盖</li>
<li>避免出现索引失效</li>
<li>避免出现 file sort，排序频繁的字段加上索引</li>
<li>分页查询深分页查询要在业务上进行优化</li>
</ul>
</blockquote>
<h2 id="深分页查询如何优化"><a href="#深分页查询如何优化" class="headerlink" title="深分页查询如何优化"></a>深分页查询如何优化</h2><p>深分页指的是分页查询的时候偏移量非常的大的时候，会需要读取大量的没用的数据，分页查询需要到B+树最左边的叶子节点，开始一个个向后遍历到第offset条数据，然后取limit 条数据。在数据非常大的时候，offset非常大时间复杂度会变成O(n)，很影响效率。</p>
<blockquote>
<ul>
<li>在业务层面上进行修改把原本业务是”第几页”，变成每次都是找”下一页”。在有索引的情况下，每次保存索引列的最大值，下次查询的时候每次都用上次最大值作为条件，下次查询携带上大于索引列最大值的条件，这样就不需要加偏移量，可以充分利用索引有序的特性。这种方式非常适合于用在用主键id做分页查询的情况。</li>
<li>不修改业务，还是按照第几页的方式。但是通过索引覆盖+子查询优化SQL。深分页查询慢的根本原因是server层和engine层分层工作，engine只负责拿到数据，对于每一条数据都要交给server层进行判断用户是否需要这条数据，所以如果查询的是非聚簇索引那么所有offset的数据都会进行回表操作，那这个回表的次数就非常的大，所以会非常的慢。所以主要就可以通过索引覆盖减少回表的次数进行优化，子查询通过索引覆盖只查询数据的id，这样在子查询里面做分页就不需要回表，主查询根据查询数据的id判断是否满足条件，这样减少了大量的回表操作，最多只会查询 limit次主表。</li>
</ul>
</blockquote>
<h2 id="如果SQL和索引都没有问题，但是查询还是非常慢怎么办？"><a href="#如果SQL和索引都没有问题，但是查询还是非常慢怎么办？" class="headerlink" title="如果SQL和索引都没有问题，但是查询还是非常慢怎么办？"></a>如果SQL和索引都没有问题，但是查询还是非常慢怎么办？</h2><blockquote>
<p>如果是单机MySQL的情况下，可能是请求过多导致单机MySQL处理请求数据量多大，导致速度慢。可以考虑搭建主从复制模式，来改善MySQL单机MySQL压力过大的问题。</p>
<p>另外如果单表数据过大，可以考虑分表降低单表压力。</p>
<p>写多读少可以考虑分库</p>
</blockquote>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制过程是怎么样的"><a href="#主从复制过程是怎么样的" class="headerlink" title="主从复制过程是怎么样的"></a>主从复制过程是怎么样的</h2><blockquote>
<p>主从复制主要是通过bin log完成的。主库只负责写数据，写的时候主库会把操作写入bin log中，事务提交后。每有一个从库连接主库，就会创建log dump线程，这个线程用于将bin log发给从库。</p>
<p>从库会专门启一个线程去连接主库的 log dump 线程，复制主库的bin log，写入从库的relay log，响应主库。</p>
<p>接着会把relay log在从库中重发里面的写入操作，完整复制的过程。</p>
</blockquote>
<h2 id="MySQL提供了几种复制模式"><a href="#MySQL提供了几种复制模式" class="headerlink" title="MySQL提供了几种复制模式"></a>MySQL提供了几种复制模式</h2><blockquote>
<p>三种：同步复制、异步复制、半同步复制。</p>
<p>同步复制：主库要收到所有从库的响应才会响应会客户端，这种方式的性能是最差的，但是安全性较高，一般用于对安全性要求较高的场景。</p>
<p>异步复制：主库不需要收到从库的响应，主库写入完成就可以响应客户端，从库的复制过程通过异步的方式完成。这种方式的性能最好，但是从库还没完成复制就宕机则会出现数据丢失。</p>
<p>半同步复制：主库只需要收到一个从库的响应，就可以响应客户端，这种方式性能在上面两种方式之间，只要有一个从库完成复制做到了数据一致数据就不会发生丢失。</p>
</blockquote>
<h2 id="MySQL主从架构下，读写分离怎么实现？"><a href="#MySQL主从架构下，读写分离怎么实现？" class="headerlink" title="MySQL主从架构下，读写分离怎么实现？"></a>MySQL主从架构下，读写分离怎么实现？</h2><blockquote>
<p>一种简单的方式就是，把数据源都配置在工程中，然后在改造代码，根据SQL语句进行判断应该使用哪个数据源。这种方式简单，但是会把数据库的路由规则放到代码里面不利于代码维护。</p>
<p>另一种就是直接使用一些中间件比如说MyCat来实现读写分离</p>
</blockquote>
<h2 id="主库挂了怎么办"><a href="#主库挂了怎么办" class="headerlink" title="主库挂了怎么办"></a>主库挂了怎么办</h2><blockquote>
<p>MySQL 没有像Redis那样的哨兵机制，会自动选取新的主机，所以需要使用一些开源套件，比如说MHA来实现，它可以帮助MySQL的主机挂了之后，自动剔除主机，选出新的主机。保证业务的连续性</p>
</blockquote>
<h2 id="什么是分库分表？什么时候要分表？什么时候要分库？"><a href="#什么是分库分表？什么时候要分表？什么时候要分库？" class="headerlink" title="什么是分库分表？什么时候要分表？什么时候要分库？"></a>什么是分库分表？什么时候要分表？什么时候要分库？</h2><blockquote>
<p>分库分表就是把原本单库的数据分到多个数据库，单表的数据分到多个表上。</p>
<p>分表一般是用在解决单表数据量过多或者字段过多的情况下考虑采用的方式，分为水平和垂直划分：</p>
<ul>
<li>水平划分一般是在数据量达到500W以上的时候可以考虑。</li>
<li>垂直划分一般是在表字段非常多的情况下，考虑把不常用的字段划分到另一个表上。</li>
</ul>
<p>分库一般是在写多读少的情况下考虑划分：</p>
<ul>
<li>分库一般会根据业务进行划分，把不同业务的数据表放到不同的库里面</li>
</ul>
</blockquote>
<h2 id="分库分表会出现什么问题？"><a href="#分库分表会出现什么问题？" class="headerlink" title="分库分表会出现什么问题？"></a>分库分表会出现什么问题？</h2><blockquote>
<p>1、分布式事务的问题，SQL涉及到跨库跨表的修改数据会出现分布式事务的问题。</p>
<p>2、全局唯一性ID问题：在单库单表的时，主键可以使用自增的方式，但是分库分表之后如果还是用自增的方式，会出现ID不唯一的情况，所以需要使用一些ID生成算法如：雪花、美团的leaf算法</p>
<p>3、跨库跨表的连表查询：跨库跨表的联表查询会变得很复杂，可以通过冗余字段解决，或者是将数据全量存在ES中，或者分库分表中间件</p>
<p>4、跨库跨表的排序：同样要通过中间件，或者全量写入ES</p>
<p>5、跨库跨表的count：可以将数据单独存在一个表里面，统计哪些数据表的总共的数据量，或者也通过ES。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io">异梦</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yimeng436.github.io/2022/08/21/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">https://yimeng436.github.io/2022/08/21/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yimeng436.github.io" target="_blank">异梦的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/img/top.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/21/SpringCloud/SpringCloud/"><img class="prev-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringCloud</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"><img class="next-cover" src="/img/top.png" onerror="onerror=null;src='/img/cover.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理"><img class="cover" src="/img/top.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">MySQL原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://mms2.baidu.com/it/u=665033858,976373917&amp;fm=253&amp;app=138&amp;f=JPEG&amp;fmt=auto&amp;q=75?w=500&amp;h=500" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">异梦</div><div class="author-info__description">欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yimeng436" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2441844062@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一条SQL的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.</span> <span class="toc-text">MySQL有哪些存储引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">MyISAM和InnoDB的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-%E5%93%AA%E4%B8%AA%E5%BC%95%E6%93%8E%E5%BF%AB"><span class="toc-number">1.4.</span> <span class="toc-text">count(*)哪个引擎快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NULL%E5%80%BC%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">1.5.</span> <span class="toc-text">NULL值是怎么存储的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char%E5%92%8Cvarchar%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">char和varchar有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E5%A6%82%E8%AF%B4%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%98%AFvarchar-10-%EF%BC%8C%E4%BD%86%E5%AE%83%E5%85%B6%E5%AE%9E%E5%8F%AA%E6%9C%896%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%8C%E9%82%A3%E4%BB%96%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8D%A0%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%98%AF%E5%A4%9A%E5%B0%91-%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8D%A0%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">1.7.</span> <span class="toc-text">假如说一个字段是varchar(10)，但它其实只有6个字节，那他在内存中占的存储空间是多少?在文件中占的存储空间是多少?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%93%AA%E4%B8%AA%E6%9B%B4%E6%96%B0%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD"><span class="toc-number">1.8.</span> <span class="toc-text">普通索引和唯一索引有什么区别?哪个更新性能更好?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">MySQL有哪些索引类型?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">InnoDB的索引是什么数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">为什么MySQL索引使用B+树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">MySQL为什么不使用哈希表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">聚簇索引和非聚簇索引有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insert-%E5%88%B0B-%E6%A0%91%E4%BC%9A%E5%AF%B9B-%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">2.6.</span> <span class="toc-text">insert 到B+树会对B+树的结构有什么影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E5%8D%83%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E7%9A%84MySQL%EF%BC%8C%E4%BC%9A%E6%9C%89%E5%A4%9A%E9%AB%98%E7%9A%84B-%E6%A0%91"><span class="toc-number">2.7.</span> <span class="toc-text">两千万条数据的MySQL，会有多高的B+树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">索引应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.</span> <span class="toc-text">为什么要建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">选择哪些字段建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%90%97"><span class="toc-number">3.3.</span> <span class="toc-text">索引是越多越好吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">索引怎么优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E7%94%A8%E5%88%B0%E5%90%97"><span class="toc-number">3.5.</span> <span class="toc-text">建立的索引一定会用到吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">3.6.</span> <span class="toc-text">什么是最左匹配原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-a-b-c-%EF%BC%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%BC%9A%E4%B8%8D%E4%BC%9A%E8%B5%B0%E7%B4%A2%E5%BC%95-%E5%A6%82%E6%9E%9C%E8%B5%B0%E5%85%B7%E4%BD%93%E6%98%AF%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E8%83%BD%E8%B5%B0"><span class="toc-number">3.7.</span> <span class="toc-text">联合索引(a,b,c)，下面的查询语句会不会走索引?如果走具体是哪些字段能走?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#where-a-gt-1-and-b-x3D-2-and-c-lt-3%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">3.8.</span> <span class="toc-text">where a&gt;1 and b &#x3D; 2 and c&lt;3怎么建立索引?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#where-a-gt-100-and-b-x3D-100-and-c-x3D-123-order-by-d%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">3.9.</span> <span class="toc-text">where a&gt;100 and b&#x3D;100 and c&#x3D;123 order by d怎么建立联合索引?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-id-name-from-XX-where-age-gt-10-and-name-like%E2%80%99xx-%E2%80%99%EF%BC%8C%E6%9C%89%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-name-age-%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">3.10.</span> <span class="toc-text">select id, name from XX where age &gt;10 and name like’xx%’，有联合索引(name,age)，说一下查询过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%B8%AAvarchar%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%98%AF-96-20230922%E2%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%E4%B8%8A%E6%9C%89%E7%B4%A2%E5%BC%95%EF%BC%8C%E9%82%A3%E5%A6%82%E6%9E%9C%E6%88%91%E6%9F%A5%E8%AF%A2%E7%9A%84wher%E6%9D%A1%E4%BB%B6%E6%98%AFwhere-time-x3D-20230922%E4%B8%8D%E5%8A%A0%E5%8D%95%E5%BC%95%E5%8F%B7%EF%BC%8C%E8%BF%98%E4%BC%9A%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">3.11.</span> <span class="toc-text">如果我定义了一个varchar类型的日期字段，并且有一个数据是&#96;20230922’，如果这个日期字段上有索引，那如果我查询的wher条件是where time&#x3D;20230922不加单引号，还会命中索引吗?为什么?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">事务特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-number">4.2.</span> <span class="toc-text">事务的原子性如何保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-number">4.3.</span> <span class="toc-text">事务的持久性如何保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-number">4.4.</span> <span class="toc-text">事务的隔离性如何保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-number">4.5.</span> <span class="toc-text">事务的一致性如何保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">并发事务会出现哪些问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">事务的隔离级别有哪些，解决了哪些问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AAMVCC"><span class="toc-number">4.8.</span> <span class="toc-text">介绍一个MVCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%AE%B0%E5%BD%95%E5%AF%B9%E6%9F%90%E4%B8%80%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A7%81"><span class="toc-number">4.9.</span> <span class="toc-text">MVCC如何判断记录对某一事务是否可见</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84MVCC%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.</span> <span class="toc-text">读已提交和可重复读的MVCC机制实现有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E7%94%A8%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">为什么互联网公司用读已提交的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">可重复读解决了什么问题？有没有完全解决幻读？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%BD%E9%97%AE%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB"><span class="toc-number">4.13.</span> <span class="toc-text">追问什么时候会发生幻读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">线上修改表结构会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update%E8%AF%AD%E5%8F%A5%E6%B2%A1%E6%9C%89where%E6%9D%A1%E4%BB%B6%E6%88%96%E8%80%85where%E6%9D%A1%E4%BB%B6%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95%E6%88%96%E8%80%85%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%B4%A2%E5%BC%95%E6%B2%A1%E6%9C%89%E5%91%BD%E4%B8%AD%EF%BC%8C%E5%8A%A0%E4%BB%80%E4%B9%88%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">update语句没有where条件或者where条件没有索引或者条件的索引没有命中，加什么锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.</span> <span class="toc-text">MySQL死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">6.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E6%97%A5%E5%BF%97"><span class="toc-number">6.1.</span> <span class="toc-text">MySQL有哪些日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log%E5%92%8Cbin-log%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.2.</span> <span class="toc-text">redo log和bin log有什么区别和应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84"><span class="toc-number">6.3.</span> <span class="toc-text">redo log 是怎么实现持久化的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9F%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">什么是两阶段提交？为什么需要两阶段提交？过程是怎么样的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AASQL%E6%98%AF%E5%90%A6%E8%B5%B0%E4%BA%86%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.</span> <span class="toc-text">怎么判断一个SQL是否走了索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-index%E5%92%8Cusing-where%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">using index和using where有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E6%85%A2SQL"><span class="toc-number">7.3.</span> <span class="toc-text">怎么找到慢SQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%85%A2SQL"><span class="toc-number">7.4.</span> <span class="toc-text">如何优化慢SQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">深分页查询如何优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CSQL%E5%92%8C%E7%B4%A2%E5%BC%95%E9%83%BD%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9F%A5%E8%AF%A2%E8%BF%98%E6%98%AF%E9%9D%9E%E5%B8%B8%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">如果SQL和索引都没有问题，但是查询还是非常慢怎么办？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">8.1.</span> <span class="toc-text">主从复制过程是怎么样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%8F%90%E4%BE%9B%E4%BA%86%E5%87%A0%E7%A7%8D%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">MySQL提供了几种复制模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E4%B8%8B%EF%BC%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">MySQL主从架构下，读写分离怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">8.4.</span> <span class="toc-text">主库挂了怎么办</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A6%81%E5%88%86%E8%A1%A8%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A6%81%E5%88%86%E5%BA%93%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">什么是分库分表？什么时候要分表？什么时候要分库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">分库分表会出现什么问题？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="MySQL原理"/></a><div class="content"><a class="title" href="/2023/08/19/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/MySQL%E5%8E%9F%E7%90%86%E9%83%A8%E5%88%86/" title="MySQL原理">MySQL原理</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="算法笔记"/></a><div class="content"><a class="title" href="/2023/08/19/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记">算法笔记</a><time datetime="2023-08-18T16:00:00.000Z" title="发表于 2023-08-19 00:00:00">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="前端知识"/></a><div class="content"><a class="title" href="/2023/06/06/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/" title="前端知识">前端知识</a><time datetime="2023-06-05T16:00:00.000Z" title="发表于 2023-06-06 00:00:00">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="FSAF论文"/></a><div class="content"><a class="title" href="/2022/10/14/Paper-FSAF/Paper-FSAF/" title="FSAF论文">FSAF论文</a><time datetime="2022-10-13T16:00:00.000Z" title="发表于 2022-10-14 00:00:00">2022-10-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文"><img src="/img/top.png" onerror="this.onerror=null;this.src='/img/cover.png'" alt="Faster-RCNN论文"/></a><div class="content"><a class="title" href="/2022/08/25/Paper-Faster-RCNN/Paper-Faster-RCNN/" title="Faster-RCNN论文">Faster-RCNN论文</a><time datetime="2022-08-24T16:00:00.000Z" title="发表于 2022-08-25 00:00:00">2022-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 异梦</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>